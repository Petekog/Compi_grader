diff --git a/reader.ml b/reader.ml
index 32445c2..7c5406c 100644
--- a/reader.ml
+++ b/reader.ml
@@ -29,18 +29,349 @@ let rec sexpr_eq s1 s2 =
   | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
   | _ -> false;;
 
-module Reader: sig
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+
+
+open PC;;
+
+(********** HELPER NTs**********)
+
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+  
+let make_spaced nt =
+  make_paired nt_whitespace nt_whitespace nt;;
+
+let _backslash = char '/';;
+let _dot = char '.';;
+let _semicolon = char ';';;
+let _end_of_line = char '\n';;
+let _open_par = char '(';;
+let _close_par = char ')';;
+let end_of_input = pack (nt_end_of_input) (fun c -> 'x');;
+let _delim_pred = fun ch -> ((ch <= ' ') || (ch = ')'));;
+
+let make_parentheses nt = 
+  make_paired _open_par _close_par nt;;
+
+
+let _visible_chars_list = range '!' '~';;
+
+let not_char = make_char (fun ch1 ch2 -> ch1 != ch2);;
+
+
+let _visible_chars = pack _visible_chars_list (fun (c) -> c);;
+
+let _digit = range '0' '9';;
+
+
+
+
+(* boolean *)
+let nt_boolean_true = 
+  let _true_parser = word_ci "#t" in
+  pack _true_parser (fun (l) -> Bool(true));;
+
+let nt_boolean_false = 
+  let _false_parser = word_ci "#f" in
+  pack _false_parser (fun (l) -> Bool(false));;
+  
+let _boolean = (disj nt_boolean_false nt_boolean_true);;
+
+
+
+(***** SYMBOLS *****)
+
+let _r = pack (word "\\r") (fun r -> '\r');;
+let _t = pack (word "\\t") (fun t -> '\t');;
+let _n = pack (word "\\n") (fun n -> '\n');;
+let _f = pack (word "\\f") (fun f -> char_of_int(12));;
+let _bs = pack (word "\\\\") (fun bs -> '\\');;
+let _dq = pack (word "\\\"") (fun dq -> '\"');;
+
+let _string_meta = disj_list [ _r; _t; _n; _f; _bs; _dq];;
+
+let _special_chars = one_of "!$^*-_=+<>/?:";;
+
+let _symbol_char_no_dot_helper = disj_list [_digit; (range_ci 'a' 'z'); _special_chars];;
+
+let _symbol_char_no_dot = 
+  pack _symbol_char_no_dot_helper
+    (fun s -> Symbol(String.lowercase_ascii (list_to_string [s])));;
+
+let _symbol_char = disj _symbol_char_no_dot_helper _dot;;
+
+let _symbol_char_with_dot = 
+  pack (caten _symbol_char (plus _symbol_char))
+  (fun (a, b) -> Symbol(String.lowercase_ascii (list_to_string (a :: b))));;
+
+let _symbol = disj _symbol_char_with_dot _symbol_char_no_dot;;
+
+
+
+(* NUMBERS*)
+
+
+
+let _plus_or_minus = 
+  pack (disj (char '+') (char '-')) 
+  (fun s -> match s with
+  | '-' -> -1
+  | '+' -> 1
+  | _ -> raise X_no_match);;
+
+let _natural = pack (plus _digit) (fun (s) -> int_of_string (list_to_string s));;
+
+let _float = pack (caten (maybe _plus_or_minus) 
+                        (caten (plus _digit)
+                          (caten _dot (plus _digit))))
+                      (fun (sign, (before, (dot, after))) -> match sign, before, dot, after with
+                      | Some s, b, d, a ->  Float((float_of_int s) *. (float_of_string (String.concat "" [list_to_string b; String.make 1 d; list_to_string a])))
+                      | _, b, d, a -> Float(float_of_string (String.concat "" [list_to_string b; String.make 1 d; list_to_string a])))
+
+
+
+let rec _gcd a b = 
+if b = 0 then a else _gcd b (a mod b);;
+
+
+let _create_fraction sign nomin domin =
+  let gcd = _gcd nomin domin in
+  let nomin = nomin / gcd in
+  let domin = domin / gcd in
+  Fraction(sign * nomin, domin);;
+
+
+let _fraction = pack (caten (maybe _plus_or_minus) 
+  (caten _natural 
+    (caten _backslash _natural)))
+    (fun (sign, (nomin, (backslash, domin))) -> match sign, nomin, backslash, domin with
+    | Some s, n, b, d -> _create_fraction s n d
+    | _, n, b, d -> _create_fraction 1 n d);;
+
+
+let _integer = pack (caten (maybe _plus_or_minus) _natural)
+(fun (sign, num) -> match sign, num with
+| Some s, n -> Fraction(s * n, 1)
+| None, n -> Fraction(n, 1));;
+
+
+let _scientific_number = 
+  pack (caten (caten (disj _float _integer) (char_ci 'e')) _integer)
+    (fun (c) -> match c with
+    | ((Fraction(num, _), e), Fraction(exp, _)) -> Float(float_of_string(string_of_int num) *. (10.0 ** float_of_string(string_of_int exp)))
+    | ((Float(num), e), Fraction(exp, _)) -> Float(num *. (10.0 ** float_of_string(string_of_int exp)))
+    | _ -> raise X_no_match);;
+
+
+
+let _number = pack (not_followed_by (disj_list [_scientific_number; _fraction; _float; _integer]) _symbol) (fun n -> Number n);;
+
+
+
+
+(***** CHARS *****)
+
+let _char_prefix = word "#\\" ;;
+let _nul = pack (word_ci "#\\nul") (fun (w) -> char_of_int(0));;
+let _newline = pack (word_ci "#\\newline") (fun (w) -> char_of_int(10));;
+let _return = pack (word_ci "#\\return") (fun (w) -> char_of_int(13));;
+let _tab = pack (word_ci "#\\tab") (fun (w) -> char_of_int(9));;
+let _page = pack (word_ci "#\\page") (fun (w) -> char_of_int(12));;
+let _space = pack (word_ci "#\\space") (fun (w) -> char_of_int(32));;
+
+let _named_chars = disj_list [_nul; _newline; _return; _tab; _page; _space];;
+
+
+let _prefix_visible_chars = pack (caten _char_prefix _visible_chars_list) (fun (pre, ch) -> ch);;
+
+
+let _characters = pack (disj _named_chars _prefix_visible_chars) (fun s -> Char(s));;
+
+
+
+(******** STRING ********)
+
+let _string_literal_char = const(fun c -> c != '\\' && c != '\"' );;
+
+
+let _string_char = disj _string_literal_char _string_meta;;
+
+
+let _string = 
+  pack (caten (char '\"') (caten (star _string_char) (char '\"')))
+  (fun (_, (text, _)) -> String (list_to_string text));;
+
+
+(**** COMMENTS ****)
+
+
+let _line_comment =
+  pack (caten (caten _semicolon (star (not_char '\n'))) (disj (char '\n') end_of_input))
+    (fun c -> 'x');;
+
+
+(* let _skip_parser = 
+  pack (star (disj _comments nt_whitespace)) (fun c -> 'x');; *)
+
+
+
+
+
+(********* LISTS **********)
+
+
+
+let _emptyList = pack (caten _open_par _close_par) (fun _ -> Nil);;
+
+
+
+
+let rec _sexpr_parser x = 
+  let _packed_ = pack (disj_list [_s_list_regular; _s_list_dotted_regular; _s_character;
+                                  _s_string; _s_number; _s_symbol; _s_boolean; _s_quote; _s_quasiquote; _s_unquote; _s_unquote_splicing; _s_nil])
+  (fun expr -> expr) in
+
+  _packed_ x
+  and _quote x = let _packed_ = pack (caten (char '\'') _sexpr_parser)
+    (fun (a, b) -> Pair(Symbol("quote"), Pair(b, Nil))) in
+
+  _packed_ x
+  and _quasiquote x = let _packed_ = pack (caten (char '`') _sexpr_parser)
+  (fun (a, b) -> Pair(Symbol("quasiquote"), Pair(b, Nil))) in
+
+  _packed_ x
+  and _unquote x = let _packed_ = pack (caten (char ',') _sexpr_parser)
+  (fun (a, b) -> Pair(Symbol("unquote"), Pair(b, Nil))) in
+
+
+  _packed_ x
+  and _unquote_splicing x = let _packed_ = pack (caten (word ",@") _sexpr_parser)
+  (fun (a, b) -> Pair(Symbol("unquote-splicing"), Pair(b, Nil))) in
+
+  _packed_ x
+  and _list_regular x = let _packed_ = 
+  pack (make_parentheses (star _sexpr_parser))
+    (fun expr -> List.fold_right (fun expr1 expr2 -> Pair(expr1, expr2)) expr Nil) in
+
+  
+  _packed_ x
+  and _list_dotted_regular x = let _packed_ = 
+  pack (make_parentheses (caten (plus _sexpr_parser) (caten _dot _sexpr_parser)))
+    (fun (list_expr, (d, expr)) -> List.fold_right(fun expr1 expr2 -> Pair(expr1, expr2)) list_expr expr) in
+
+  
+_packed_ x
+  and _s_comment x = let _packed_ = 
+    pack (caten (word "#;") _sexpr_parser) (fun _ -> 'x') in
+
+_packed_ x
+  and _comment x = let _packed_ = 
+    pack (disj _s_comment _line_comment) (fun _ -> 'x') in
+
+_packed_ x
+  and _star_skip x = let _packed_ =
+    pack (star (disj _comment nt_whitespace)) (fun c -> 'x') in
+
+_packed_ x
+  and _clean_nt_parser parser x = let _packed_ = make_paired _star_skip _star_skip parser in
+
+_packed_ x
+  and _nil x = let _packed_ = 
+  pack (caten (caten _open_par _star_skip) _close_par) (fun _ -> Nil) in
+
+_packed_ x
+  and _s_boolean x = let _packed_ =
+  pack (_clean_nt_parser _boolean) (fun term -> term) in
+
+_packed_ x
+  and _s_character x = let _packed_ =
+  pack (_clean_nt_parser _characters) (fun term -> term) in
+
+_packed_ x
+  and _s_number x = let _packed_ =
+  pack (_clean_nt_parser _number) (fun term -> term) in
+
+
+_packed_ x
+  and _s_string x = let _packed_ =
+  pack (_clean_nt_parser _string) (fun term -> term) in
+
+_packed_ x
+  and _s_symbol x = let _packed_ =
+  pack (_clean_nt_parser _symbol) (fun term -> term) in
+
+
+_packed_ x
+  and _s_quote x = let _packed_ =
+  pack (_clean_nt_parser _quote) (fun term -> term) in
+
+  _packed_ x
+  and _s_quasiquote x = let _packed_ =
+  pack (_clean_nt_parser _quasiquote) (fun term -> term) in
+
+
+  _packed_ x
+  and _s_unquote x = let _packed_ =
+  pack (_clean_nt_parser _unquote) (fun term -> term) in
+
+  
+  _packed_ x
+  and _s_unquote_splicing x = let _packed_ =
+  pack (_clean_nt_parser _unquote_splicing) (fun term -> term) in
+
+
+  _packed_ x
+  and _s_list_regular x = let _packed_ =
+  pack (_clean_nt_parser _list_regular) (fun term -> term) in
+
+
+  _packed_ x
+  and _s_list_dotted_regular x = let _packed_ =
+  pack (_clean_nt_parser _list_dotted_regular) (fun term -> term) in
+
+  _packed_ x
+  and _s_nil x = let _packed_ =
+  pack (_clean_nt_parser _nil) (fun term -> term) in
+
+  _packed_ x;;
+
+
+
+
+  module Reader: sig
+    val read_sexprs : string -> sexpr list
+  end
+  = struct
+  let normalize_scheme_symbol str =
+    let s = string_to_list str in
+    if (andmap
+    (fun ch -> (ch = (lowercase_ascii ch)))
+    s) then str
+    else Printf.sprintf "|%s|" str;;
+  
+  
+  let read_sexprs string = (fun (x, y) -> x) ((star _sexpr_parser) (string_to_list string));;
+  
+  
+  end;; (* struct Reader *)
+  
+  
+
+
+
+  
+
+  
+    
+
+  
+  
+
+
   
-end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..61a9fd9 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,7 @@
+I, Topaz Radian ID 204078455, assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..41c02ea 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,4 +1,5 @@
 #use "tag-parser.ml";;
+open Tag_Parser;;
 
 type var = 
   | VarFree of string
@@ -60,6 +61,442 @@ let rec expr'_eq e1 e2 =
                       
 exception X_syntax_error;;
 
+
+(************ HELPER FUNCTIONS **********)
+
+
+let rec get_idx_helper x env acc = match env with 
+| [] -> -1
+| a::b -> if(compare x a == 0) 
+          then acc
+          else get_idx_helper x b (acc + 1);;
+
+let get_idx x env = get_idx_helper x env 0;;
+
+
+
+
+let rec get_nested_env x rest_env num = match rest_env with
+    | [] -> VarFree(x)
+    | a::b -> if(List.mem x a)
+              then let i = get_idx x a in
+                VarBound(x, num, i)
+              else get_nested_env x b (num + 1);;
+
+
+
+let var_annotater x env = match env with
+| [] -> VarFree(x)
+| first::rest -> if(List.mem x first)
+                  then VarParam(x, get_idx x first)
+                  else (get_nested_env x env (-1));;
+
+
+
+  (********* LEXICAL ADDRESS *********)
+
+
+  let extend_environment current_env new_params = match current_env, new_params with
+  | [[]], [] -> []
+  | [[]], x -> [x]
+  | _ -> List.cons new_params current_env
+;;
+
+let rec annotate_lexical_helper expr env = match expr with
+| Const(x) -> Const'(x)
+| Var(x) -> Var'(var_annotater x env)
+| If(testCase, thenCase, elseCase) -> If'(annotate_lexical_helper testCase env, annotate_lexical_helper thenCase env, annotate_lexical_helper elseCase env)
+| Set(Var(name), value) -> Set'((var_annotater name env), annotate_lexical_helper value env)
+| Def(Var(name), value) -> Def'(var_annotater name env, annotate_lexical_helper value env)
+| Or(exprList) -> Or'(map exprList env)
+| Seq(exprList) -> Seq'(map exprList env)
+| Applic(expr, exprList) -> Applic'(annotate_lexical_helper expr env, map exprList env)
+| LambdaSimple(args, body) -> LambdaSimple'(args, annotate_lexical_helper body (extend_environment env args))
+| LambdaOpt(args, opt, body) -> LambdaOpt'(args, opt, annotate_lexical_helper body (extend_environment env (List.append args [opt])))
+| _ -> raise X_syntax_error
+
+
+
+and map ex_list env = match ex_list with
+| [] -> []
+| ex::rest_list -> let a = annotate_lexical_helper ex env in a::(map rest_list env)
+
+;;
+
+
+(************ TAIL RECURSION **************)
+
+
+
+let rec tail_calls_helper expr in_tp = match expr with
+| Var'(x) -> Var'(x)
+| Const'(x) -> Const'(x)
+| If'(testCase, thenCase, elseCase) -> If'(tail_calls_helper testCase false,
+tail_calls_helper thenCase in_tp,
+tail_calls_helper elseCase in_tp)
+| Def'(name, value) -> Def'(name, tail_calls_helper value false)
+| Set'(name, value) -> Set'(name, tail_calls_helper value false)
+| Or'(exprList) -> Or'(last_decide_tp exprList in_tp)
+| Seq'(exprList) -> Seq'(last_decide_tp exprList in_tp)
+| LambdaSimple'(params, body) -> LambdaSimple'(params, tail_calls_helper body true)
+| LambdaOpt'(params, opt, body) -> LambdaOpt'(params, opt, tail_calls_helper body true)
+| Applic'(expr, exprList) -> if(in_tp)
+then ApplicTP'(tail_calls_helper expr false, set_all_tp exprList false)
+else Applic'(tail_calls_helper expr false, set_all_tp exprList false)
+| _ -> raise X_syntax_error
+
+
+and set_all_tp = fun expr_list is_tp ->
+match expr_list with
+| [] -> []
+| x::y -> (List.cons (tail_calls_helper x is_tp) (set_all_tp y is_tp))
+
+and last_decide_tp = fun expr_list is_tail_position ->
+  match expr_list with
+    | [] -> []
+    | [x] -> [tail_calls_helper x true]
+    | x::y -> (List.cons (tail_calls_helper x false) (last_decide_tp y is_tail_position))
+;;
+
+
+
+(************** BOXING ****************)
+
+let add_to_end = fun obj l -> (List.rev (List.cons obj (List.rev l)));;
+
+
+
+
+let rec boxing expr param = match expr with
+  | Const'(x) -> Const'(x)
+  | Var'(VarFree(x)) -> Var'(VarFree(x))
+  | Var'(VarParam(x, minor)) -> if(compare param x == 0) then BoxGet'(VarParam(x, minor)) 
+        else Var'(VarParam(x, minor))
+  | Var'(VarBound(x, major, minor)) -> if(compare param x == 0) then BoxGet'(VarBound(x, major, minor)) 
+          else Var'(VarBound(x, major, minor))
+  | If'(testCase, thenCase, elseCase) -> If'(boxing testCase param, boxing thenCase param, boxing elseCase param)
+  | Def'(name, value) -> Def'(name, boxing value param)
+
+  | Set'(VarParam(x, minor), value) -> if(compare param x == 0) then BoxSet'(VarParam(x, minor), boxing value param) 
+                else Set'(VarParam(x, minor), boxing value param)
+  | Set'(VarBound(x, major, minor), value) -> if(compare param x == 0) then BoxSet'(VarBound(x, major, minor), boxing value param) 
+                        else Set'(VarBound(x, major, minor), boxing value param)
+  | Set'(x, value) -> Set'(x, boxing value param)
+
+  | Or'(exprList) -> Or'(map_box exprList param)
+  | Seq'(exprList) -> Seq'(map_box exprList param)
+  | LambdaSimple'(args, body) ->  if(List.mem param args)
+                                  then LambdaSimple'(args, body)
+                                  else LambdaSimple'(args, boxing body param)
+  | LambdaOpt'(args, opt, body) -> if(List.mem param (List.cons  opt args))
+  then LambdaOpt'(args, opt, body)
+  else LambdaOpt'(args, opt, boxing body param)
+  | Applic'(expr, exprList) -> Applic'(boxing expr param, map_box exprList param)
+  | ApplicTP'(expr, exprList) -> ApplicTP'(boxing expr param, map_box exprList param)
+  | BoxSet'(x, y) -> BoxSet'(x, boxing y param)
+  | x -> x
+
+
+
+
+
+
+
+  
+
+
+and map_box expr_list par = match expr_list with
+  | [] -> []
+  | x::y -> (boxing x par)::(map_box y par)
+
+
+;;
+
+
+let rec is_boxing get_set_list = match get_set_list with
+| [] -> false
+| [has_get, has_set]::rest -> let rec needs_boxing rest = match rest with
+                                | [] -> false, false
+                                | [get, set]::y -> let rest_get, rest_set = needs_boxing y in
+                                                    (get || rest_get), (set || rest_set) 
+                                | _ -> raise X_syntax_error
+                              in let rest_get, rest_set = needs_boxing rest in
+                              ((has_get && rest_set) || (has_set && rest_get)) || (is_boxing rest)
+| _ -> raise X_syntax_error
+;;
+
+
+
+
+
+let find_write_occurr arg expr = match expr with
+                                | Set'(VarParam(x, minor), value) -> compare x arg == 0
+                                | Set'(VarBound(x, major, minor), value) -> compare x arg == 0
+                                | Set'(VarFree(x), value) -> compare x arg == 0
+                                | _ -> false
+;;
+
+let find_read_occurr arg expr = match expr with
+  | Var'(VarParam(x, minor)) -> compare x arg == 0
+  | Var'(VarBound(x, major, minor)) -> compare x arg == 0
+  | _ -> false
+;;
+
+
+let encase_expr_in_seq arg argNumber body = match body with
+  | Seq'(exprList) -> Seq'(List.cons (Set'(VarParam(arg, argNumber), Box'(VarParam(arg, argNumber)))) exprList)
+  | x -> Seq'([Set'(VarParam(arg, argNumber), Box'(VarParam(arg, argNumber))); x])
+;;
+
+
+
+
+let rec 
+  box_set_func expr = match expr with
+    | Const'(x) -> Const'(x)
+    | Var'(VarFree(x)) -> Var'(VarFree(x))
+    | Var'(VarParam(x, minor)) -> Var'(VarParam(x, minor)) 
+    | Var'(VarBound(x, major, minor)) -> Var'(VarBound(x, major, minor)) 
+    | If'(testCase, thenCase, elseCase) -> If'(box_set_func testCase, box_set_func thenCase, box_set_func elseCase)
+    | Def'(name, value) -> Def'(name, box_set_func value)
+    | Set'(VarParam(x, minor), value) -> Set'(VarParam(x, minor), box_set_func value)
+    | Set'(VarBound(x, major, minor), value) -> Set'(VarBound(x, major, minor), box_set_func value)
+    | Set'(x, value) -> Set'(x, box_set_func value)
+    | Or'(exprList) -> Or'(List.map box_set_func exprList)
+    | Seq'(exprList) -> Seq'(List.map box_set_func exprList)
+
+    | LambdaSimple'(args, body) -> LambdaSimple'(args, lambda_boxer args body 0)
+    | LambdaOpt'(args, opt, body) -> LambdaOpt'(args, opt, lambda_boxer (add_to_end opt args) body 0)
+    
+    | Applic'(expr, exprList) -> Applic'(box_set_func expr, List.map box_set_func exprList)
+    | ApplicTP'(expr, exprList) -> ApplicTP'(box_set_func expr, List.map box_set_func exprList)
+    | x -> x 
+
+
+   
+
+   
+
+
+  and lambda_boxer args body argNumber = match args with
+    | [] -> (box_set_func body)
+    | arg::rest -> 
+      let new_body = check_and_replace_arg arg body in 
+      let needs_encasing = (not (expr'_eq body new_body)) in
+      let new_body = lambda_boxer rest new_body (argNumber + 1) in 
+      if(needs_encasing)
+      then encase_expr_in_seq arg argNumber new_body
+      else new_body
+
+          
+
+      
+
+                       
+  and check_get_or_set_expr arg expr has_get has_set = match expr with
+    | Const'(x) -> has_get, has_set
+    | Var'(VarFree(x)) -> has_get, has_set
+    | Var'(VarParam(x, minor)) -> compare x arg == 0 || has_get, has_set 
+    | Var'(VarBound(x, major, minor)) -> compare x arg == 0 || has_get, has_set
+    | If'(testCase, thenCase, elseCase) -> let isGet_test, isSet_test = check_get_or_set_expr arg testCase has_get has_set in
+                                            let isGet_then, isSet_then = check_get_or_set_expr arg thenCase has_get has_set in                                        
+                                            let isGet_else, isSet_else = check_get_or_set_expr arg elseCase has_get has_set in
+                                            (has_get || isGet_test || isGet_then || isGet_else), (has_set || isSet_test || isSet_then || isSet_else)
+    | Def'(name, value) -> check_get_or_set_expr arg value has_get has_set
+
+    | Set'(VarParam(x, minor), value) -> check_get_or_set_expr arg value has_get ((compare x arg == 0) || has_set) 
+    | Set'(VarBound(x, major, minor), value) -> check_get_or_set_expr arg value has_get ((compare x arg == 0) || has_set) 
+    | Set'(VarFree(x), value) -> check_get_or_set_expr arg value has_get has_set 
+    
+    | Or'(exprList) -> (get_or_set_expr_map arg exprList has_get has_set)                      
+    | Seq'(exprList) -> (get_or_set_expr_map arg exprList has_get has_set)
+    | LambdaSimple'(args, body) -> if(List.mem arg args)
+                                    then has_get, has_set
+                                    else check_get_or_set_expr arg body has_get has_set
+    | LambdaOpt'(args, opt, body) -> if(List.mem arg (List.cons opt args))
+                                      then has_get, has_set
+                                      else check_get_or_set_expr arg body has_get has_set
+
+    | Applic'(expr, exprList) -> get_or_set_expr_map arg (List.cons expr exprList) has_get has_set
+    | ApplicTP'(expr, exprList) -> get_or_set_expr_map arg (List.cons expr exprList) has_get has_set
+    | Box'(x) -> has_get, has_set
+    | BoxGet'(x) -> has_get, has_set
+    | BoxSet'(x, y) -> check_get_or_set_expr arg y has_get has_set
+
+
+    
+
+
+
+
+
+
+
+  and get_or_set_expr_map par expr_list has_get has_set= match expr_list with
+    | [] -> has_get, has_set
+    | x::y -> let curr_get, curr_set = (check_get_or_set_expr par x has_get has_set) in
+              let rest_get, rest_set = (get_or_set_expr_map par y has_get has_set) in
+              curr_get || rest_get, curr_set || rest_set
+
+
+
+
+  and check_ribs_of_applic arg expr_list = match expr_list with
+    | [] -> false
+    | expr::[] -> false
+    | _ -> let get_set_list = map_applic_ribs arg expr_list in
+            is_boxing get_set_list
+
+
+  and map_applic_ribs arg exprList = match exprList with
+    | [] -> []
+    | expr::rest -> let has_get, has_set = check_get_or_set_expr arg expr false false in
+                    (List.cons ([has_get,has_set]) (map_applic_ribs arg rest))
+      
+
+
+
+                
+
+  and check_and_replace_ribs_of_applic = fun arg expr_list from_Seq->
+    if((check_ribs_of_applic arg expr_list) && ((not from_Seq) || (check_additional_criteria arg expr_list)))
+      then (map_box expr_list arg)
+      else expr_list
+
+
+
+
+
+  and check_additional_criteria arg exprList = match exprList with
+    | [] -> true
+    | expr::rest -> (match (find_write_occurr arg expr) with
+                      | true -> (not (check_read_occurrence arg rest)) && (check_additional_criteria arg rest)
+                      | false -> (match (find_read_occurr arg expr) with
+                                  | true -> (not (check_write_occurrence arg rest)) && (check_additional_criteria arg rest)
+                                  | false -> check_additional_criteria arg rest
+                                  )
+                    )
+
+
+                    
+  
+
+
+  and check_read_occurrence arg exprList = match exprList with
+    | [] -> false
+    | expr::rest -> let is_read_exp = find_read_occurr arg expr in
+                    let rec find_read arg expr =  
+                      (match expr with
+                        | Const'(x) -> false
+                        | Var'(VarFree(x)) -> false
+                        | Var'(VarParam(x, minor)) -> compare x arg == 0
+                        | Var'(VarBound(x, major, minor)) -> compare x arg == 0
+                        | If'(testCase, thenCase, elseCase) -> (find_read arg testCase) || (find_read arg thenCase) || (find_read arg elseCase)
+                        | Def'(name, value) -> find_read arg value
+
+                        | Set'(name, value) -> find_read arg value
+                        
+                        | Or'(exprList) -> (find_map arg exprList)                      
+                        | Seq'(exprList) -> (find_map arg exprList)
+                        | LambdaSimple'(args, body) -> if(List.mem arg args)
+                                                        then false
+                                                        else find_read arg body
+                        | LambdaOpt'(args, opt, body) -> if(List.mem arg (List.cons opt args))
+                                                          then false
+                                                          else find_read arg body
+
+                        | Applic'(expr, exprList) -> find_map arg (List.cons expr exprList) 
+                        | ApplicTP'(expr, exprList) -> find_map arg (List.cons expr exprList) 
+                        | Box'(x) -> false
+                        | BoxGet'(x) -> false
+                        | BoxSet'(x, y) -> false
+                      )
+                    and find_map arg exprList = match exprList with
+                      | [] -> false
+                      | expr::rest -> (find_read arg expr) || find_map arg rest
+                    
+                    in if(not is_read_exp) then (find_read arg expr) || (check_read_occurrence arg rest) else false
+
+
+  and check_write_occurrence arg exprList = match exprList with
+    | [] -> false
+    | expr::rest -> let is_write_exp = find_write_occurr arg expr in
+                    let rec find_write arg expr =  
+                      (match expr with
+                        | Const'(x) -> false
+                        | Var'(x) -> false
+                        | If'(testCase, thenCase, elseCase) -> (find_write arg testCase) || (find_write arg thenCase) || (find_write arg elseCase)
+                        | Def'(name, value) -> find_write arg value
+
+                        | Set'(VarParam(x, minor), value) -> compare x arg == 0
+                        | Set'(VarBound(x, major, minor), value) -> compare x arg == 0
+                        | Set'(VarFree(x), value) -> compare x arg == 0
+                        
+                        | Or'(exprList) -> (find_map arg exprList)                      
+                        | Seq'(exprList) -> (find_map arg exprList)
+                        | LambdaSimple'(args, body) -> if(List.mem arg args)
+                                                        then false
+                                                        else find_write arg body
+                        | LambdaOpt'(args, opt, body) -> if(List.mem arg (List.cons opt args))
+                                                          then false
+                                                          else find_write arg body
+
+                        | Applic'(expr, exprList) -> find_map arg (List.cons expr exprList) 
+                        | ApplicTP'(expr, exprList) -> find_map arg (List.cons expr exprList) 
+                        | Box'(x) -> false
+                        | BoxGet'(x) -> false
+                        | BoxSet'(x, y) -> false
+                      )
+                    and find_map arg exprList = match exprList with
+                      | [] -> false
+                      | expr::rest -> (find_write arg expr) || find_map arg rest
+                    
+                      in if(not is_write_exp) then (find_write arg expr) || (check_write_occurrence arg rest) else false
+                      
+
+
+
+  
+    
+
+  and check_and_replace_arg arg body = match body with
+    | Const'(x) -> Const'(x)
+    | Var'(VarFree(x)) -> Var'(VarFree(x))
+    | Var'(VarParam(x, minor)) -> Var'(VarParam(x, minor)) 
+    | Var'(VarBound(x, major, minor)) -> Var'(VarBound(x, major, minor)) 
+    | If'(testCase, thenCase, elseCase) -> let ifClauses = (check_and_replace_ribs_of_applic arg ([testCase; thenCase; elseCase]) false) in
+                                             If'(check_and_replace_arg arg (List.nth ifClauses 0), 
+                                              check_and_replace_arg arg (List.nth ifClauses 1),
+                                              check_and_replace_arg arg (List.nth ifClauses 2))
+    | Def'(name, value) -> Def'(name, check_and_replace_arg arg value)
+    | Set'(VarParam(x, minor), value) -> Set'(VarParam(x, minor), check_and_replace_arg arg value)
+    | Set'(VarBound(x, major, minor), value) -> Set'(VarBound(x, major, minor), check_and_replace_arg arg value)
+    | Set'(x, value) -> Set'(x, check_and_replace_arg arg value)
+
+    | Or'(exprList) -> let new_exprList = (check_and_replace_ribs_of_applic arg exprList false) in
+                      Or'(new_exprList)
+    | Seq'(exprList) ->  let new_exprList = (check_and_replace_ribs_of_applic arg exprList true) in
+                          Seq'(new_exprList)
+                          
+    | LambdaSimple'(args, body) -> LambdaSimple'(args, lambda_boxer args body 0)
+    | LambdaOpt'(args, opt, body) -> LambdaOpt'(args, opt, lambda_boxer (add_to_end opt args) body 0)
+
+    | Applic'(expr, exprList) -> Applic'(check_and_replace_arg arg expr, check_and_replace_ribs_of_applic arg exprList false)
+    | ApplicTP'(expr, exprList) -> ApplicTP'(check_and_replace_arg arg expr, check_and_replace_ribs_of_applic arg exprList false)
+    | Box'(x) -> Box'(x)
+    | BoxGet'(x) -> BoxGet'(x)
+    | BoxSet'(x, y) -> BoxSet'(x, y)
+
+
+  and replace_arg_map par expr_list = match expr_list with
+    | [] -> []
+    | x::y -> (check_and_replace_arg par x)::(replace_arg_map par y)
+;;
+
+
+
+ 
+
 module type SEMANTICS = sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
@@ -69,11 +506,14 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+   
+let annotate_lexical_addresses e = annotate_lexical_helper e [[]];;
+
+let annotate_tail_calls e = tail_calls_helper e false;;
+
+let box_set e = box_set_func e;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
 
-let box_set e = raise X_not_yet_implemented;;
 
 let run_semantics expr =
   box_set
@@ -81,5 +521,3 @@ let run_semantics expr =
        (annotate_lexical_addresses expr));;
   
 end;; (* struct Semantics *)
-
-
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..9ffcfd2 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -40,8 +40,12 @@ let rec expr_eq e1 e2 =
      (expr_eq e1 e2) &&
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
+
                        
+open Reader;;
+
+ 
+
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -50,15 +54,321 @@ end;; (* signature TAG_PARSER *)
 
 module Tag_Parser : TAG_PARSER = struct
 
-let reserved_word_list =
-  ["and"; "begin"; "cond"; "define"; "else";
-   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
-   "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
-   "unquote-splicing"];;  
+  let reserved_word_list =
+    ["and"; "begin"; "cond"; "define"; "else";
+     "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+     "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
+     "unquote-splicing"];;  
+
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+
+   (******** HELPER FUNCTIONS*******)
+
+let rec flatten sexpr l = match sexpr with
+| Nil -> l
+| Pair(x, Nil) -> List.cons x l
+| Pair(x, y) -> List.cons x (flatten y l)
+| _ -> [sexpr];;
+
+let flatten_from_pairs sexpr = flatten sexpr [];;
+
+let rec list_to_pairs sexpr_list = match sexpr_list with 
+| [] -> Nil
+| x::y -> Pair(x, list_to_pairs y);;
+
+let rec flatten_and_remove_nested_seq_aux sexpr l = match sexpr with
+  | Nil -> l
+  | Pair(Symbol("begin"), x) -> flatten_and_remove_nested_seq_aux x l
+  | Pair(Symbol(x), y) -> List.cons (Symbol(x)) (flatten_and_remove_nested_seq_aux y l)
+  | Pair(x, y) -> List.append (flatten_and_remove_nested_seq_aux x []) (flatten_and_remove_nested_seq_aux y l)
+  | _ -> [sexpr];;
+
+  
+
+
+
+
+
+let flatten_and_remove_nested_seq sexpr = flatten_and_remove_nested_seq_aux sexpr [];;
+
+let get_second_elem_pair sexpr = match sexpr with
+    | Pair(x, y) -> y
+    | _ -> sexpr;;
+
+
+
+
+
+let get_first_elem_pair sexpr = match sexpr with
+| Pair(x, y) -> x
+| _ -> sexpr;;
+
+let extract_from_symbol sexpr = match sexpr with 
+| Symbol(x) -> x
+| _ -> raise X_syntax_error;;
+
+
+
+
+let create_begin_body = fun body ->
+Pair(Symbol("begin"), body);;
+
+
+let rec create_args_aux sexpr_list arg_list = match sexpr_list with
+  | [] -> arg_list
+  (*| x::[] -> let arg = List.hd (flatten_from_pairs x) in
+              List.cons arg arg_list*)
+  | x::y -> let arg = List.hd (flatten_from_pairs x) in
+              List.cons arg (create_args_aux y arg_list);;
+
+let create_args sexpr_list = create_args_aux sexpr_list [];;
+
+
+let rec create_exprs_aux sexpr_list expr_list = match sexpr_list with
+| [] -> expr_list
+| x::y -> let expr = (List.hd (List.rev (flatten_from_pairs x))) in
+          List.cons expr (create_exprs_aux y expr_list);;
+
+
+let create_exprs sexpr_list = create_exprs_aux sexpr_list [];;
+
+let rec has_dup sexpr_list = match sexpr_list with
+| [] -> false
+| hd::tl -> List.exists (sexpr_eq hd) tl || has_dup tl;;
+
+
+let build_set_bang = fun arg_name expr -> Pair(Symbol("set!"), Pair(arg_name, Pair(expr, Nil)));;
+
+
+let rec create_set_bang_args sexpr_list acc = match sexpr_list with
+| [] -> acc
+| x::y -> let new_arg = build_set_bang (List.hd(create_args [x])) (List.hd(create_exprs [x])) in
+    List.cons new_arg acc;;
+
+let quote_whatever = Pair (Symbol "quote", Pair (Symbol "whatever", Nil));;
+
+let rec create_letrec_whatever_arg_list_aux sexpr_list acc = match sexpr_list with
+  | [] -> acc
+  | x::y -> let whatever_arg = Pair(List.hd(create_args [x]), Pair(quote_whatever, Nil)) in
+    List.cons whatever_arg (create_letrec_whatever_arg_list_aux y acc);;
+
+let  create_letrec_whatever_arg_list sexpr_list = create_letrec_whatever_arg_list_aux sexpr_list [];;
+
+
+let create_cond_macro_no_rest = fun testCase thenCase -> 
+  Pair (Symbol "let",
+  Pair(Pair (Pair (Symbol("value"), Pair (testCase, Nil)),
+    Pair
+      (Pair (Symbol "f",
+        Pair (Pair (Symbol "lambda", Pair (Nil, Pair(thenCase, Nil))),
+        Nil)), Nil)),
+  Pair(Pair(Symbol "if",
+      Pair (Symbol "value",
+      Pair (Pair (Pair (Symbol "f", Nil),
+        Pair (Symbol "value", Nil)), 
+        Nil))),
+    Nil)));;
+
+
+let create_cond_macro_with_rest = fun testCase thenCase rest_ribs ->
+Pair (Symbol("let"),
+  Pair
+   (Pair (Pair (Symbol("value"), Pair (testCase, Nil)),
+     Pair
+      (Pair (Symbol("f"),
+        Pair (Pair (Symbol("lambda"), Pair (Nil, Pair (thenCase, Nil))),
+         Nil)),
+      Pair(Pair (Symbol("rest"),
+         Pair (Pair (Symbol("lambda"), Pair (Nil, Pair (Pair(Symbol("cond"), rest_ribs), Nil))),
+          Nil)),
+       Nil))),
+   Pair(Pair (Symbol("if"),
+      Pair (Symbol("value"),
+       Pair (Pair (Pair (Symbol("f"), Nil), Pair (Symbol("value"), Nil)),
+        Pair (Pair (Symbol("rest"), Nil), Nil)))),
+    Nil)));;
+
+
+  let create_cond_macro testCase thenCase rest_ribs = match rest_ribs with
+  | Nil -> create_cond_macro_no_rest testCase thenCase
+  | _ -> create_cond_macro_with_rest testCase thenCase rest_ribs;;
+
+
+
+  let rec isProperList sexpr = match sexpr with
+  | Nil -> true
+  | Pair(x, y) -> isProperList y
+  | _ -> false;;
+
+
+    
+  let rec remove_nested_seq seq = match seq with
+  | [] -> []
+  | Seq(x)::y -> List.append (remove_nested_seq x) (remove_nested_seq y)
+  | x::y -> List.cons x (remove_nested_seq y)
+    
+
+let rec tag_parser sexpr = match sexpr with
+  | Nil -> Const(Sexpr(Nil))
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | String(x) -> Const(Sexpr(String(x)))
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | Symbol x -> if((List.mem(x) reserved_word_list)) 
+    then raise X_syntax_error
+    else Var x
+  | Pair(a, b) -> let matching_pair = fun a b -> match a, b with
+
+    | Symbol("begin"), x -> let begin_func x = match x with
+      | Nil -> Const(Void)
+      | Pair(Nil, Nil) -> Const(Void)
+      | Pair(x, Nil) -> tag_parser x
+      | _ -> Seq(remove_nested_seq (List.map tag_parser (flatten_from_pairs x)))
+    in begin_func x
+
+    | Symbol("or"), x -> let or_func x = match x with
+      | Nil -> Const(Sexpr(Bool(false)))
+      | Pair(y, Nil) -> tag_parser y
+      | _ -> Or(List.map tag_parser (flatten_from_pairs x))
+    in or_func x
+
+    | Symbol("and"), x -> let rec and_func x = match x with
+      | Nil -> Const(Sexpr(Bool(true)))
+      | Pair(a, Nil) -> tag_parser a
+      | _ -> If(tag_parser (List.hd (flatten_from_pairs x)), (and_func (get_second_elem_pair x)), Const(Sexpr(Bool(false))))
+
+    in and_func x
+
+    | Symbol("quote"), Pair(x, Nil) -> Const(Sexpr(x))
+    | Symbol("quote"), x -> tag_parser x
+
+    | Symbol("if"), x -> let if_func x = match x with
+      | Pair(testPred, Pair(thenCase, Pair(elseCase, Nil))) -> If(tag_parser testPred, tag_parser thenCase, tag_parser elseCase)
+      | Pair(testPred, Pair(thenCase, Nil)) -> If(tag_parser testPred, tag_parser thenCase, Const(Void))
+      | _ -> raise X_syntax_error
+    in if_func x
+    
+
+    | Symbol("define"), Pair(name, Pair(expr, Nil)) -> let define_func1 name expr = match name with
+    
+      | Symbol(z) -> Def(tag_parser name, tag_parser expr)
+      | Pair (z, w) -> Def(tag_parser z, tag_parser (Pair(Symbol("lambda"), Pair(w, Pair(expr, Nil)))))
+      | _ -> raise X_syntax_error
+
+    in define_func1 name expr
+    | Symbol("define"), Pair(name, expr) -> let define_func2 name expr = match name with
+      | Pair(z, w) -> Def(tag_parser z, tag_parser (Pair(Symbol("lambda"), Pair(w, expr))))
+      | _ -> raise X_syntax_error
+    in define_func2 name expr
+
+
+        
+    | Symbol("lambda"), Pair(a, b) -> let lambda_func = fun x y ->
+        let lambda_simple = fun x y ->
+          let arg_list = flatten_from_pairs x in
+          let stripped_arg_list = List.map extract_from_symbol arg_list in
+          let lambda_body = match y with
+                            | Pair(z, Nil) -> tag_parser z
+                            | _ -> tag_parser (Pair(Symbol("begin"), y))
+          in if ((not (has_dup arg_list)) && y != Nil) then LambdaSimple(stripped_arg_list, lambda_body) else raise X_syntax_error
+      
+        in let lambda_opt = fun x y ->
+          let arg_list = flatten_from_pairs x in
+          let lambda_body = match y with
+                            | Pair(z, Nil) -> tag_parser z
+                            | _ -> tag_parser (Pair(Symbol("begin"), y)) in
+
+          let rev_arg_list = List.rev arg_list in
+          let vs = extract_from_symbol (List.hd rev_arg_list) in
+          let arg_list = List.rev (List.tl rev_arg_list) in
+          let stripped_arg_list = List.map extract_from_symbol arg_list in
+          if((not (has_dup arg_list)) && y != Nil)
+            then
+              LambdaOpt(stripped_arg_list, vs, lambda_body)
+            else
+              raise X_syntax_error in
+        
+        if(isProperList a)
+          then
+            (lambda_simple x y)
+          else
+            (lambda_opt x y) 
+
+        in lambda_func a b
+
+
+
+    | Symbol("let"), x -> let let_func x = match x with
+      | Pair(Nil, body) -> Applic(LambdaSimple(([], tag_parser (create_begin_body body))), [])
+      | Pair(argList, body) -> Applic(LambdaSimple((List.map extract_from_symbol (create_args (flatten_from_pairs argList))), 
+                                tag_parser (create_begin_body body)), 
+                                (List.map tag_parser (create_exprs (flatten_from_pairs argList))))
+      | _ -> raise X_syntax_error
+    in let_func x
+    
+    
+    | Symbol("let*"), x -> let let_star_func x = match x with
+      | Pair(Nil, body) -> tag_parser (Pair(Symbol("let"), Pair(Nil, body)))
+      | Pair(Pair(arg, Nil), body) -> tag_parser (Pair(Symbol("let"), Pair(Pair(arg, Nil), body)))
+      | Pair(Pair(first_arg, tail_arg), body) -> tag_parser (Pair(Symbol("let"), Pair(Pair(first_arg, Nil), 
+                                                            Pair(Pair(Symbol("let*"), Pair(tail_arg, body)), Nil)
+                                                            )))
+      | _ -> raise X_syntax_error
+    in let_star_func x
+
+    | Symbol("letrec"), x -> let letrec_func x = match x with
+      | Pair(Nil, body) -> tag_parser (Pair(Symbol("let"), Pair(Nil, body)))
+      | Pair(argList, body) -> tag_parser (Pair(Symbol("let"), 
+                                              Pair(list_to_pairs (create_letrec_whatever_arg_list (flatten_from_pairs argList)), 
+                                              list_to_pairs (create_set_bang_args (flatten_from_pairs argList) [(Pair(Symbol("let"), Pair(Nil, body)))]) 
+                                              )))
+      | _ -> raise X_syntax_error
+    in letrec_func x
+
+    | Symbol("cond"), x -> let cond_func x = match x with
+      | Pair(Pair(Symbol("else"), elseCase), rest_ribs) -> tag_parser (Pair(Symbol("begin"), elseCase))
+      | Pair(Pair(testCase, Pair(Symbol("=>"), Pair(thenCase, Nil))), rest_ribs) ->
+        tag_parser (create_cond_macro testCase thenCase rest_ribs)
+      
+
+      | Pair(Pair(testCase, thenCase), Nil) -> tag_parser (Pair(Symbol("if"), Pair(testCase, Pair(Pair(Symbol("begin"), thenCase), Nil))))  
+      | Pair(Pair(testCase, thenCase), rest_ribs) -> tag_parser (Pair(Symbol("if"), Pair(testCase, Pair(Pair(Symbol("begin"), thenCase), 
+                                                                Pair(Pair(Symbol("cond"), rest_ribs), Nil)))))
+      | _ -> raise X_syntax_error
+      
+      in cond_func x
+
+    | Symbol("quasiquote"), Pair(x, Nil) ->
+      let rec quasiquote_func x = match x with
+        | Pair(Symbol("unquote"), Pair(y, Nil)) -> y
+        | Pair(Symbol("unquote-splicing"), Pair(y, Nil)) -> raise X_syntax_error
+        | Symbol(y) -> Pair(Symbol("quote"), Pair(Symbol(y), Nil))
+        | Nil -> Pair(Symbol("quote"), Pair(Nil, Nil))
+        | Pair(a, b) -> let helper_fun = fun a b -> match a, b with
+                        | Pair(Symbol("unquote-splicing"), Pair(z, Nil)), b -> Pair(Symbol("append"), Pair(z, Pair((quasiquote_func b), Nil)))
+                        | a, Pair(Symbol("unquote-splicing"), Pair(z, Nil)) -> Pair(Symbol("cons"), Pair((quasiquote_func a), Pair(z, Nil)))
+                        | _ -> Pair(Symbol("cons"), Pair((quasiquote_func a), Pair((quasiquote_func b), Nil)))
+                        in helper_fun a b
+        | _ -> raise X_syntax_error
+      in tag_parser (quasiquote_func x)
+
+
+    | Symbol("set!"), Pair(name, Pair(expr, Nil)) -> let set_func name expr = match name with
+      | Symbol(x) -> Set(tag_parser name, tag_parser expr)
+      | _ -> raise X_syntax_error
+      in set_func name expr
+
+    | _ -> Applic(tag_parser a, List.map tag_parser (flatten_from_pairs b))
+    in matching_pair a b
+    ;;
+
+
+
+
+
+let tag_parse_expressions sexpr = List.map tag_parser sexpr;;
 
   
 end;; (* struct Tag_Parser *)
