diff --git a/reader.ml b/reader.ml
index 32445c2..cb564ec 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,46 +1,289 @@
-
-#use "pc.ml";;
-
-exception X_not_yet_implemented;;
-exception X_this_should_not_happen;;
-  
-type number =
-  | Fraction of int * int
-  | Float of float;;
-  
-type sexpr =
-  | Bool of bool
-  | Nil
-  | Number of number
-  | Char of char
-  | String of string
-  | Symbol of string
-  | Pair of sexpr * sexpr;;
-
-let rec sexpr_eq s1 s2 =
-  match s1, s2 with
-  | Bool(b1), Bool(b2) -> b1 = b2
-  | Nil, Nil -> true
-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
-  | Char(c1), Char(c2) -> c1 = c2
-  | String(s1), String(s2) -> s1 = s2
-  | Symbol(s1), Symbol(s2) -> s1 = s2
-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
-  | _ -> false;;
-
-module Reader: sig
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
-
-
-let read_sexprs string = raise X_not_yet_implemented;;
-  
-end;; (* struct Reader *)
+
+#use "pc.ml";;
+open PC;;
+
+  exception X_not_yet_implemented;;
+  exception X_this_should_not_happen;;
+    
+  type number =
+    | Fraction of int * int
+    | Float of float;;
+    
+  type sexpr =
+    | Bool of bool
+    | Nil
+    | Number of number
+    | Char of char
+    | String of string
+    | Symbol of string
+    | Pair of sexpr * sexpr;;
+
+  let rec sexpr_eq s1 s2 =
+    match s1, s2 with
+    | Bool(b1), Bool(b2) -> b1 = b2
+    | Nil, Nil -> true
+    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+    | Char(c1), Char(c2) -> c1 = c2
+    | String(s1), String(s2) -> s1 = s2
+    | Symbol(s1), Symbol(s2) -> s1 = s2
+    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+    | _ -> false;;
+    
+  
+(*-------------------------------------helper functions-------------------------------------*)
+  let rec gcd a b = 
+    if a = 0 then b
+    else gcd (b mod a) a;;
+
+  let float_of_char c = 
+      let num = (int_of_char c)-(int_of_char '0') in
+        float_of_int num;;
+
+  let rec list_to_proper_list = fun(lst) ->
+    match lst with 
+    | car::cdr -> Pair(car, (list_to_proper_list cdr))
+    | x -> Nil;;
+
+  let rec list_to_improper_list = fun (lst) ->
+    match lst with
+    | [] -> Nil
+    | first :: [] -> Pair(first,Nil)
+    | first :: second :: [] -> Pair(first,second)
+    | first :: rest -> Pair(first,list_to_improper_list rest);;
+
+  let make_paired nt_left nt_right nt =
+    let nt = caten nt_left nt in
+    let nt = pack nt (function (_, e) -> e) in
+    let nt = caten nt nt_right in
+    let nt = pack nt (function (e, _) -> e) in
+      nt;;
+
+  let nt_notEndOfLine = guard nt_any (fun(c) -> c != '\n') ;;
+
+  let nt_LineComment = pack 
+                      (caten (char ';') (caten (star nt_notEndOfLine) (maybe (char '\n')))) 
+                      (fun(_,(list_of_char, _)) -> '_');;
+
+  let nt_WhiteSpace = range (char_of_int 0) ' ';;
+(*-------------------------------------Boolean----------------------------------------------*)
+  let nt_False = pack (word_ci "#f") (fun _ -> Bool(false));;
+  let nt_True = pack (word_ci "#t") (fun _ -> Bool(true));;
+  let nt_Boolean = disj nt_False nt_True;;
+
+
+(*-------------------------------------Char-------------------------------------------------*)
+
+  let nt_CharPrefix = word "#\\";; 
+  let nt_VisibleSimpleChar = guard nt_any (fun c -> c > ' ');;
+  let nt_NamedChar = disj_list 
+                      (pack (word_ci "newline") (fun _ -> char_of_int(10)) :: 
+                      pack (word_ci "nul") (fun _-> char_of_int(0)) ::
+                      pack (word_ci "page") (fun _-> char_of_int(12)) ::
+                      pack (word_ci "return") (fun _-> char_of_int(13)) :: 
+                      pack (word_ci "space") (fun _-> char_of_int(32)) ::
+                      pack (word_ci "tab") (fun _->char_of_int(9)) :: []);;
+
+  let nt_Char = pack (caten nt_CharPrefix (disj nt_NamedChar nt_VisibleSimpleChar)) (fun (_,c) -> Char(c));;
+
+(*-------------------------------------Number-----------------------------------------------*)
+  let digit = range '0' '9';;
+
+  let nt_Sign = 
+    let sign =maybe (disj (char '+') (char '-')) in
+    pack sign 
+    (
+      fun (s) ->
+        match s with 
+        | Some('+') -> 1
+        | Some('-') -> -1
+        | None -> 1
+        | _ -> raise X_no_match
+    )
+    ;;
+
+  let nt_Natural = 
+      let digits = plus digit in
+        pack digits (fun (ds) -> (int_of_string (list_to_string ds)));;
+
+  let nt_Mantissa = 
+    let mantissa = plus digit in
+      pack mantissa (
+                    fun (ds) -> 
+                      List.fold_right 
+                          (fun a b ->
+                            let f = (float_of_char a) in
+                            (f +. b ) /. 10.)
+                          ds 
+                          0.
+                  );;
+
+  let nt_IntegerAsInteger =
+    let integ = caten nt_Sign nt_Natural in
+      pack integ 
+      (
+        fun ((sign,num)) -> 
+          sign*num
+      );; 
+      
+
+  let nt_Fraction = 
+    let frac = caten nt_IntegerAsInteger (caten (char '/') nt_Natural) in
+                pack frac
+                    (fun (nomer,(_,denom)) ->
+                        let gd = gcd nomer denom in
+                        Number(Fraction(nomer/gd , denom/gd))
+                    )
+                  
+              ;;
+
+  let nt_Snotation = pack (caten (char_ci 'e') nt_IntegerAsInteger) (fun (_,exp)-> 10. ** (float_of_int exp)) ;; 
+
+
+  let nt_Integer = 
+    let integ = caten (caten nt_Sign nt_Natural) (maybe nt_Snotation) in
+    pack integ 
+    (
+      fun (((sign,num),snot)) ->
+        match snot with
+      | Some(snot) ->  Number(Float( (float_of_int (sign*num)) *. snot))
+      | None -> Number(Fraction(sign*num,1))
+    );;
+
+
+  let nt_Float = 
+    let flo = caten (caten (maybe nt_Sign) (caten nt_Natural (caten (char '.') nt_Mantissa))) (maybe nt_Snotation) in
+      pack flo
+      (
+        fun ((sign,(rs,(_,ls))),sn) ->
+        match sign, sn with 
+        |Some(sign), Some(sn) -> Number(Float(sn *. (float_of_int sign) *. ((float_of_int rs) +. ls)))
+        |Some(sign), None -> Number(Float((float_of_int sign) *. ((float_of_int rs) +. ls)))
+        |None, Some(sn) -> Number(Float(sn *. ((float_of_int rs) +. ls)))
+        |None, None -> Number(Float(((float_of_int rs) +. ls)))
+          
+      );;
+              
+  let nt_Number = disj_list(
+  nt_Float :: 
+  nt_Fraction::
+  nt_Integer::[]
+  );;
+
+
+(*-------------------------------------String-----------------------------------------------*)
+    let nt_StringMetaChar = 
+    (disj_list (
+      (pack (word "\\\\") (fun _ -> '\\'))::
+      (pack (word "\\\"") (fun _ -> '\"')) ::
+      (pack (word "\\t") (fun _->'\t'))::
+      (pack (word "\\f") (fun _->'\012'))::
+      (pack (word "\\n") (fun _-> '\n' ))::
+      (pack (word "\\r") (fun _-> '\r'))::[]
+      ));;
+        
+  let nt_StringLiteralChar = guard nt_any (fun(c)-> c != '\"' && c != '\\');;
+
+  let nt_StringChar = disj nt_StringMetaChar nt_StringLiteralChar ;;
+
+  let nt_String = 
+    let str = caten (char '\034') 
+  (caten (star nt_StringChar) (char '\034')) in
+  pack str (fun(_, (char_list, _)) -> String(list_to_string char_list));;
+
+(*-------------------------------------Symbol-----------------------------------------------*)
+
+  let nt_Dot = char '.' ;;
+  let nt_Letter = range_ci 'a' 'z';;
+  let nt_PunctuationMark = disj_list(
+                                char '!' ::
+                                char '$' ::
+                                char '^' ::
+                                char '*' ::
+                                char '-' ::
+                                char '_' ::
+                                char '=' ::
+                                char '+' ::
+                                char '<' ::
+                                char '>' ::
+                                char '?' ::
+                                char '/' ::
+                                char ':' :: []);;
+
+  let nt_SymbolCharNoDot = disj digit (disj nt_Letter nt_PunctuationMark);;
+  let nt_SymbolChar = disj nt_SymbolCharNoDot nt_Dot;;
+  let nt_Symbol = 
+    pack((disj 
+            (pack (caten nt_SymbolChar (plus nt_SymbolChar)) (fun (c,ls) -> c::ls))
+            (pack nt_SymbolCharNoDot (fun c -> c::[]))))
+    (fun (symb) -> Symbol(String.lowercase_ascii (list_to_string symb)));;
+
+(*-------------------------------------Sexp-------------------------------------------------*)
+  let rec nt_Sexpr s= 
+  let nt_sexpr = 
+    make_spacedCommented(disj_list ( 
+                  nt_Boolean::  
+                  nt_Char::       
+                  (not_followed_by nt_Number nt_Symbol)::     
+                  nt_String::     
+                  nt_Symbol::
+                  nt_List s::
+                  nt_DottedList s::
+                  nt_Quoted s::     
+                  nt_QuasiQuoted s::
+                  nt_Unquoted s::   
+                  nt_UnquoteAndSpliced s::[])) 
+  in nt_sexpr s
+
+  (*-------------------------------------comments and whitespace------------------------------*)
+  and nt_SexprComment s= (pack 
+  (caten (word "#;") nt_Sexpr) 
+      (fun(_) -> '_')) 
+
+  and nt_CommentOrWhiteSpaces s=
+    star (disj_list([ nt_WhiteSpace; nt_LineComment; nt_SexprComment s]))
+
+  and make_spacedCommented nt s= make_paired (nt_CommentOrWhiteSpaces s) (nt_CommentOrWhiteSpaces s) nt s
+(*-------------------------------------List-------------------------------------------------*)
+  and nt_List s = 
+  pack (caten (char '(') (caten (nt_CommentOrWhiteSpaces s) (caten (star nt_Sexpr) (char ')')))) 
+  (fun (_, (_, (a, _)))->list_to_proper_list a)
+
+  and nt_DottedList s= 
+  pack
+    (caten (char '(') 
+        (caten (plus nt_Sexpr) 
+          (caten (char '.') 
+          (caten nt_Sexpr (char ')'))))) (fun (_, (ls, (_, (rs, _))))-> list_to_improper_list (List.append ls (rs::[])))
+
+(*-------------------------------------Quotes-----------------------------------------------*)
+
+  and nt_Quoted s= pack (caten (char (char_of_int 39)) nt_Sexpr)
+    (fun (_, (sexp)) -> Pair(Symbol("quote") , Pair(sexp, Nil)))
+
+  and nt_QuasiQuoted s= pack (caten (char '`') nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("quasiquote") , Pair(sexp, Nil)))
+
+  and nt_Unquoted s= pack (caten (char ',') nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("unquote") , Pair(sexp, Nil)))
+
+  and nt_UnquoteAndSpliced s= pack (caten (word ",@") nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("unquote-splicing") , Pair(sexp, Nil)));;
+
+
+module Reader: sig
+  val read_sexprs : string -> sexpr list
+end
+= struct
+let normalize_scheme_symbol str =
+  let s = string_to_list str in
+  if (andmap
+  (fun ch -> (ch = (lowercase_ascii ch)))
+  s) then str
+  else Printf.sprintf "|%s|" str;;
+
+
+let read_sexprs string = 
+            let (lst,rest) = test_string (star nt_Sexpr) string in
+            lst;;
+end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..3021a5a 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Mihael amar - 208383984
+Elad feldman - 308385947
+
+I (We) assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..0013ad9 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,5 +1,7 @@
 #use "tag-parser.ml";;
 
+
+
 type var = 
   | VarFree of string
   | VarParam of string * int
@@ -21,6 +23,9 @@ type expr' =
   | Applic' of expr' * (expr' list)
   | ApplicTP' of expr' * (expr' list);;
 
+
+type env = Env of string list;;
+
 let rec expr'_eq e1 e2 =
   match e1, e2 with
   | Const' Void, Const' Void -> true
@@ -56,10 +61,293 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+  | _ -> false;;
+	
+                       
 exception X_syntax_error;;
 
+(* -------------------------------------helper functions--------------------------------------------- *)
+  let rec index_of_rec lst element indx =
+    match lst with
+    | [] -> -1
+    | car::cdr -> 
+        if (car = element) then indx
+        else index_of_rec cdr element (indx + 1);;
+
+  let index_of lst element = 
+    index_of_rec lst element 0;;
+
+  let rec major_minor_rec lst element env_num= 
+    match lst with
+    | [] -> -1, -1
+    | car::cdr -> let indx = index_of car element in
+      if(indx < 0) then major_minor_rec cdr element (env_num +1)
+      else env_num, indx;;
+
+  let major_minor lst element = 
+    major_minor_rec lst element 0;;
+
+(* -------------------------------------annotate lexical--------------------------------------------- *)
+  let make_var x env=
+    match env with
+    | params::env -> let index = index_of params x in
+                    if(index >= 0) then 
+                      VarParam(x, index)
+                    else 
+                      let major, minor = major_minor env x in
+                      if(major >= 0) 
+                        then VarBound(x, major, minor)
+                      else VarFree(x)
+    | [] -> VarFree(x);;
+
+  let rec annotate_lexical e env =
+    match e with 
+    | Const(c) -> Const'(c)
+    | If(test,dit,dif) -> If'(annotate_lexical test env, annotate_lexical dit env, annotate_lexical dif env)
+    | Seq(seq) -> Seq'(List.map (fun exp-> annotate_lexical exp env) seq)
+    | Set(Var(name),vl) -> Set'(make_var name env , annotate_lexical vl env)
+    | Def(Var(name),vl) -> Def'(make_var name env , annotate_lexical vl env)
+    | Or(ors) -> Or'(List.map (fun exp-> annotate_lexical exp env) ors) 
+    | Applic(func , arguments) -> Applic'(annotate_lexical func env, List.map (fun arg -> annotate_lexical arg env) arguments)
+    | LambdaSimple(params,body) -> LambdaSimple'(params , annotate_lexical body (params::env))
+    | LambdaOpt(mandatory , optional , body) -> LambdaOpt'(mandatory, optional , annotate_lexical body  ((List.append mandatory [optional])::env))
+    | Var(x) -> Var'(make_var x env)
+    | _ -> raise X_syntax_error;;
+
+(* -------------------------------------annotate tail calls------------------------------------------ *)
+  let rec annotate_TC expr in_tp = 
+    match expr with 
+    | Const'(x) -> Const'(x)
+    | Var'(var) -> Var'(var)
+    | If'(test,dit,dif) -> If'(annotate_TC test false, annotate_TC dit in_tp, annotate_TC dif in_tp)
+    | Seq'(seq) -> Seq'(List.mapi (fun index expr -> if (index == ((List.length seq) -1)) then annotate_TC expr in_tp else annotate_TC expr false) seq)
+    | Set'(var,vl) -> Set'(var, annotate_TC vl false)
+    | Def'(var,vl) ->Def'(var, annotate_TC vl false)
+    | Or'(ors) -> Or'(List.mapi (fun index expr -> if (index == ((List.length ors) -1)) then annotate_TC expr in_tp else annotate_TC expr false) ors)
+    | LambdaSimple'(params, body) -> LambdaSimple'(params, annotate_TC body true)
+    | LambdaOpt'(mandatory, optional, body) -> LambdaOpt'(mandatory, optional, annotate_TC body true)
+    | Applic'(body, args) -> 
+      if(in_tp) then 
+        ApplicTP'(annotate_TC body false, List.map (fun arg -> annotate_TC arg false ) args)
+      else 
+        Applic'(annotate_TC body false, List.map (fun arg -> annotate_TC arg false ) args)
+    | _ -> raise X_no_match;;  
+
+(* --------------------------------------Boxing------------------------------------------------------ *)
+  (* ----------------------------------basic boxing------------------------------------------------ *)
+    let ext_env params env = 
+        params::env;;
+    
+    let read_write_append (r_lst1,w_lst1) (r_lst2,w_lst2) =
+        (List.append r_lst1 r_lst2,List.append w_lst1 w_lst2)
+
+    let rec find_read_write exp depth env cur_closure_params= 
+      match exp with
+      | Const'(x) -> ([],[])
+      | If'(test,dit,dif) ->  if_read_write test dit dif depth env cur_closure_params
+      | LambdaSimple'(params,body) -> find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env params)
+      | LambdaOpt'(mandatory, optional, body) -> find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env((List.append mandatory [optional])))
+      | Or'(ors) -> List.fold_left (fun acc exp -> (read_write_append acc (find_read_write exp depth env cur_closure_params)) ) ([],[]) ors
+      | Set'(vr,vl) -> let (reads,writes) = find_read_write vl depth env cur_closure_params in
+                        (reads,List.append (write_var vr depth env cur_closure_params) writes)
+      | Seq'(seq) ->  List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params)) ([],[]) seq
+      | Def'(vr,vl) -> let (reads,writes) = find_read_write vl depth env cur_closure_params in  
+                        (reads,List.append (write_var vr depth env cur_closure_params) writes )
+      | Applic'(body,args) -> read_write_append (find_read_write body depth env cur_closure_params) (List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params) ) ([],[]) args)
+      | ApplicTP'(body,args) -> read_write_append (find_read_write body depth env cur_closure_params) (List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params) ) ([],[]) args)
+      | Var'(VarFree(name)) -> ([],[])
+      | Var'(VarParam(name,minor)) -> if (depth == 0) then ([name, cur_closure_params::env],[]) else ([],[])
+      | Var'(VarBound(name,major,minor)) -> if (depth -1 == major) then ([name, cur_closure_params::env],[]) else ([],[])
+      | BoxSet'(vr,vl) -> find_read_write vl depth env cur_closure_params
+      | BoxGet'(vr) -> ([],[])
+      | Box'(var) -> ([],[])
+
+
+    and if_read_write test dit dif depth env cur_closure_params= 
+      let test_read = find_read_write test depth env cur_closure_params in
+      let dit_read = find_read_write dit depth env cur_closure_params in
+      let dif_read = find_read_write dif depth env cur_closure_params in
+      read_write_append (read_write_append test_read dit_read) dif_read
+
+    and write_var vr depth env params= 
+      match vr with
+      | VarParam(name,minor) -> if (depth == 0) then [name, params::env] else []
+      | VarBound(name,major,minor) -> if (depth - 1 == major) then [name, params::env] else []
+      | VarFree(name) -> [];;
+    
+    let get_read_write params expr  =
+      find_read_write expr 0 [] (Env(params));;
+
+    let get_list (env:env) =
+      let Env(lst) = env in
+      lst;;
+
+    let rec is_common_ancestor (env1:env list) (env2:env list) var = 
+      match env1 with
+      | first::rest -> if ((List.exists (fun x -> x == first) env2) && (not (List.mem var (get_list first)))) then true else is_common_ancestor rest env2 var
+      | [] -> false;; 
+
+    let get_var_name var =
+      match var with
+      | Var'(VarParam(name,_)) -> name
+      | Var'(VarBound(name,_,_)) -> name 
+      | Var'(VarFree(name)) -> name
+      | _ -> raise X_no_match ;;
+
+    let var_match var1 env1 var2 env2 =
+      let rec same_rib (env1:env list) (env2:env list) = 
+        match env1,env2 with
+      | first::rest , [] -> false
+      | [] , first::rest -> false
+      | [] , [] -> true
+      | first1::rest1 , first2::rest2 -> if (first1 == first2) then same_rib rest1 rest2 else false in
+      if ( (var1 = var2) && (not (is_common_ancestor env1 env2 var1)) && (not (same_rib env1 env2))) then true else false 
+  
+  (* ------------------------------additional criteria--------------------------------------------- *)
+    let ignore_to_var_list ignores=
+      let extract_var_from_ignore ignore = 
+        match ignore with 
+        | (VarBound(name,major,minor), _) -> name
+        | _ -> "error" in
+      List.map (fun ignore -> extract_var_from_ignore ignore) ignores;;
+
+    let in_dont_ignore vr dont_ignore_read = 
+      match vr with
+      | VarParam(name,minor) -> List.mem name (ignore_to_var_list dont_ignore_read)
+      | VarBound(name,major,minor) -> List.mem name (ignore_to_var_list dont_ignore_read)
+      | VarFree(name) -> false;;
+
+    let append_to_dont_ignore vr depth dont_ignore env params =
+      match vr with 
+      | VarParam(name,minor) -> dont_ignore
+      | VarBound(name,major,minor) -> if (depth -1 == major) then (VarBound(name,major,minor),params::env)::dont_ignore else dont_ignore
+      | VarFree(name) -> dont_ignore;;
+    
+    let foursome_append (rlist1,wlist1,dir1,diw1) (rlist2,wlist2,dir2,diw2) =
+        let dont_ignore_read  = List.fold_left (fun acc var -> if (not (List.mem var dir1)) then var::acc else acc) dir1 dir2 in
+        let dont_ignore_write  = List.fold_left (fun acc var -> if (not (List.mem var dir1)) then var::acc else acc) diw1 diw2 in
+        (List.append rlist1 rlist2,List.append wlist1 wlist2,dont_ignore_read,dont_ignore_write)
+
+    let rec third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write = 
+      match exp with
+      | Const'(x) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | If'(test,dit,dif) ->  third_rule_if_read_write test dit dif depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | LambdaSimple'(params,body) -> third_rule_find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env params) dont_ignore_read dont_ignore_write
+      | LambdaOpt'(mandatory, optional, body) -> third_rule_find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env((List.append mandatory [optional]))) dont_ignore_read dont_ignore_write
+      | Or'(ors) -> List.fold_left (fun acc exp -> (foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write)) ) ([],[], dont_ignore_read, dont_ignore_write) ors
+      | Set'(vr,vl) -> set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | Seq'(seq) ->  List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write)) ([],[], dont_ignore_read, dont_ignore_write) seq
+      | Def'(vr,vl) -> set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | Applic'(body,args) -> foursome_append (third_rule_find_read_write body depth env cur_closure_params dont_ignore_read dont_ignore_write) (List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write) ) ([],[],dont_ignore_read,dont_ignore_write) args)
+      | ApplicTP'(body,args) -> foursome_append (third_rule_find_read_write body depth env cur_closure_params dont_ignore_read dont_ignore_write) (List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write) ) ([],[],dont_ignore_read,dont_ignore_write) args)
+      | Var'(VarFree(name)) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | Var'(VarParam(name,minor)) -> if (depth == 0) && (List.mem name (ignore_to_var_list dont_ignore_write)) then ([name, cur_closure_params::env],[], dont_ignore_read, dont_ignore_write) else ([],[], dont_ignore_read, dont_ignore_write)
+      | Var'(VarBound(name,major,minor)) -> var_bound_find_read_write name major minor env cur_closure_params depth dont_ignore_read dont_ignore_write
+      | BoxSet'(vr,vl) -> third_rule_find_read_write vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | BoxGet'(vr) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | Box'(var) -> ([],[], dont_ignore_read, dont_ignore_write)
+
+
+      and var_bound_find_read_write name major minor env cur_closure_params depth dont_ignore_read dont_ignore_write =
+        if (depth -1 == major) && (List.mem name (ignore_to_var_list dont_ignore_write)) then
+                    ([name, cur_closure_params::env],[], (VarBound(name,major,minor), cur_closure_params::env)::dont_ignore_read, dont_ignore_write ) else 
+                    if (depth -1 == major) then
+                    ([],[], (VarBound(name,major,minor), cur_closure_params::env)::dont_ignore_read, dont_ignore_write)
+                    else ([],[], dont_ignore_read, dont_ignore_write)
+
+      and set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write =
+          let (reads,writes, dont_ignore_read1, dont_ignore_write1) = third_rule_find_read_write vl depth env cur_closure_params dont_ignore_read dont_ignore_write in  
+                let writes = if (in_dont_ignore vr dont_ignore_read) 
+                then 
+                List.append (write_var vr depth env cur_closure_params) writes 
+                else 
+                writes in
+                (reads, writes, dont_ignore_read1, (append_to_dont_ignore vr depth dont_ignore_write1 env cur_closure_params))
+
+      and third_rule_if_read_write test dit dif depth env cur_closure_params dont_ignore_read dont_ignore_write= 
+      let test_read = third_rule_find_read_write test depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      let dit_read = third_rule_find_read_write dit depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      let dif_read = third_rule_find_read_write dif depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      foursome_append (foursome_append test_read dit_read) dif_read
+
+    let ignore_to_env ignores =
+      let extract_env ignore =
+        match ignore with 
+        | (VarBound(name,major,minor), env) -> (name, env)
+        | _ -> raise X_no_match in
+      List.map (fun ignore -> extract_env ignore) ignores;;
+
+    let third_rule params body = 
+        let get_dont_ignore_read = (fun (a,b,c,d) -> c) in
+        let get_dont_ignore_write = (fun (a,b,c,d) -> d) in
+        let get_r_w = (fun (a,b,c,d) -> (List.append a (ignore_to_env c), List.append b (ignore_to_env d))) in
+        match body with
+        | Seq'(ribs) ->get_r_w (List.fold_left (fun acc rib -> (foursome_append (third_rule_find_read_write rib 0 [] (Env params) (get_dont_ignore_read acc) (get_dont_ignore_write acc)) acc )) ([],[],[],[])  ribs)
+        | _ -> get_read_write params body;;
+
+  let rec get_need_to_be_boxed_vars params body =
+    if (params = [] ) then [] else 
+    let (reads,writes) = third_rule params body in
+    let lst = (List.fold_left (fun acc (var1, env1) -> if (List.exists (fun (var2, env2) -> var_match var1 env1 var2 env2) writes) then var1::acc else acc ) [] reads) in
+    List.fold_right (fun param acc  -> if (List.mem param lst) then param::acc else acc) params []
+
+  let rec box_var var_name body =
+    match body with
+    | Const'(x) -> Const'(x)
+    | If'(test,dit,dif) ->  If'(box_var var_name test,box_var var_name dit,box_var var_name dif)
+    | LambdaSimple'(params,body) -> if (List.mem var_name params) then LambdaSimple'(params,body) else LambdaSimple'(params,box_var var_name body)
+    | LambdaOpt'(mandatory, optional, body) -> if (List.mem var_name (List.append mandatory [optional])) then LambdaOpt'(mandatory, optional, body) else LambdaOpt'(mandatory, optional,box_var var_name body)
+    | Or'(ors) -> Or'(List.map (fun expr -> box_var var_name expr) ors)
+    | Set'(vr,Box'(vr2)) -> Set'(vr,Box'(vr2))
+    | Set'(vr,vl) -> if ((get_var_name (Var'(vr))) = var_name) then BoxSet'(vr,box_var var_name vl) else Set'(vr,box_var var_name vl)
+    | Seq'(seq) ->  Seq'(List.map (fun expr -> box_var var_name expr) seq)
+    | Def'(vr,vl) -> Def'(vr,box_var var_name vl)
+    | Applic'(body,args) -> Applic'(box_var var_name body,List.map (fun arg -> box_var var_name arg) args)
+    | ApplicTP'(body,args) -> ApplicTP'(box_var var_name body,List.map (fun arg -> box_var var_name arg) args)
+    | Var'(VarFree(name)) -> Var'(VarFree(name))
+    | Var'(VarParam(name,minor)) -> if (name = var_name) then BoxGet'(VarParam(name,minor)) else Var'(VarParam(name,minor)) 
+    | Var'(VarBound(name,major,minor)) -> if (name = var_name) then BoxGet'(VarBound(name,major,minor)) else Var'(VarBound(name,major,minor))
+    | Box'(vr) -> Box'(vr)
+    | BoxGet'(vr) -> BoxGet'(vr)
+    | BoxSet'(vr,vl) -> BoxSet'(vr,box_var var_name vl) 
+
+  (* add Set'(VarParam(v, minor), Box'(VarParam(v,minor))) in the begging of the lambda *)
+  let add_set_box body vars params=
+    let sets= List.map (fun var_name -> Set'(VarParam(var_name, index_of params var_name),Box'(VarParam(var_name,index_of params var_name)))) vars in
+    match body with 
+    | Seq'(seq) -> Seq'(List.append sets seq)
+    | expr -> Seq'(List.append sets [expr])
+
+  let rec apply_box expr =
+    let (params,body) = match expr with 
+                        | LambdaSimple'(params,body) -> (params,body)
+                        | LambdaOpt'(mandatory, optional, body) -> ((List.append mandatory [optional]),body)
+                        | _ -> raise X_no_match in
+    if (params = []) then expr else
+    let need_to_be_boxed = get_need_to_be_boxed_vars params body in 
+    if (need_to_be_boxed = [] ) then expr else
+    let new_body = add_set_box body need_to_be_boxed params in
+    let new_body = List.fold_left (fun acc var -> box_var var acc) new_body need_to_be_boxed in
+    match expr with 
+    | LambdaSimple'(params,_) -> LambdaSimple'(params,new_body)
+    | LambdaOpt'(mandatory, optional, _) -> LambdaOpt'(mandatory, optional, new_body)
+    | _ -> raise X_no_match
+
+  let rec reach_lambda e =
+    match e with
+    | Const'(x) -> Const'(x)
+    | Var'(var) -> Var'(var)
+    | If'(test,dit,dif) -> If'(reach_lambda test,reach_lambda dit, reach_lambda dif)
+    | Seq'(seq) -> Seq'(List.map reach_lambda seq)
+    | Set'(var,vl) -> Set'(var, reach_lambda vl)
+    | Def'(var,vl) -> Def'(var, reach_lambda vl)
+    | Or'(ors) -> Or'(List.map reach_lambda ors)
+    | LambdaSimple'(params, body) -> apply_box (LambdaSimple'(params,reach_lambda body))
+    | LambdaOpt'(mandatory, optional, body) -> apply_box (LambdaOpt'(mandatory, optional,reach_lambda body))
+    | Applic'(body, args) -> Applic'(reach_lambda body, List.map reach_lambda args)
+    | ApplicTP'(body,args) -> ApplicTP'(reach_lambda body, List.map reach_lambda args)
+    | _ -> raise X_no_match;;  
+
 module type SEMANTICS = sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
@@ -67,13 +355,19 @@ module type SEMANTICS = sig
   val box_set : expr' -> expr'
 end;;
 
+
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let annotate_lexical_addresses e = 
+  annotate_lexical e [];;
+
+
+let annotate_tail_calls e = annotate_TC e false;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
 
-let box_set e = raise X_not_yet_implemented;;
+
+let box_set e =  reach_lambda e;; 
+
 
 let run_semantics expr =
   box_set
@@ -82,4 +376,21 @@ let run_semantics expr =
   
 end;; (* struct Semantics *)
 
+(* 
+let test_semantics str = Semantics.run_semantics (List.hd (Tag_Parser.tag_parse_expressions (read_sexprs str)));;
+
+let test_find_read_write str =
+  let expr_tag = (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs str)))) []) in
+  let LambdaSimple'(params,body) = expr_tag in
+  find_read_write body 0 [] (Env params);;
+
+let test_tp_string x = 
+  annotate_TC (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs x)))) []) false;;
+
+let test_lexical_string x =
+  annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs x)))) [];;
 
+let test_get_need_to_be_boxed_vars str = 
+  let expr_tag = (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs str)))) []) in
+  let LambdaSimple'(params,body) = expr_tag in
+  get_need_to_be_boxed_vars params body;; *)
\ No newline at end of file
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..4335ff1 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,21 +1,22 @@
 #use "reader.ml";;
+open Reader;;
 
 type constant =
   | Sexpr of sexpr
   | Void
 
 type expr =
-  | Const of constant
-  | Var of string
-  | If of expr * expr * expr
-  | Seq of expr list
-  | Set of expr * expr
-  | Def of expr * expr
-  | Or of expr list
+  | Const of constant    
+  | Var of string             
+  | If of expr * expr * expr  
+  | Seq of expr list  
+  | Set of expr * expr        
+  | Def of expr * expr         
+  | Or of expr list             
   | LambdaSimple of string list * expr
   | LambdaOpt of string list * string * expr
-  | Applic of expr * (expr list);;
-
+  | Applic of expr * (expr list);;  
+  
 let rec expr_eq e1 e2 =
   match e1, e2 with
   | Const Void, Const Void -> true
@@ -40,8 +41,7 @@ let rec expr_eq e1 e2 =
      (expr_eq e1 e2) &&
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
-                       
+	                      
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -56,10 +56,227 @@ let reserved_word_list =
    "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
    "unquote-splicing"];;  
 
-(* work on the tag parser starts here *)
+let is_Var x = 
+  not (List.mem x reserved_word_list);;  
+
+let rec is_proper_list pr = 
+  match pr with
+  | Nil -> true
+  | Pair(x, Nil)-> true
+  | Pair(x, Pair(y, z)) -> is_proper_list (Pair(y, z))
+  | Pair (x,y) -> false
+  | _ -> raise X_syntax_error;;
+
+let rec pairs_to_list_map pr func=
+  match pr with
+  | Pair(x,Nil) -> (func x)::[]
+  | Pair(x, Pair(y,z)) -> (func x)::(pairs_to_list_map (Pair(y,z)) func)
+  | Pair(x, y) -> (func x)::[(func y)]
+  | Nil -> []
+  | _ -> raise X_no_match;;
+
+let rec pairs_to_list pr=
+  match pr with
+  | Pair(x,Nil) ->  x::[]
+  | Pair(x, Pair(y,z)) -> x::(pairs_to_list (Pair(y,z)))
+  | Pair(x, y) -> x::[y]
+  | Nil -> []
+  | _ -> raise X_no_match;;
+
+let pairs_to_string_list pr =  
+  pairs_to_list_map pr (fun y -> match y with
+                                 | Symbol(x) -> x
+                                 | _ -> raise X_no_match);;
+
+
+let rec seperate_list_last lst = 
+  match lst with
+  |x::y::[] -> x::[] , y
+  |x::y -> let a, b = seperate_list_last y in x::a, b
+  |_ -> raise X_syntax_error
+
+let get_params_vals lst = 
+  let params = pairs_to_list_map lst (fun x ->match x with 
+                                              | (Pair(Symbol(param), _)) -> param
+                                              | _ -> raise  X_syntax_error) in
+  let vals = pairs_to_list_map lst (fun x -> match x with 
+                                             | (Pair(param, Pair(vals, _))) -> vals
+                                             | _ -> raise X_syntax_error ) in
+  (params, vals);;
+  
+let rec list_to_pairs lst = 
+  match lst with 
+  | a::[] -> Pair(a, Nil)
+  | a::b -> Pair(a, list_to_pairs b)
+  | [] -> raise X_syntax_error
+
+let rec tag_parse exp = 
+  match exp with
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | String(x) -> Const(Sexpr(String(x)))
+  | Symbol(x) -> if is_Var(x) then Var(x) else raise X_syntax_error
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("if"), sexps) -> parse_if sexps 
+  | Pair(Symbol("lambda"), x) -> parse_lambda  x
+  | Pair(Symbol("or"), sexps ) -> parse_or sexps
+  | Pair(Symbol("set!"), Pair(vars, Pair(vals, Nil))) -> Set(tag_parse vars, tag_parse vals)
+  | Pair(Symbol("define"), Pair(Pair(Symbol(name), argl), expr)) -> mit_form_expnder name argl expr
+  | Pair(Symbol("define"), Pair(vars, Pair(vals, Nil))) -> Def(tag_parse vars, tag_parse vals) 
+  | Pair(Symbol("begin"),sexps) -> parse_begin sexps
+  | Pair(Symbol("quasiquote"),Pair(rest, Nil)) -> quasiquote_expander rest 
+  | Pair(Symbol("cond"), rest) -> cond_expander rest  
+  | Pair(Symbol("let"),  Pair(init,body)) -> let_expander init body
+  | Pair(Symbol("let*"), Pair(init,body)) -> let_star_expander init body
+  | Pair(Symbol("letrec"), Pair(init,body)) -> letrec_expander init body
+  | Pair(Symbol("and"), rest) -> and_expander rest
+  | Pair(Symbol("pset!"), rest) -> pset_expander rest
+  | Pair(x, y) -> Applic(tag_parse x, (pairs_to_list_map y tag_parse) )
+  | _ -> raise X_no_match
+
+and parse_if sexps =
+  match sexps with 
+  | Pair(test, Pair(dit, Pair(dif, Nil))) -> If(tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair(test, Pair(dit,Nil)) -> If(tag_parse test, tag_parse dit, Const(Void))
+  | _ -> raise X_no_match
+
+and parse_lambda x = 
+  match x with 
+  | Pair(Symbol(y), body) -> LambdaOpt([], y, parse_seq body)
+  | Pair(args,body) -> if(is_proper_list args) then 
+                          LambdaSimple(pairs_to_string_list args,parse_seq body)
+                      else let args=pairs_to_string_list args in 
+                            let mandatory, optional = seperate_list_last args in
+                          LambdaOpt(mandatory, optional, parse_seq body)
+  | _ -> raise X_syntax_error
+
+and parse_or sexps = 
+  match sexps with
+  | Nil ->  Const(Sexpr(Bool(false)))
+  | Pair(x, Nil) ->  tag_parse x
+  | x -> Or(pairs_to_list_map x tag_parse)
+
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+and parse_seq exps = 
+  let exps = pairs_to_list exps in
+    if (List.length exps = 1) then  
+      tag_parse (List.hd exps)
+    else 
+      let parsed = List.map tag_parse exps in
+      let parsed = 
+        List.fold_left 
+          (fun acc exp-> 
+            match exp with
+            | Seq(x) -> List.append acc x
+            | _ -> List.append acc [exp] )
+          []
+          parsed in                     
+      Seq(parsed)
+
+and parse_begin sexps = 
+  match sexps with
+  | Nil -> Const(Void)
+  | exps -> parse_seq exps
+   
+and cond_expander sexpr =
+      let rec ribs_expander ribs =
+        match ribs with
+        | [] -> (Pair(Symbol("begin"),Nil))
+        | first::rest ->
+            match first with
+            | Pair(test, Pair(Symbol("=>"), func)) -> apply_cond_rib test func rest
+            | Pair(Symbol("else"), seq) -> (Pair(Symbol("begin"), seq))
+            | Pair(test, seq) ->  (Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), seq), Pair(ribs_expander rest,Nil))))) 
+            | _ -> raise X_syntax_error
+  
+      and apply_cond_rib test func rest = 
+        match rest with
+        | [] -> Pair(Symbol "let",Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, func)), Nil)), Nil)), Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Nil))), Nil)))
+        | _ ->  Pair(Symbol "let",Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, func)), Nil)), Pair(Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(ribs_expander rest, Nil))), Nil)), Nil))), Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Pair(Pair(Symbol "rest", Nil), Nil)))), Nil)))
+  in
+  let ribss = pairs_to_list sexpr in
+  tag_parse (ribs_expander ribss)
+    
+and quasiquote_expander exps = 
+  match exps with
+  | Pair(Symbol("unquote"), Pair(sexp, Nil)) -> tag_parse sexp
+  | Pair(Symbol("unquote-splicing"),Pair(sexp, Nil) ) -> raise X_syntax_error
+  | Nil -> tag_parse (Pair(Symbol("quote") , Pair(Nil,Nil)))
+  | Symbol(x) -> tag_parse (Pair(Symbol("quote") , Pair(Symbol(x),Nil) ))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(sexp, Nil)),b) -> Applic(Var("append"), [tag_parse sexp ;quasiquote_expander b ] )
+  | Pair(a,Pair(Symbol("unquote-splicing"),Pair(sexp, Nil))) -> Applic(Var("cons") , [quasiquote_expander a ; tag_parse sexp])
+  | Pair(a,b) -> Applic(Var("cons") , [quasiquote_expander a; quasiquote_expander b])
+  | _ -> raise X_syntax_error
+
+and let_expander init body = 
+  let (paramters,vals) = get_params_vals init in
+  let body = parse_seq body in
+  let func = LambdaSimple(paramters,body) in
+  Applic(func ,List.map tag_parse vals)
+
+and let_star_expander init body =
+  match init with 
+  | Nil -> tag_parse (Pair(Symbol("let"), Pair(Nil, body)))
+  | Pair(x, Pair(y, z)) -> tag_parse (Pair(Symbol("let"), Pair(Pair(x, Nil),Pair(Pair(Symbol("let*"), Pair(Pair(y, z), body)), Nil))))
+  | Pair(x, y) -> tag_parse (Pair(Symbol("let"), Pair(init, body)))
+  | _ -> raise X_syntax_error
+
+and letrec_expander init body =
+  let rec list_to_let_rec_pairs lst =
+    match lst with
+    | [] -> Nil
+    | a::b -> Pair(Pair(a, Pair(Pair(Symbol("quote"),Pair(Symbol("whatever"), Nil)), Nil)), list_to_let_rec_pairs b) in
+  
+  let rec lists_to_let_rec_sets params vals body=
+    match params, vals with
+    | [], [] -> body
+    | a::b, c::d ->  Pair(Pair(Symbol("set!"), Pair(a, Pair(c, Nil))), lists_to_let_rec_sets b d body) 
+    | a::b, [] -> raise X_syntax_error
+    | [], a::b -> raise X_syntax_error in
+  
+  let (params,vals) = get_params_vals init in
+  let params = List.map (fun (x) -> Symbol(x)) params in
+  tag_parse (Pair(Symbol("let") ,Pair(list_to_let_rec_pairs params ,lists_to_let_rec_sets params vals body)))
+
+and and_expander rest = 
+  match rest with 
+  | Nil -> Const(Sexpr(Bool(true)))
+  | Pair(x, Nil) -> tag_parse x
+  | Pair(test,rest) -> 
+    let _then = Pair(Symbol("and") , rest) in
+    let _else = Bool(false) in
+    tag_parse (Pair(Symbol("if"),Pair(test,Pair(_then,Pair(_else,Nil)))))
+  | _ -> raise X_syntax_error
+
+          
+and mit_form_expnder name argl expr =
+  tag_parse (Pair(Symbol("define"), Pair(Symbol(name), Pair(Pair(Symbol("lambda"), Pair(argl, expr)), Nil))))
+
+and pset_expander rest = 
+    let rec init_ribs params vals index =
+      match params,vals with
+      | param::[] , vl::[] -> Pair(Symbol(";" ^ (string_of_int index)), Pair(vl, Nil))::[]
+      | param::rest_params , vl::rest_vals -> Pair(Symbol (";" ^ (string_of_int index)), Pair(vl, Nil))::(init_ribs rest_params rest_vals (index+1))
+      | _ -> raise X_syntax_error in
+    
+    let rec body_expr params index = 
+      match params with 
+      | param::[] -> Pair(Symbol "set!", Pair(Symbol(param), Pair(Symbol (";"^(string_of_int index)), Nil)))::[]
+      | param::rest_params -> Pair(Symbol "set!", Pair(Symbol(param), Pair(Symbol (";"^(string_of_int index)), Nil))) :: (body_expr rest_params (index+1))
+      | _ -> raise X_syntax_error in
+
+    let params, vals = get_params_vals rest in
+    let init = init_ribs params vals 1 in 
+    let body_expressions = body_expr params 1 in
+    let init = list_to_pairs init in
+    let body_expressions = list_to_pairs body_expressions in
+    tag_parse (Pair(Symbol("let"), Pair(init, body_expressions )));;
+
+
+let tag_parse_expressions sexpr = List.map tag_parse sexpr
 
   
 end;; (* struct Tag_Parser *)
 
+
