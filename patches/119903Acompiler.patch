diff --git a/reader.ml b/reader.ml
index 32445c2..83240c7 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,5 @@
-
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -36,11 +36,472 @@ end
 let normalize_scheme_symbol str =
   let s = string_to_list str in
   if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
+  (fun ch -> (ch = (lowercase_ascii ch)))
+  s) then str
   else Printf.sprintf "|%s|" str;;
 
+(*Abstract*)
+ (*This code is from RS3*)
+let nt_whitespaces = star (char ' ');;
+let ntHashtag = char '#';;
+let ntSlash = char '/';;
+let ntDot = char '.';;
+
+let digit = range '0' '9';;
+let digitSeq = plus digit;;
+
+let nt_Quoted = char '\'';;
+let nt_QQuoted = char '`';;
+let nt_Unquoted = char ',';;
+let nt_UnquotedSpliced = word ",@";;
+
+let nt_Sexpr_Comment = word_ci "#;";;
+(* ------------------------ *)
+
+(*takes 3 parsers , concate them and remove the left and right parts*)
+let make_paired nt_left nt_right nt =
+let nt = caten nt_left nt in
+let nt = pack nt (function (_, e) -> e) in
+let nt = caten nt nt_right in
+let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+let nt_char_to_ignore =
+  let nt_tab = char '\t' in
+  let nt_f = char '\012' in
+  let nt_n = char '\n' in
+  let nt_r = char '\r' in
+  let nt = disj_list [nt_whitespace;nt_tab; nt_f; nt_n; nt_r;] in
+  nt;; 
+ 
+ let nt_chars_to_ignore =star nt_char_to_ignore;;
+ let make_clean nt = make_paired nt_chars_to_ignore nt_chars_to_ignore nt;;
+
+let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
+let tok_lparen = make_clean ( char '(');;
+let tok_rparen = make_clean ( char ')');; 
+(*end of code from RS3*)
+(* recognize dot with spaces*)
+let tok_dot = make_clean (char '.');;
+
+
+
+
+
+(* 3.3.1 Boolean *)
+(* returns sexpr (of Bool ) * char list (of unparesd characters)
+		example: parseBool (string_to_list "#Tfg");; *)
+
+let parseBool s = 
+	let ntTrue = char_ci 't' 
+	and ntFalse = char_ci 'f'
+	and rest =  fun (_,r) -> r in
+	try let tst = rest (ntHashtag s) in
+		try let t = ntTrue ( tst) in
+			(Bool(true), rest(t)) 
+		with X_no_match -> 
+		try let f = ntFalse ( rest (ntHashtag s)) in
+			(Bool(false), rest(f)) 
+		with X_no_match -> nt_none()
+	with X_no_match -> nt_none();;
+
+
+(* 3.3.2 & 4 & 7 Numbers *)
+
+(* returns  int (-1 or 1 as sign) * char list (rest of the number) 
+	later one need to multiply sign by the parsed number *)
+let ntSign s = 
+	let ntPlus = char '+'
+	and ntMinus = char '-' 
+	and extractSign = fun (i) -> if i='+' then 1 else -1 in
+	try let d = disj ntPlus ntMinus in
+		pack d extractSign s;
+	with X_no_match -> (1,s)
+
+
+(* convert char of int to int *)
+let char_to_int c = 
+	int_of_char c - int_of_char '0';;
 
-let read_sexprs string = raise X_not_yet_implemented;;
+(* maps list of chars to int *)
+let list_of_char_to_int lst =
+  List.map char_to_int lst;;
+
+(* calc natural number from int list *)
+let nat s = 	
+	List.fold_left 
+		(fun a b -> 10*a + b)
+		0
+		(list_of_char_to_int s);;
+
+let composeFuncs f1 f2 = 
+	fun s -> f1 (f2 s);;
+
+(* maps list of chars to list of float *)
+let list_of_char_to_float lst =
+	let chat_fo_float = composeFuncs float_of_int char_to_int in
+  	List.map chat_fo_float lst;;
+
+(* calc mantissa (after the dot) number from int list *)
+let mantissa s = 
+	let f = 	
+	List.fold_right
+		(fun a b -> a +. 0.1*.b)
+		(list_of_char_to_float s)
+		0.0 in
+		f /. 10.;;
+
+(* Naturals parser *)
+let parseNat s = 
+	pack digitSeq nat s ;;
+
+(* Mantissa parser *)
+let parseMantissa ls = 
+	let nums,ls = digitSeq ls in
+	( (mantissa nums), ls);;
+
+
+(* return the greatest common divisor of two numbers *)
+let gcd a b = 
+	let a,b = if (a>b) then (a,b) else (b,a) in
+	let rec recGcd a b =
+		if b=0 then a else recGcd b (a mod b) in
+		recGcd a b;;
+
+(* return parsed number as int after E if exists 
+	example: parseScientific ['e';'0';'2';...] -> (2,..) *)
+let parseScientific s = 
+	let ntE = char_ci 'e' in
+	let _,ls = ntE s in
+	let sign, num = ntSign ls in
+	let num, ls = parseNat num in
+	(sign*num,ls) ;;
+
+(* float*int->float
+	return nEe *)
+let rec raiseExp n e =
+	if e =0 then n else 
+		if e>0 then raiseExp (n*.10.0) (e -1) 
+				 else raiseExp (n/.10.0) (e +1) ;;
+
+(* returns sexpr (of Number ) * char list (of unparesd characters)
+		example: parseNum (string_to_list "+0034.0100");; *)
+let parseNum s = 
+	let sign,num = ntSign s in
+	let n1,ls = parseNat num in
+	(* fraction *)
+	try let _, ls = ntSlash ls in
+		let n2,ls = parseNat ls in
+		let gcdNum = gcd n1 n2 in
+		(Number(Fraction (sign*n1/gcdNum,n2/gcdNum)) , ls)
+	with X_no_match ->
+	(* float *)
+	try let _, ls = ntDot ls in
+		let n2,ls = parseMantissa ls in
+		let fltNum = if n1>=0 then (float_of_int n1) +. n2 else (float_of_int n1) -. n2 in
+		let fltNum = fltNum *. float(sign) in
+		(* scientific float *)
+		try let e,ls = parseScientific ls in
+			let exp = raiseExp fltNum e in
+			(Number(Float(exp)), ls)
+		with X_no_match ->
+		(Number(Float (fltNum)), ls)
+	with X_no_match -> 
+	(* scientific int *)
+	try let e,ls = parseScientific ls in
+		let exp = raiseExp (float(n1)) e in
+		(Number(Float(float(sign)*.exp)), ls)
+	with X_no_match ->
+	(* int as fraction*)
+	(Number(Fraction (sign*n1,1)),ls);;
+	
+
+(*3.3.3 Symbol*)
+(*As we saw in RS3 the range parser constructor takes two chars and returns a parser that accepts a single char in the given character range*)
+let nt_lower_case = range 'a' 'z';;
+(*As requested, Our parser convert all literal symbol characters to lowercase *)
+let nt_upper_case = pack (range 'A' 'Z') (fun(x) -> Char.lowercase_ascii x );;
+let digits = range '0' '9';;
+
+let nt_special_char = 
+  let nt_exclemation = char '!' in
+  let nt_dollar =  char '$' in
+  let nt_power = char '^' in
+  let nt_star = char '*' in
+  let nt_score =  char '-'  in
+  let nt_underscore =  char '_' in
+  let nt_eq =  char '='  in
+  let nt_plus = char '+' in
+  let nt_left_arrow =  char '<' in
+  let nt_right_arrow =  char '>' in
+  let nt_slash =  char '/' in
+  let nt_quest_mark =  char '?' in
+  let nt_colon =  char ':' in  
+  let nt = disj_list [nt_exclemation ; nt_dollar ; nt_power ; nt_star ; nt_score ; nt_underscore ; nt_eq ; nt_plus ; 
+                      nt_left_arrow ; nt_right_arrow ; nt_quest_mark ; nt_slash ; nt_colon ] in
+  nt;;
+let nt_dot= char '.';;
+
+let nt_symbol_char_no_dot =    
+  let nt = disj_list [nt_lower_case;nt_upper_case;digits ; nt_special_char; ] in
+  nt;;
+  
+  let nt_symbol_char=
+	let nt=disj_list[nt_symbol_char_no_dot ;nt_dot ] in
+  nt;;
   
-end;; (* struct Reader *)
+	let nt_symbol_char_with_dot=
+		let nt=caten nt_symbol_char (plus nt_symbol_char) in
+		let nt=pack nt (fun (a,b)->list_to_string(a::b)) in
+		nt;;
+	
+	let nt_symbol = 
+	let nt=pack nt_symbol_char_no_dot (fun ds-> list_to_string([ds])) in
+	let nt=disj nt_symbol_char_with_dot  nt in 
+	let nt=pack nt (fun (ds)->Symbol (ds)) in
+	nt;;
+		
+ (*3.3.4 String*)
+  let nt_string_meta_chars =
+  let nt_backslash = pack (word "\\\\") (fun _ -> '\\') in
+  let nt_quote = pack (word "\\\"") (fun _ -> '"') in
+  let nt_tab = pack (word_ci "\\t") (fun _ -> '\t') in
+  let nt_f = pack (word_ci "\\f") (fun _ -> '\012') in
+  let nt_n = pack (word_ci "\\n") (fun _ ->'\n') in
+  let nt_r = pack (word_ci "\\r") (fun _ ->'\r') in
+  let nt = disj_list [nt_backslash; nt_quote; nt_tab; nt_f; nt_n; nt_r;] in
+  nt;; 
+ 
+
+(*any character other than backslash  or double qoute *)
+let nt_string_literal_char = pack (range '\032' '\255') (fun(ds) -> match ds with
+    | '\\' -> raise X_no_match
+    | '\"' -> raise X_no_match
+    | _ -> ds );;
+
+let nt_string_char = 
+  let nt = disj nt_string_literal_char nt_string_meta_chars in
+  nt;;
+
+let nt_string =
+    let nt_quote = char '\"' in
+    let nt_str = diff nt_any (one_of "\\\"") in
+    let nt_str = disj nt_str nt_string_meta_chars in
+    let nt_str = star nt_str in
+    let nt = caten nt_quote (caten nt_str nt_quote) in
+	nt;;
+
+
+
+(* 3.3.5 Char *)
+let nt_char_prefix = word "#\\";;
+
+let nt_nul = word_ci "nul";;
+let nt_newline = word_ci "newline";;
+let nt_return = word_ci "return";;
+let nt_tab = word_ci "tab";;
+let nt_page = word_ci "page";;
+let nt_space = word_ci "space";;
+
+let nt_null_to_char  = pack nt_nul (fun (ds) -> '\000');;
+let nt_newline_to_char  = pack nt_newline (fun (ds) -> '\010');;
+let nt_return_to_char  = pack nt_return (fun (ds) -> '\013');;
+let nt_tab_to_char  = pack nt_tab (fun (ds) -> '\009');; 
+let nt_page_to_char  = pack nt_page (fun (ds) -> '\012');;
+let nt_space_to_char  = pack nt_space (fun (ds) -> '\032');;
+
+let nt_named_char = disj_list [nt_null_to_char;nt_newline_to_char;nt_return_to_char;nt_space_to_char;nt_tab_to_char;nt_page_to_char];;
+
+let nt_named_chars = caten nt_char_prefix nt_named_char;;
+(*any charachter that greater than the space character in the ASCII table*)
+let nt_visible_char = caten nt_char_prefix (range '\032' '\255');;
+
+
+let nt_char  =
+  let test = disj nt_named_chars nt_visible_char in
+  pack test (fun (ds) -> match ds with
+      |(_,l) -> Char (l)
+    );;
+
+
+(*3.3.6 Nil*)
+let nt_nil =
+	let nt= caten tok_lparen tok_rparen in
+    let nt = pack nt (fun _ -> Nil) in
+	nt;;
+	
+
+let ntSemicolon= char ';';; 
+let ntEndOfLine = char '\n';;
+
+(* 3.2.2 Line Comments *)
+let rec skipComment s = 
+	if s=[] then [] else
+	let eol = disj nt_named_char ntEndOfLine in
+	try let _,ls = eol s in
+		ls
+	with X_no_match -> (skipComment (List.tl s));;
+
+let parseLineComment s = 
+	let _,ls = ntSemicolon s in
+	([], (skipComment ls));;
+
+
+(* return the string part from parser *)
+let getString s = 
+	let r,ls = nt_string s in
+	let _,(st,_) = r in
+	(st,ls);;
+
+
+	  
+(* parse the first sexpr and return the rest as char list *)
+let rec parse_One_Sexpr s = 
+	if s=[] then ([],[]) else
+	(* white spaces *)
+	let w,rest = nt_chars_to_ignore s in
+		if w != [] then 
+		parse_One_Sexpr rest
+		else
+	(* Bool *)
+	let nt_bool = make_clean (not_followed_by parseBool nt_symbol) in
+	try let a,rest = nt_bool s in
+		([a],rest)
+	with X_no_match ->
+	(* Char *)
+	try let a,rest = make_clean(nt_char) s in
+		([a],rest)
+	with X_no_match ->
+	(* Number *)
+	let nt_num = make_clean(not_followed_by parseNum nt_symbol) in
+	try let a,rest = nt_num s in
+		([a],rest)
+	with X_no_match -> 
+	(* String *)
+	try let a,rest =make_clean( getString) s in
+		([String(list_to_string a)],rest)
+	with X_no_match ->
+	(* Quotes *)
+	try 
+		make_clean(parse_QuoteLike) s
+	with X_no_match ->
+	(*list*)
+	try let a,rest = parse_list s in
+		([a],rest)
+	with X_no_match -> 
+	(* Symbol *)
+	try let a,rest =  make_clean(nt_symbol) s in
+		([a],rest)
+	with X_no_match -> 
+	(* Sexpr Comments *)
+	try let a,rest =  parse_Sexpr_Comments s in
+		(a,rest)
+	with X_no_match ->
+	(* Line Comments *)
+	let a,ls = parseLineComment s in	
+		(a,ls)
+
+
+	and parse_list s=
+	let rec make_proper_list = function
+      | [] -> Nil
+      | car::cdr -> Pair (car , make_proper_list cdr) in
+	 let rec make_improper_list = function
+      | [] -> Nil
+	  (*in improper we know the last index*)
+      | car::cdr::[] -> Pair (car, cdr)
+      | car::cdr -> Pair (car , make_improper_list cdr) in
+
+
+	let nt_plus = caten nt_chars_to_ignore parse_One_Sexpr in
+    let nt_plus = pack nt_plus (fun (_, sexpr) -> sexpr) in
+    let nt_plus = caten parse_One_Sexpr (star nt_plus) in
+    let nt_plus = pack nt_plus (fun (car, cdr) -> car::cdr) in
+	
+	
+	let nt_list = caten tok_lparen (caten nt_plus tok_rparen) in
+	let nt_list = pack nt_list (fun (_, (sexprs, _)) -> make_proper_list (List.flatten sexprs)) in
+    let nt_list = disj nt_nil nt_list in
+	let nt_dotted_list = caten tok_lparen (caten nt_plus  (caten tok_dot (caten one_with_comment tok_rparen))) in
+    let nt_dotted_list = pack nt_dotted_list (fun (_, (sexprs, (_, (last_sexpr, _)))) -> make_improper_list ((List.flatten sexprs)@last_sexpr)) in
+    let nt = disj  nt_list nt_dotted_list  in
+	nt s
+	
+	(* 3.3.8 Quote-like forms *)
+	and parse_QuoteLike s = 
+		let check_empty = fun (p, rest) ->
+				match p with 
+				| []-> one_with_comment rest
+				| _-> (p,rest) in
+		(*qoute*)
+		try let _,ls = nt_Quoted s in
+			let p,rest = one_with_comment ls in
+			let p,rest = check_empty (p, rest) in
+			let p= List.hd p in
+				([Pair(Symbol("quote"),Pair(p,Nil))],rest)
+		with X_no_match -> 
+		(*quasiqoute*)
+		try let _,ls = nt_QQuoted s in
+			let p,rest = one_with_comment ls in
+			let p,rest = check_empty (p, rest) in
+			let p= List.hd p in
+			([Pair(Symbol("quasiquote"),Pair(p,Nil))],rest)
+		with X_no_match -> 
+		(*unquote-splicing*)
+		try let _,ls = nt_UnquotedSpliced s in
+			let p,rest = one_with_comment ls in
+			let p,rest = check_empty (p, rest) in
+			let p= List.hd p in
+			([Pair(Symbol("unquote-splicing"),Pair(p,Nil))],rest)
+		with X_no_match ->
+		(*unquote*)
+		try let _,ls = nt_Unquoted s in
+			let p,rest = one_with_comment ls in
+			let p,rest = check_empty (p, rest) in
+			let p= List.hd p in
+			([Pair(Symbol("unquote"),Pair(p,Nil))],rest)
+		with X_no_match ->
+		nt_none() 
+
+
+	(* 3.2.3 Sexpr Comments *)
+	(* TODO: make sure its VALID sexpr. it works now on any sexpr *)
+	and parse_Sexpr_Comments s = 
+		let a, ls = nt_Sexpr_Comment s in
+		let one,rest = parse_One_Sexpr ls in 
+		if one = [] then
+		let ls = ['#';';']@rest in
+		let a,ls = parse_Sexpr_Comments ls in 
+			([],ls)
+		else
+			([],rest)
+
+	and parse_comments s = 
+		let nt_owc1 = caten nt_whitespaces (caten (star parse_Sexpr_Comments) (caten nt_whitespaces (star parseLineComment ) ))  in
+		let nt_owc2 = caten nt_whitespaces (caten (star parseLineComment) (caten nt_whitespaces (star parse_Sexpr_Comments ) ))  in
+		let nt_owc = caten nt_owc1 nt_owc2 in
+		let _,rest = nt_owc s in 
+		([],rest)
+
+	and one_with_comment s= 
+		let f = fun ((sexprs, _),rest)->(sexprs,rest) in 
+		let _,first_com = parse_comments s in
+		f (caten parse_One_Sexpr parse_comments first_com)
+
+	(* parse all sexprs 
+		s 		- char list
+		sexprs  - sexpr list it already parsed *)
+	and parse_Sexpr s sexpr_ls= 
+		if s=[] then (sexpr_ls,[]) else
+		let one,rest = parse_One_Sexpr s in
+			parse_Sexpr rest (sexpr_ls@one) ;;
+		
+
+let read_sexprs s = let p,_ = parse_Sexpr (string_to_list s) [] in
+	p;;
+
+
+
+
+
+end;; (* struct Reader *)
\ No newline at end of file
diff --git a/readme.txt b/readme.txt
index e69de29..021a572 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Shani Klein- 205781909	
+Raz Paul- 206120206
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action .
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..ded47cd 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
                                             (expr'_eq th1 th2) &&
                                               (expr'_eq el1 el2)
@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+  | _ -> false;;
+	
+                       
 exception X_syntax_error;;
 
 module type SEMANTICS = sig
@@ -69,17 +61,394 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+(* ---------------------- *)
+(* Q3.2 *)
+(* ---------------------- *)
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+(* Returns index of tring x in string list lst, -1 if doesnt exist *)
+let index_of x lst = 
+  let rec f x lst count =
+    match lst with
+    | [] -> -1
+    | car::cdr -> if (String.equal car x) then count else (f x cdr (count+1))
+  in
+  f x lst 0;;
+  (*given number num return list of [1,2,3,....,num]*)
+  let rec list_all_nums_befor num = 
+    match num with
+    | 0 -> []
+    | _ -> (list_all_nums_befor (num-1))@[(num-1)] 
 
-let box_set e = raise X_not_yet_implemented;;
+(* vars is list of variables(string) list 
+    orderd by leftmost is current lexical env, each hop to the right meand on lex above*)
+let rec annotate vars e= 
+  let get_v vr= 
+    match vr with
+    | Var(v) -> v
+    | _ -> nt_none()
+  in
+  match e with 
+  | Const(e) -> Const'(e) 
+  | Var(v) -> Var'(ann_var v vars)
+  | If(tst,dit,dif) -> If'((annotate vars tst),(annotate vars dit),(annotate vars dif))
+  | Seq(s) -> Seq'((List.map (annotate vars) s))
+  | Or(lst) -> Or'((List.map (annotate vars) lst))
+  | LambdaSimple(var_list, body) -> LambdaSimple'(var_list,(annotate ([var_list]@vars) body))
+  | LambdaOpt(var_list,opt,body) -> LambdaOpt'(var_list,opt,(annotate ([var_list@[opt]]@vars) body))
+  | Applic (op,lst) -> Applic'((annotate vars op), (List.map (annotate vars) lst))
+  | Set(v,n) -> Set'((ann_var (get_v v) vars),(annotate vars n))
+  | Def(a,b) -> Def'((ann_var (get_v a) vars),(annotate vars b))
+  
+and ann_var v var_list =
+  let rec check_bound lst major= 
+    match lst with 
+    | [] -> (-1,-1)
+    | car::cdr -> if car != -1 then (major,car) else  (check_bound cdr (major+1))
+  in
+  let check =  List.map (index_of v) var_list in
+  let res = 
+    match check with
+    | [] -> VarFree(v)
+    | car::cdr ->
+      if car > -1 then VarParam(v,car) else 
+      (let major,minor = check_bound cdr 0 in 
+      if (minor != -1) then VarBound(v,major,minor) else VarFree(v)) 
+  in
+  res
 
-let run_semantics expr =
-  box_set
-    (annotate_tail_calls
-       (annotate_lexical_addresses expr));;
+  let annotate_lexical_addresses e = annotate [[]] e;;
+
+
+  (* ---------------------- *)
+  (* Q3.3 *)
+  (* ---------------------- *)
+  (* changes all calls is tail position from Applic' -> ApplicTP' *)
+  let rec change_to_tp in_tp e = 
+    let split_last = fun (l) -> ((List.rev (List.tl (List.rev l))),(List.hd (List.rev l))) in
+    match e with 
+    | If'(tst,dit,dif) -> If'(tst,(change_to_tp in_tp dit),(change_to_tp in_tp dif))
+    | Seq'(s) -> let rest,last = split_last s in
+      Seq'(((List.map (change_to_tp false) rest))@[change_to_tp in_tp last])
+    | Or'(lst) -> let rest,last = split_last lst in
+      Or'(((List.map (change_to_tp false) rest))@[change_to_tp in_tp last])
+    | LambdaSimple'(var_list, body) -> LambdaSimple'(var_list,(change_to_tp true body))
+    | LambdaOpt'(var_list,opt,body) -> LambdaOpt'(var_list,opt,(change_to_tp true body))
+    | Applic'(op,lst) -> if in_tp then ApplicTP'((change_to_tp false op),(List.map (change_to_tp false ) lst)) else Applic'((change_to_tp false op),(List.map (change_to_tp false) lst))
+    | Set'(v,n) -> Set'(v,(change_to_tp false n))
+    | Def'(a,b) -> Def'(a,(change_to_tp in_tp b)) 
+    | other -> other ;;
+  
+  let annotate_tail_calls e = change_to_tp false e;;
+  
+
+let check_f_before_g seq param f g=
+  let rec check_rec seq param f g find_f =  
+    match seq with
+    | [] -> false
+    | car::cdr -> 
+          (if (f param car) then (check_rec cdr param f g true) else 
+              (if ((g param car) && find_f) then true else 
+                (check_rec cdr param f g find_f)))
+  in check_rec seq param f g false;;
+(* ---------------------- *)
+  (* Q3.4 *)
+(* ---------------------- *)
+(* return true if we need to do boxing to parameter "param"*)
+let  rec need_boxing param body =
+  if(check_specials param body ) then false else  
+  let reading_occurences = count_param_reading_occurrences param body 0 in
+  let writing_occurences = count_param_writing_occurrences param body 0 in
+  let matched=different_ribs reading_occurences writing_occurences in 
+  matched 
+
+  and check_specials param body =  match body with
+  | Seq'(seq) ->
+    let spc1= (is_special_case1  seq param) in
+    let spc2= (is_special_case2 seq param ) in
+    spc1 || spc2
+  |_->false
+
+  and is_special_case1 seq param  =check_f_before_g  seq param  is_read_occ has_write_occ
+  and is_special_case2 seq param  =check_f_before_g  seq param  is_write_occ has_read_occ  
+
+  and map_count_reading_occurences exp_list param count = match exp_list with
+  | [] -> []
+  | first_exp::rest -> List.append (count_param_reading_occurrences param first_exp count) (map_count_reading_occurences rest param (count+1))
+
+  and map_count_writing_occurences exp_list param count = match exp_list with
+  | [] -> []
+  | first_exp::rest -> List.append (count_param_writing_occurrences param first_exp count) (map_count_writing_occurences rest param (count+1))
+
+  and check_rib write_occur read_occurances = 
+    List.fold_left (fun matched read_occur -> (matched || (write_occur != read_occur))) false read_occurances
+  
+  and different_ribs read_occurances write_occurances = match write_occurances with 
+    | [] -> false
+    | write_occur::rest -> if(check_rib write_occur read_occurances) 
+                            then true
+                            else (different_ribs read_occurances rest)
+
+
+and count_param_writing_occurrences param body count = match body with
+| Const'(value) -> []
+| Var'(variable) -> []
+| Set'(VarParam (variable,indx), value) -> List.append (if (variable = param) then [-1] else []) 
+                                             (count_param_writing_occurrences param value (count+1))
+| Set'(VarBound (variable,level,index), value) -> List.append (if (variable = param) then [-1] else []) 
+                                              (count_param_writing_occurrences param value (count+1))
+| Set'(VarFree (variable), value) -> List.append (if (variable = param) then [-1] else []) 
+                                      (count_param_writing_occurrences param value (count+1))
+| Applic'(expression, args) -> List.append (count_param_writing_occurrences param expression count) (map_count_writing_occurences args param count)
+| ApplicTP'(expression, args) -> List.append (count_param_writing_occurrences param expression count) (map_count_writing_occurences args param count)
+| Seq'(exp_list) -> map_count_writing_occurences exp_list param count
+| Or'(exp_list) -> map_count_writing_occurences exp_list param count
+| Def'(variable, value) -> List.append (count_param_writing_occurrences param (Var'(variable)) count) (count_param_writing_occurrences param value count)
+
+| If'(test, dit, dif) -> List.append 
+                          (List.append 
+                              (count_param_writing_occurrences param test (count+1)) 
+                              (count_param_writing_occurrences param dit (count+1))
+                          ) 
+                          (count_param_writing_occurrences param dif (count+1))
+
+(* if param is in the lambda param_list it is in a new lexical scope, so no occurrence *)
+| LambdaSimple'(p_list, b) -> if (List.mem param p_list) 
+                                then [] 
+                                else (if ((count_param_writing_occurrences param b (count+1)) = []) then [] else [count])
+| LambdaOpt'(p_list, opt_p, b) -> if (List.mem param (List.append p_list [opt_p]))
+                                    then [] 
+                                    else (if ((count_param_writing_occurrences param b (count+1)) = []) then [] else [count])
+| _ -> []
+
+and count_param_reading_occurrences param body count = match body with
+| Const'(value) -> []
+| Var'(VarParam (variable,indx)) -> if ( variable = param) then [-1] else []
+| Var'(VarBound (variable,level,index)) -> if ( variable = param) then [-1] else []
+| Var'(VarFree (variable)) -> if ( variable = param) then [-1] else []
+| Set'(variable, value) -> (count_param_reading_occurrences param value (count+1))
+| BoxSet'(variable,value) -> if (count_param_reading_occurrences param value (count+1)= []) then [] else [count]
+| Applic'(expression, args) -> List.append (count_param_reading_occurrences param expression count) (map_count_reading_occurences args param count)
+| ApplicTP'(expression, args) -> List.append (count_param_reading_occurrences param expression count) (map_count_reading_occurences args param count)
+| Seq'(exp_list) -> map_count_reading_occurences exp_list param count
+| Or'(exp_list) -> map_count_reading_occurences exp_list param count
+| Def'(variable, value) -> List.append (count_param_reading_occurrences param  (Var'(variable)) count) (count_param_reading_occurrences param value count)
+| If'(test, dit, dif) -> List.append 
+                          (List.append 
+                              (count_param_reading_occurrences param test (count+1)) 
+                              (count_param_reading_occurrences param dit (count+1))
+                          ) 
+                          (count_param_reading_occurrences param dif (count+1))
+(* if param is in the lambda param_list it is in a new lexical scope, so no occurrence *)
+| LambdaSimple'(p_list, b) -> if (List.mem param p_list) 
+                                then [] 
+                                else (if ((count_param_reading_occurrences param b (count+1)) = []) then [] else [count])
+| LambdaOpt'(p_list, opt_p, b) -> if (List.mem param (List.append p_list [opt_p]))
+                                    then [] 
+                                    else (if ((count_param_reading_occurrences param b (count+1)) = []) then [] else [count])
+| _ -> []
+
+and is_read_occ param body=
+  match body with
+  (*we have read occ of param if we have Var'(param) *)
+  | Var' (VarBound(name, level, index))-> if(name = param) then true else false
+  | Var' (VarParam (name, index)) -> if(name = param) then true else false
+  | Var' (VarFree(name))->if(name = param) then true else false
+  | Set' (var,exp)-> is_read_occ param exp  
+  |_->false
+
+and is_write_occ param body=
+  match body with
+  | Set' (VarBound(name, level, index), expr) -> if(name = param) then true else false
+  | Set' (VarParam (name, index), expr) ->if(name = param) then true else false
+  | Set' (VarFree(name), expr) -> if(name = param) then true else false
+  |_->false
+
+and has_read_occ param body =  match body with 
+  (*we have read occ of param if we have Var'(param) *)
+  | Var' (VarBound(name, level, index))-> if(name = param) then true else false
+  | Var' (VarParam (name, index)) -> if(name = param) then true else false
+  | Var' (VarFree(name)) -> if(name = param) then true else false
+  | Def' (variable, value) -> has_read_occ param (Var'(variable)) || has_read_occ param value
+  | If' (test, dit, dif) -> has_read_occ param test || has_read_occ param dit || has_read_occ param dif
+  | Seq' expr_list -> ormap (has_read_occ param) expr_list
+  | Set' (var, expr) -> has_read_occ param expr
+  | BoxSet' (_, expr) -> has_read_occ param expr
+  | Or' lst -> ormap (has_read_occ param) lst
+  | Applic' (op, args) -> has_read_occ param op || ormap (fun e -> has_read_occ param e) args
+  | ApplicTP' (op, args) -> has_read_occ param op || ormap (fun e -> has_read_occ param e) args
+
+  | LambdaSimple' (params, body) -> if (List.exists (fun e -> e = param) params)
+                                    then false
+                                    else has_read_occ param body
+  | LambdaOpt' (params, opt, body) -> if (List.exists (fun e -> e = param) (opt::params))
+                                      then false
+                                      else has_read_occ param body
+  | _ -> false 
+
+  and has_write_occ param body =
+  match body with
+  | Set' (VarBound (par, index, _), expr) -> par = param || has_write_occ param expr
+  | Set' (VarParam (par, index), expr) -> par = param || has_write_occ param expr
+  | Set' (VarFree(par), expr) -> par = param || has_write_occ param expr
+
+  | If' (test, dit, dif) -> has_write_occ param test || has_write_occ param dit || has_write_occ param dif
+  | Def' (e1, e2) -> has_write_occ param (Var'(e1)) || has_write_occ param e2
+  | Seq' lst -> ormap (has_write_occ param) lst
+  | BoxSet' (var, expr) -> has_write_occ param expr
+  | Or' lst -> ormap (has_write_occ param) lst
+  | Applic' (op, args) | ApplicTP' (op, args) -> has_write_occ param op || ormap (fun e -> has_write_occ param e) args
+  | LambdaSimple' (params, body) ->if (List.exists (fun e -> e = param) params)
+                                  then false
+                                  else has_write_occ param body
+  | LambdaOpt' (params, opt, body) -> if (List.exists (fun e -> e = param) (opt::params))
+                                then false
+                                else has_write_occ param body
+|  _ -> false
+
+(* Replace any set-occurances of v with BoxGet' *)
+let rec replace_set_occ param body =
+  match body with
+  | Const' _ | Var' _ | BoxGet' _ | Box' _ -> body
+  | BoxSet' (var, expr) -> BoxSet' (var, replace_set_occ param expr)
+  | If' (pred, dit, dif) -> If' (replace_set_occ param pred, replace_set_occ param dit, replace_set_occ param dif)
+        | Seq' lst -> Seq' (List.map (replace_set_occ param) lst)
+
+  | Def' (VarBound (par, n1, n2), e2) ->  Def' (VarBound (par, n1, n2), replace_set_occ param e2)
+  | Def' (VarParam (par, n1), e2) -> Def' (VarParam (par, n1), replace_set_occ param e2)
   
-end;; (* struct Semantics *)
+  | Set' ((VarBound (p, n1, n2)), expr) ->
+    if (p = param)
+    then BoxSet' (VarBound (param, n1, n2), replace_set_occ param expr)
+    else Set' (VarBound (p, n1, n2), replace_set_occ param expr)
+  | Set' (VarParam (p, n1), expr) ->
+  if (p = param)
+  then BoxSet' (VarParam (param, n1), replace_set_occ param expr)
+  else Set' (VarParam (p, n1), replace_set_occ param expr)
+  | Set' (VarFree var, expr) -> Set' (VarFree var, replace_set_occ param expr)
+  | Or' lst -> Or' (List.map (replace_set_occ param) lst)
+  | Applic'	(op, args) -> Applic'	(replace_set_occ param op, List.map (replace_set_occ param) args)
+  | ApplicTP' (op, args) -> ApplicTP' (replace_set_occ param op, List.map (replace_set_occ param) args)
+  | LambdaSimple' (params, body) ->
+    if (List.exists (fun e -> e = param) params)
+    then LambdaSimple' (params, body)
+    else LambdaSimple' (params, replace_set_occ param body)
+        | LambdaOpt' (params, opt, body) ->
+    if (List.exists (fun e -> e = param) (opt::params))
+    then LambdaOpt' (params, opt, body)
+    else LambdaOpt' (params, opt, replace_set_occ param body)
+        | _ -> raise X_this_should_not_happen  
+
+(* Replace any get-occurances of v with BoxGet' *)
+let rec replace_get_occ param body =
+  match body with
+  | Var' (VarBound (par, n1, n2)) ->
+      if (par = param)
+      then BoxGet' (VarBound (param, n1, n2))
+      else body
+          | Var' (VarParam (par, n1)) ->
+      if (par = param)
+      then BoxGet' (VarParam (param, n1))
+      else body
+  | Const' _ | Var' _ | BoxGet' _ | Box' _ -> body
+  | BoxSet' (var, expr) -> BoxSet' (var, replace_get_occ param expr)
+  | If' (pred, dit, dif) -> If' (replace_get_occ param pred, replace_get_occ param dit, replace_get_occ param dif)
+  
+  | Def' (VarBound (par, n1, n2), e2) ->
+    let test= replace_get_occ param (Var'(VarBound (par, n1, n2))) in
+    (match test with
+    | Var'(VarBound (e, n1, n2))-> Def' (VarBound (e, n1, n2), replace_get_occ param e2)
+    | _ -> raise X_this_should_not_happen )
+  
+  | Def' (VarParam (par, n1), e2) ->
+  let test= replace_get_occ param (Var'(VarParam (par, n1))) in
+    (match test with
+    | Var'(VarParam (e, n1))-> Def' (VarParam (e, n1), replace_get_occ param e2)
+    | _ -> raise X_this_should_not_happen )
+
+  | Seq' lst -> Seq' (List.map (fun e -> replace_get_occ param e) lst)
+  | Set' (VarBound (par, n1, n2), expr) ->
+      if (par = param)
+      then Set' (VarBound (param, n1, n2), replace_get_occ param expr) 
+      else 
+      let temp= replace_get_occ param (Var' (VarBound (par, n1, n2))) in
+      ( match temp with
+      | Var'(VarBound (par, n1, n2))->Set' (VarBound (par, n1, n2), replace_get_occ param expr) 
+      |_ -> raise X_this_should_not_happen 
+      )
+  | Set' (VarParam (par, n1), expr) ->
+      if (par = param)
+      then Set' (VarParam (param, n1), replace_get_occ param expr) 
+      else 
+      let temp= replace_get_occ param (Var' (VarParam (par, n1))) in
+    ( match temp with
+      | Var'(VarParam (par, n1))->Set' (VarParam (par, n1), replace_get_occ param expr) 
+      |_ -> raise X_this_should_not_happen 
+    )
+  | Set' (VarFree (var), expr) -> Set' (VarFree (var), replace_get_occ param expr)
+  | Or' lst -> Or' (List.map (fun e -> replace_get_occ param e) lst)
+  | Applic' (op, args) ->		Applic'   (replace_get_occ param op, List.map (fun e -> replace_get_occ param e) args)
+  | ApplicTP' (op, args) ->	ApplicTP' (replace_get_occ param op, List.map (fun e -> replace_get_occ param e) args)
+  | LambdaSimple' (params, body) ->
+  if (List.exists (fun e -> e = param) params)
+  then LambdaSimple' (params, body)
+  else LambdaSimple' (params, replace_get_occ param body)
+      | LambdaOpt' (params, opt, body) ->
+  if (List.exists (fun e -> e = param) (opt::params))
+  then LambdaOpt' (params, opt, body)
+  else LambdaOpt' (params, opt, replace_get_occ param body)
+      | _ -> raise X_this_should_not_happen
+
+  let box_param param min body =
+    let body = replace_get_occ param body in
+    let body = replace_set_occ param body in
+    match body with
+    | Seq' list -> Seq' ([Set' (VarParam (param, min), Box' (VarParam (param, min)))]@list)
+    | _ -> Seq' [Set' (VarParam (param, min), Box' (VarParam (param, min))); body] ;;
+
 
+  let foldfunc (param, minor) body =
+  if (need_boxing param body)
+  then (box_param param minor body)
+  else body;;
 
+  let uniq_cons x xs = if List.mem x xs then xs else x :: xs
+
+  let remove_from_right xs = List.fold_right uniq_cons xs []
+  
+let apply_box_on_lambda params body =
+  (* comine paran with it's index *)
+  let params= remove_from_right params in
+  let params = List.combine params (list_all_nums_befor (List.length params)) in
+  List.fold_right foldfunc params body;;
+
+let rec check_for_lambdas exp =
+  match exp with
+  | BoxSet' (var, expr) -> BoxSet' (var, check_for_lambdas expr)
+
+  | Def' (VarBound(name, level, index), e2) ->Def' (VarBound(name, level, index), check_for_lambdas  e2)  
+  | Def' (VarParam(name, index), e2) -> Def' (VarParam(name, index), check_for_lambdas  e2)
+  | Def' (VarFree (var), e2) -> Def' (VarFree (var), check_for_lambdas  e2)
+  
+  | If' (pred, dit, dif) -> If' (check_for_lambdas pred, check_for_lambdas dit, check_for_lambdas dif)
+  | Seq' lst -> Seq' (List.map check_for_lambdas lst)
+  
+  | Set'(VarParam (variable,indx), e2) ->  Set' (VarParam (variable,indx), check_for_lambdas  e2)
+  | Set'(VarBound (par, n1, n2), e2)->Set' (VarBound (par, n1, n2), check_for_lambdas  e2)
+  | Set'(VarFree (par), e2)-> Set' (VarFree (par), check_for_lambdas  e2)
+
+  | Or' lst -> Or' (List.map check_for_lambdas lst)
+  | Applic' (op, args) -> Applic' (check_for_lambdas op, List.map check_for_lambdas args)
+  | ApplicTP' (op, args) -> ApplicTP' (check_for_lambdas op, List.map check_for_lambdas args)
+  
+  | LambdaSimple' (params, body) -> LambdaSimple' (params, check_for_lambdas (apply_box_on_lambda params body))
+  | LambdaOpt' (params, opt, body) -> LambdaOpt' (params, opt, check_for_lambdas (apply_box_on_lambda (params@[opt]) body))
+  |_-> exp
+  ;;
+    
+let box_set e = check_for_lambdas e;;
+
+ let run_semantics expr =
+    box_set
+    (annotate_tail_calls
+    (annotate_lexical_addresses expr));;
+  end;; (* struct Semantics *)
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..798f42c 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -57,9 +57,380 @@ let reserved_word_list =
    "unquote-splicing"];;  
 
 (* work on the tag parser starts here *)
+(* ------------------------------------- *)
+(* Constants 3.2.1.1 *)
+(* ------------------------------------- *)
+let selfEval sexpr =
+  match sexpr with 
+  | Bool e ->  Const(Sexpr(sexpr))
+  | Char e -> Const(Sexpr(sexpr))
+  | Number e -> Const(Sexpr(sexpr))
+  | String e -> Const(Sexpr(sexpr))
+  | Nil -> Const(Sexpr(sexpr))
+  | _ -> nt_none()
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let constQuote sexpr = 
+   match sexpr with
+  | Pair(Symbol("quote"),Pair(exp,Nil)) -> Const(Sexpr(exp))
+  | _ -> nt_none() 
 
+let tag_const sexpr = 
+  disj selfEval constQuote sexpr;;
+
+
+(* ------------------------------------- *)
+(* Variables 3.2.1.2 *)
+(* ------------------------------------- *)
+let is_reserved_word w = 
+  List.mem w reserved_word_list ;;
+
+let tag_vars sexpr = 
+  match sexpr with
+  | Symbol(sym) -> if not (is_reserved_word sym) then Var(sym) else nt_none()
+  | _ -> nt_none()
+
+
+(* ------------------------------------- *)
+(* Conditionals 3.2.1.3 *)
+(* ------------------------------------- *)
+
+let make_if_exp if_lst = 
+  let tst_exp = List.nth if_lst 0 and
+  thn_exp = List.nth if_lst 1 and
+  els_exp = List.nth if_lst 2 in
+  If(tst_exp,thn_exp,els_exp) ;;
+
+(* ------------------------------------- *)
+(* Lambda Expressions 3.2.1.4 *)
+(* ------------------------------------- *)
+
+let rec get_last_sexpr sexpr = 
+  match sexpr with
+  | Pair(car,cdr) ->
+    (match cdr with
+        | Nil -> car
+        | _-> get_last_sexpr cdr)
+  | _ -> nt_none() ;;
+
+(* ------------------------------------- *)
+(* Quasiquated Expressions 3.2.2.1 *)
+(* ------------------------------------- *)
+
+let rec make_qq_pair sexpr = 
+  match sexpr with
+  | Pair(Symbol("unquote"),Pair(e,Nil)) -> e                  (* 1 *)   
+  | Pair(Symbol("unquote-splicing"),Pair(e,Nil)) -> e         (* 2 *)
+  | Symbol(s) -> Pair(Symbol("quote"),Pair(Symbol(s),Nil))    (* 3 *)
+  | Pair(a,b) ->                                              (* 5 *)
+    (
+      try match a with 
+        | Pair(Symbol("unquote-splicing"),Pair(e,Nil)) -> Pair(Symbol("append"), Pair(e,Pair((make_qq_pair b),Nil)))
+        | _ -> Pair(Symbol("cons"),Pair((make_qq_pair a),Pair((make_qq_pair b),Nil)))
+      with X_no_match -> 
+      try match b with 
+        | Pair(Symbol("unquote-splicing"),Pair(e,Nil)) -> Pair(Symbol("cons"), Pair((make_qq_pair a),b))
+        | _ -> nt_none()
+      with X_no_match ->
+        Pair(Symbol("cons"), Pair((make_qq_pair a),Pair((make_qq_pair b),Nil)))
+    )
+  | _ -> Pair(Symbol("quote"),Pair(sexpr,Nil))  ;;
+
+(* ------------------------------------- *)
+(* Let Expressions 3.2.2.3 *)
+(* ------------------------------------- *)
+let rec open_binding sexpr vars vals =
+  match sexpr with
+  | Nil -> (vars,vals)
+  | Pair(first,rest)-> 
+    (
+      match first with
+      | Pair(vr,Pair(vl,Nil)) -> open_binding rest (vars@[vr]) (vals@[vl])
+      | _ -> nt_none()
+    )
+  | _ -> nt_none();;
+
+let rec list_to_pair ls = 
+  if ls = [] then Nil else
+  Pair((List.hd ls), (list_to_pair (List.tl ls)));;
+
+let rec pair_to_list p =
+  match p with
+  | Pair(a,b) -> a::(pair_to_list b)
+  | Nil -> []
+  | _-> raise X_syntax_error;;
+
+let is_var expr =
+  match expr with
+  | Var(_) -> true
+  | _ -> false
+
+let rec drop_seq l =
+  match l with
+  | [] -> []
+  | Seq(s)  :: tl -> drop_seq ((List.hd s)::List.tl s)
+  | hd :: tl -> hd :: drop_seq tl;;
+
+(*given list of (v_1 expr_1) (v_2 expr_2) .... (v_n expr_n) 
+returns (v_1,v_2,..v_n  *)
+let rec get_vars args = 
+  match args with
+  | Nil -> Nil
+  | Pair(Pair(name, Pair(value, Nil)), rest) -> Pair(name, get_vars rest)
+  | _ -> args;;
+
+(*given list of (v_1 expr_1) (v_2 expr_2) .... (v_n expr_n) 
+returns (expr_1,expr_2,..xpr_n*)
+let rec get_expressions args = 
+  match args with
+  | Nil -> Nil
+  | Pair(Pair(name, Pair(value, Nil)), rest) -> Pair(value, get_expressions rest)
+  | _ -> args;;
+
+let rec let_to_lambda sexpr =
+  match sexpr with
+  | Pair(defs,body)->
+      let vars,vals = open_binding defs [] [] in
+      let vars = list_to_pair vars and
+          vals = list_to_pair vals in
+      let e = Pair(Symbol("lambda"),Pair(vars,body)) in
+      Pair(e,vals)
+  | _ -> nt_none();;
+
+(* ------------------------------------- *)
+
+  let rec tag_parse  = function
+    (* Constants *)
+    | Bool sexpr ->  Const(Sexpr(Bool(sexpr)))
+    | Char sexpr -> Const(Sexpr(Char(sexpr)))
+    | Number sexpr -> Const(Sexpr(Number(sexpr)))
+    | String sexpr -> Const(Sexpr(String(sexpr)))
+    | Nil ->  Const(Void)
+    | Pair(Symbol("quote"),Pair(exp,Nil)) -> Const(Sexpr(exp))
+    (* Variables *)
+    | Symbol(sym) -> if not (is_reserved_word sym) then Var(sym) else nt_none()
+    (* Conditionals *)
+    | Pair(Symbol("if"),exp) -> tag_if exp
+    (* Lambda *)
+    | Pair(Symbol("lambda"),Pair(arglist,body)) -> tag_lambda arglist body
+    (* Disjunctions *)
+    | Pair(Symbol("or"),exp) -> tag_or exp
+    (* Definitions *)
+    | Pair(Symbol("define"),exp)->tag_define exp
+    (* Assignments *)
+    | Pair(Symbol("set!"),exp)->tag_set exp
+    | Pair(Symbol("pset!"),exp)-> tag_parse (macro_pset exp)
+    (* Sequences  *)
+    | Pair(Symbol("begin"),exp) -> tag_seq_exp exp
+    (* QuasiQuote *)
+    | Pair(Symbol("quasiquote"),Pair(e,Nil)) -> tag_parse (make_qq_pair e)
+    (* Let *)
+    | Pair(Symbol("let"),e)-> tag_parse (let_to_lambda e)
+    (* Let-Astrics *)
+    | Pair(Symbol("let*"),e)-> macro_let_star e
+    (* Letrec *)
+    | Pair(Symbol("letrec"),e)-> macro_letrec e
+    (* And *)
+    | Pair(Symbol("and"), exp) -> tag_parse (macro_and exp)  
+    (* Cond *)
+    |Pair(Symbol("cond"),exp) -> tag_parse (macro_cond exp)
+    (* Application *)
+    | Pair(app,args) -> tag_applic app args 
+     
+
+
+(* If *)
+  and tag_if exp = 
+    match exp with
+      | Pair(test,Pair(dit,Pair(dif,Nil))) -> 
+        If((tag_parse test), (tag_parse dit),(tag_parse dif))
+      | Pair(test,Pair(dit,Nil)) -> 
+        If((tag_parse test),(tag_parse dit),Const(Void))
+      | _ -> nt_none()
+
+(* Lambda *)
+and tag_lambda arglist body = 
+  (* helper function *)
+  let make_symbols lst = 
+    List.map (fun (s) -> match s with |Var(sym) -> sym | _->nt_none()) lst
+  in
+  (* the main function *)
+  let body = Pair(Symbol("begin"),body) in
+  let a,b = make_expr_list arglist [] in
+  if b = [] then
+    LambdaSimple((make_symbols a),(tag_parse body))
+  else 
+    LambdaOpt((make_symbols a) , (List.hd (make_symbols b)), (tag_parse body))
+
+(* Applic *)
+  and tag_applic app args = 
+  let get_sexper_list args = 
+    let lst,_ = make_expr_list args [] in
+    lst 
+  in
+  Applic((tag_parse app) , (get_sexper_list args ))
+
+  (* Pair of sexpr -> (exprs list , [last one if dotted])*)  
+  and make_expr_list nest_pair lst= 
+    let get_exp sexpr = 
+      match sexpr with
+      | Pair(e,res) -> ((tag_parse e ),res)
+      | _ ->  nt_none()
+    in
+    if nest_pair = Nil then (lst,[]) else
+    try let v,res = get_exp nest_pair in
+      if res = Nil then (lst@[v],[]) else make_expr_list res (lst@[v]) 
+    with X_no_match -> (lst,[(tag_parse nest_pair)])
   
-end;; (* struct Tag_Parser *)
+   (*Disjunctions - which is or-expresion*)
+  and tag_or exp =
+  match exp with 
+  |Pair(sexpr, Nil) -> tag_parse sexpr
+  |Pair(sexpr,rest) -> Or((List.map tag_parse (pair_to_list exp)))
+  | Nil -> Const(Sexpr(Bool(false)))
+  | _-> raise X_syntax_error
+
+  (*Definitions*)
+  and tag_define exp= 
+    match exp with 
+      |Pair(Symbol(var_name),Nil) ->if not (is_reserved_word var_name) then Def(Var(var_name),Const(Void))  else nt_none() (*just declaration*)
+      |Pair(Symbol(var_name),Pair(sexpr,Nil)) ->if not (is_reserved_word var_name) then  Def(Var(var_name), (tag_parse sexpr))  else nt_none() 
+      |Pair(Pair(Symbol(var_name),args),expr) -> (macro_define var_name args expr)  (* MIT Define *)
+      | _-> raise X_syntax_error
+
+  and macro_define var_name args expr = 
+  let l = (List.map tag_parse (pair_to_list expr)) in
+    if(List.length l != 0 && (not (is_reserved_word var_name) )) then 
+      (Def(Var(var_name), tag_parse (Pair(Symbol("lambda"), Pair(args, expr)))))
+    else raise X_syntax_error
+    
+  (*Assignments - set!*)
+  and tag_set exp=
+    match exp with
+      |Pair(x,Pair(y,Nil)) -> 
+        let v=tag_parse x in
+          if (is_var v) then Set(v,(tag_parse y))  else nt_none()  
+      |_ -> raise X_syntax_error
+  
+  (* Sequences - explicisy*)
+  and tag_seq_exp exp= 
+    match exp with
+      | Nil -> Const(Void) (*An empty sequence should be tag-parsed to Const Void*)
+      | Pair(sexpr,Nil)-> tag_parse sexpr
+      | Pair(sexpr,rest)-> Seq(drop_seq (List.map tag_parse (pair_to_list exp))) 
+      | _ -> nt_none()
+  
+
+  (* Let* *)
+  and macro_let_star sexpr = 
+    let get_car_cdr p = 
+      match p with
+      | Pair(car,cdr)->(Pair(car,Nil),cdr) 
+      | _ -> nt_none()
+    in
+    match sexpr with
+    | Pair (args,body)->
+      (match args with
+        (* base case 1 *)
+        | Nil -> ( tag_parse (Pair(Symbol("let"),sexpr)) )
+        (* base case 2 *)   
+        | Pair (Pair (v, Pair (a, Nil)),Nil) -> ( tag_parse (Pair(Symbol("let"),sexpr)) )
+        (* case 3 *) 
+        | _ -> let v1,els = get_car_cdr args in
+        let els = Pair(Pair(Symbol("let*"),Pair(els,body)),Nil) in
+        let exp = Pair(Symbol("let"),Pair(v1,els))in
+        (tag_parse exp)
+      )
+    | _ -> nt_none()
+
+  (* Letrec*)
+  and macro_letrec sexpr = 
+
+    let rec add_set_bang p ls= 
+      match p with
+      | Pair(car,cdr)->
+        if cdr = Nil then ls@[Pair(Symbol("set!"),car)]
+        else add_set_bang cdr (ls@[Pair(Symbol("set!"),car)])
+      | _ -> nt_none()
+    in
+    match sexpr with
+      | Pair(defs,body)->
+        let vars,_ = open_binding defs [] [] in
+        let whatever = (List.hd (Reader.read_sexprs "'whatever")) in
+        let vars = list_to_pair (List.map (fun (x) -> Pair(x,Pair(whatever,Nil))) vars) in
+        let sets = add_set_bang defs [] in
+        let body = pair_to_list (Pair(Pair(Symbol("let"),Pair(Nil,body)),Nil)) in
+        let body = list_to_pair (sets@body) in
+        let e = Pair(Symbol("let"),Pair(vars,body)) in
+        (tag_parse e)
+    | _ -> nt_none()
+
+
+  and macro_and exp = match exp with
+    | Nil -> Bool(true)
+    | Pair(sexpr, Nil) -> sexpr
+    | Pair(sexpr, rest) -> Pair(Symbol("if"), Pair(sexpr, Pair( (macro_and rest), Pair( Bool(false), Nil ))))
+    | _ -> raise X_syntax_error
+
+    and get_string_from_symbol sym=match sym with
+    | Symbol(s)->s
+    | _ -> raise X_syntax_error
+
+    
+    and macro_pset args =   
+    let exprs= get_expressions args in
+    let vars= get_vars args in    
+    let vars_as_string= List.map (fun (sym)->get_string_from_symbol sym)  (pair_to_list vars) in
+    let new_vars=generate_new_vars vars_as_string [] vars_as_string in
+    let new_vars=List.map (fun s->Symbol (s)) new_vars in
+    let vars=List.map (fun s->Symbol (s)) vars_as_string in
+    let combined_pairs=List.combine vars new_vars in
+    let body=      
+    List.map (fun (var,exp)->Pair(Symbol("set! "), Pair(var,Pair( exp,Nil)))) combined_pairs in
+    let lmbda=Pair(Symbol("lambda"),Pair((list_to_pair new_vars),Pair((list_to_pair body),Nil))) in
+    Pair(lmbda,exprs)  
+     
+
+    and generate_new_vars all_vars vars_to_use  original_vars =
+      match original_vars with 
+      |[]->vars_to_use
+      |a::b->
+        let random_word = a^"s" in
+        let new_original_vars= random_word::b in
+        if( List.mem random_word all_vars) then 
+          generate_new_vars all_vars vars_to_use new_original_vars
+        else
+        let new_all_vars=random_word::all_vars in
+        random_word::generate_new_vars new_all_vars vars_to_use b 
+
+    and macro_cond args= 
+    match args with
+    (*test case 2*)
+    | Pair(Pair(test,Pair(Symbol("=>"),Pair(dit,Nil))),Nil) -> cond2_nil test dit
+    | Pair(Pair(test,Pair(Symbol("=>"),Pair(dit,Nil))),dif) -> cond2_dif test dit dif   
+    (*test case 3*)
+    |  Pair(Pair(Symbol("else"),dit),_) -> Pair(Symbol("begin"),dit)
+    (*test case 1*)
+    |Pair(Pair(test,dit),Nil) -> Pair(Symbol("if"),Pair(test,Pair(Pair(Symbol("begin"),dit),Nil)))
+    |Pair(Pair(test,dit),dif) -> Pair(Symbol("if"),Pair(test,Pair(Pair(Symbol("begin"),dit),Pair(Pair(Symbol("cond"),dif),Nil))))
+    |  _ -> args 
+
+    and cond2_nil test dit = 
+     Pair(Symbol("let"),Pair(Pair((make_let "value" test),
+     Pair((make_let "f" (make_lambda dit)),Nil)),
+     Pair((make_if_then "value" "f"),Nil)))
+
+    and cond2_dif test dit dif = 
+      Pair(Symbol("let"),Pair(Pair((make_let "value" test),
+      Pair((make_let "f" (make_lambda dit)),
+      Pair((make_let "rest" (make_lambda (Pair(Symbol("cond"),dif)))),Nil))),
+      Pair((make_if_then_else "value" "f" "rest"),Nil)))
+    
+      
+    and make_lambda exp=  Pair(Symbol("lambda"),Pair(Nil,Pair(exp,Nil)))
+    and make_let variable value = Pair(Symbol(variable),Pair(value,Nil))
+    and make_if_then test dit_func=Pair(Symbol("if"), Pair(Symbol(test),Pair(Pair(Pair(Symbol(dit_func),Nil),Pair(Symbol(test),Nil)),Nil)))
+    and make_if_then_else test dit_func dif_func = Pair(Symbol("if"),Pair(Symbol(test),Pair(Pair(Pair(Symbol(dit_func),Nil),Pair(Symbol(test),Nil)),
+                                                  Pair(Pair(Symbol(dif_func),Nil),Nil))));;
+    let tag_parse_expressions sexpr =(List.map tag_parse sexpr);;
 
+end;; (* struct Tag_Parser *)
\ No newline at end of file
