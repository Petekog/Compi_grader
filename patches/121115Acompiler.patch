diff --git a/omer folder/compiler.patch b/omer folder/compiler.patch
new file mode 100644
index 0000000..cfbec18
--- /dev/null
+++ b/omer folder/compiler.patch
@@ -0,0 +1,3057 @@
+diff --git a/compiler.patch b/compiler.patch
+new file mode 100644
+index 0000000..e69de29
+diff --git a/omer folder/compiler.patch b/omer folder/compiler.patch
+new file mode 100644
+index 0000000..425db86
+--- /dev/null
++++ b/omer folder/compiler.patch
+@@ -0,0 +1,2024 @@
++diff --git a/compiler.patch b/compiler.patch
++new file mode 100644
++index 0000000..e69de29
++diff --git a/omer folder/compiler.patch b/omer folder/compiler.patch
++new file mode 100644
++index 0000000..054936c
++--- /dev/null
+++++ b/omer folder/compiler.patch
++@@ -0,0 +1,1004 @@
+++diff --git a/reader.ml b/reader.ml
+++index 32445c2..24c92e3 100644
+++--- a/reader.ml
++++++ b/reader.ml
+++@@ -1,5 +1,5 @@
+++-
+++ #use "pc.ml";;
++++open PC;;
+++
+++ exception X_not_yet_implemented;;
+++ exception X_this_should_not_happen;;
+++@@ -17,18 +17,20 @@ type sexpr =
+++   | Symbol of string
+++   | Pair of sexpr * sexpr;;
+++
+++-let rec sexpr_eq s1 s2 =
+++-  match s1, s2 with
+++-  | Bool(b1), Bool(b2) -> b1 = b2
+++-  | Nil, Nil -> true
+++-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+++-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+++-  | Char(c1), Char(c2) -> c1 = c2
+++-  | String(s1), String(s2) -> s1 = s2
+++-  | Symbol(s1), Symbol(s2) -> s1 = s2
+++-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+++-  | _ -> false;;
+++
++++  let rec sexpr_eq s1 s2 =
++++    match s1, s2 with
++++    | Bool(b1), Bool(b2) -> b1 = b2
++++    | Nil, Nil -> true
++++    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
++++    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
++++    | Char(c1), Char(c2) -> c1 = c2
++++    | String(s1), String(s2) -> s1 = s2
++++    | Symbol(s1), Symbol(s2) -> s1 = s2
++++    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
++++    | _ -> false;;
++++
++++
+++ module Reader: sig
+++   val read_sexprs : string -> sexpr list
+++ end
+++@@ -40,7 +42,274 @@ let normalize_scheme_symbol str =
+++ 	s) then str
+++   else Printf.sprintf "|%s|" str;;
+++
++++let packOnFirst nt f s =
++++  let (e, s) = (nt s) in
++++  (f e);;
+++
+++-let read_sexprs string = raise X_not_yet_implemented;;
++++let packOnSecond nt f s =
++++  let (e, s) = (nt s) in
++++  (f s);;
+++
++++let notChar = make_char (fun ch1 ch2 -> ch1 != ch2);;
++++
++++
++++
++++let newLineParsaPred = packOnFirst   (caten (char '\\') (char 'n')) (fun _ ->  false);;
++++
++++(* let newLineParsa = pack (caten (char '\\') (char 'n')) (fun (e,s) -> s);; *)
++++let newLineParsa = char '\n';;
++++
++++let nt_whitespaces = star (char ' ');;
++++
++++
++++let make_paired nt_left nt_right nt =
++++let nt = caten nt_left nt in
++++let nt = pack nt (function (_, e) -> e) in
++++let nt = caten nt nt_right in
++++let nt = pack nt (function (e, _) -> e) in
++++nt;;
++++
++++let make_spaced nt =
++++  make_paired nt_whitespaces nt_whitespaces nt;;
++++
++++let semicolonParser = char ';';;
++++
++++
++++(* let notNewLineParser = packOnFirst( (const (newLineParsaPred))) (fun ch -> ch);; *)
++++let notNewLineParser  = const(fun p -> p!= '\n');;
++++(* let notNewLineParser = (const(fun p -> p!= "\\n")) ;; *)
++++(* let notNewLineParser = let nt = word "\\n" in
++++                       let nt = ;; *)
++++(* let notNewLineParser  = try word "\\n"
++++                        with X_no_match  ->  nt_any
++++                          ;; *)
++++
++++
++++
++++
++++(* let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');; *)
++++let notNewLineParser2 = (star (notNewLineParser)) ;;
++++(* this check as long as there is no new line *)
++++
++++let make_line_comment_parser_paired  =
++++  let nt = caten semicolonParser notNewLineParser2 in
++++  let nt = pack nt (function (_, e) -> e) in
++++  let nt = caten nt newLineParsa in
++++  let nt = packOnSecond nt (function e ->  (e,e)) in
++++  nt;;
++++
++++
++++(* let lineCommentParser = make_spaced ( pack (caten   semicolonParser (caten (star notNewLineParser)  newlineParser)) (fun _ -> [' '])  );; *)
++++
++++
++++(* Boolean, dot, CharPrefix, Digit,Natural,  Fraction, Float*)
++++let backSlashParser = char '\\';;
++++let hashParser = char '#';;
++++
++++(*
++++⟨Boolean⟩::= #f | #t
++++*)
++++let booleanParser = make_spaced( PC.pack (PC.caten hashParser (PC.disj (PC.char_ci 't') (PC.char_ci 'f') ))
++++        (fun (_, ch) -> if ch = 't' || ch = 'T' then Bool true else Bool false));;
++++
++++(* digit => Natural => Integer => Fraction => Float => *)
++++let digitParser  = range '0' '9';;  (* Parses all numbers between 0-9 <digit> *)
++++let digitSeqParser = (plus digitParser);;(* <digit>+ *)
++++let naturalParser = pack digitSeqParser (fun str ->  (int_of_string(list_to_string str)));;(*Turns a list of chars of numbers into a natural number*)
++++
++++
++++let maybeMinusPlusParser = (* Parses  (+|-)? and returns -1 if the char that is parsed is - and 1 otherwise *)
++++  let plusParser = pack (char '+') (fun _ -> 1) in  (*returns 1*)
++++  let minusParser =  pack (char '-') (fun _ -> -1) in (*returns -1*)
++++  pack (maybe(disj plusParser minusParser)) (fun opt -> match opt with Some(e) -> e | None -> 1);;
++++
++++let integerParser = pack (caten maybeMinusPlusParser naturalParser) (fun (e,s) -> e*s);; (* <Integer> catens the (+|-)? with natural number and multiplies the outputs  *)
++++
++++let rec gcd a b = (*returns greates commod divisor of a and b *)
++++  if b = 0 then a else gcd b (a mod b);;
++++
++++let fractionParser = (*<Fraction> = <Integer> / <Natural> *)
++++  let fractionPar = pack( caten( caten integerParser (char '/')) naturalParser) (fun ((i, d), n) ->
++++  let div = gcd i n in (*gets gcd if the numerator and denominator*)
++++  Fraction (i/div, n/div)) in  (*makes the smallest number of an integer and natural number*)
++++  let integerToFraction = pack integerParser (fun num -> Fraction (num, 1)) in (*an Integer is parsed into a Fraction with 1 as the denominator*)
++++    disj fractionPar integerToFraction ;;
++++
++++let mantissaParser = pack digitSeqParser (fun lst -> (* parses a list of digit chars to a mantissa*)
++++  let with0 = String.concat "" ["0."; (list_to_string lst)] in (*before the char list is turned into a float, the list ['0';'.'] is concatenated before it so the number will stay as a mantissa *)
++++  float_of_string with0);;
++++
++++let floatParser string = pack( caten( caten integerParser (char '.')) mantissaParser) (fun ((i, d), m) -> (*<Float> = ⟨Integer⟩.⟨Natural⟩*)
++++   if i > 0 then  (float_of_int i)+.m (*connect the integer with a mantissa *)
++++   else if i==0 && List.nth string 0 != '-'  then (float_of_int i) +. m
++++   else (float_of_int i) -. m) string;;
++++
++++let scientificNotationParser = (* The scientic notation is of the form of (integer | float) e|E integer*)
++++    let integerAndFloat = disj  floatParser (pack integerParser (fun num ->  float_of_int num ))  in  (** returns a Float, if the num is int it makes a Float of it*)
++++    let e = pack (char_ci 'e') (fun _ -> Nil) in
++++    pack( caten( caten integerAndFloat e) integerParser) (fun ((num, d), pow) -> num *. 10.0 ** (float_of_int pow));;
++++let numberParser = make_spaced( pack (disj (pack (disj scientificNotationParser floatParser) (fun fl -> Float fl) ) fractionParser) (fun num -> Number num ));; (* (scientifNotation | Float | Fraction)*)
++++
++++
++++let charPrefixParser = pack (caten hashParser backSlashParser) (fun _ -> Nil);;
++++
++++let visibleCharParser = pack (const (fun p -> p > ' ')) (fun ch -> Char ch);;
++++
++++let nulParser = pack( word_ci "nul") (fun _ -> Char (char_of_int 0));;
++++let newlineParser = pack( word_ci "newline") (fun _ -> Char (char_of_int 10));;
++++let returnParser = pack( word_ci "return") (fun _ -> Char (char_of_int 13));;
++++let tabParser = pack( word_ci "tab") (fun _ -> Char (char_of_int 9));;
++++let formfeedParser = pack( word_ci "page") (fun _ -> Char (char_of_int 12));;
++++let spaceParser = pack( word_ci "space") (fun _ -> Char (char_of_int 32));;
++++
++++
++++let namedCharParser = disj_list  [nulParser; newlineParser; returnParser; tabParser; formfeedParser; spaceParser];;
++++
++++let charParser = make_spaced( pack (caten charPrefixParser (disj namedCharParser visibleCharParser)) (fun (_, ch) -> ch));;
++++
++++(* need to add named char*)
++++
++++
++++let dotParser string= pack (guard (char '.') (fun _ -> List.length(string) > 1))(fun _ -> ".") string;; (**doest parse if . is alone *)
++++let symbolCharNoDotParser = (*Parses all the chars that are not a dot and turns them into a string*)
++++    let letter_ciParser = pack(range_ci 'a' 'z') (fun ch -> lowercase_ascii ch) in
++++    let punctuationParser = one_of "!$^*-_=:+<>/?" in
++++    pack (disj_list [digitParser ; letter_ciParser ; punctuationParser]) (fun sym -> String.make 1 sym);;
++++let symbolCharParser = disj symbolCharNoDotParser dotParser;; (*(<dot> | <symbolCharNoDot>)*)
++++let symbolParser =
++++    let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in (*<symbolChar><symbolChar>+, connects the strings of the symbols *)
++++    let symbolParserWithoutNumber = (disj withDotParser symbolCharNoDotParser) in
++++    pack symbolParserWithoutNumber (fun str ->
++++    try (let (e,s) = numberParser (string_to_list str) in
++++    if s == [] then e else Symbol(str))
++++    with X_no_match -> Symbol(str));; (*Constructs a symbol with a string*)
++++
++++ (* let symbolParserWithoutNumber =
++++  let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in
++++  disj withDotParser symbolCharNoDotParser;;
++++let symbolParser string=
++++  let parsedBySymbol = symbolParserWithoutNumber
++++  try (let number = numberParser )  *)
++++
++++
++++let gershaimParser = PC.char '"';;
++++
++++let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');;
++++
++++let returnStringMetaCharParser = pack (char_ci 'r') (fun _ -> char_of_int 13)
++++let newlineStringMetaCharParser = pack (char_ci 'n') (fun _ -> char_of_int 10)
++++let tabStringMetaCharParser = pack (char_ci 't') (fun _ -> char_of_int 9)
++++let pageStringMetaCharParser = pack (char_ci 'f') (fun _ -> char_of_int 12)
++++let backslashStringMetaCharParser = pack (char_ci '\\') (fun _ -> char_of_int 92)
++++let gershaimStringMetaCharParser = pack (char_ci '"') (fun _ -> char_of_int 34)
++++
++++let stringMetaCharParser = pack (caten backSlashParser (disj_list [returnStringMetaCharParser;
++++                                      newlineStringMetaCharParser;
++++                                      tabStringMetaCharParser;
++++                                      pageStringMetaCharParser;
++++                                      backslashStringMetaCharParser;
++++                                      gershaimStringMetaCharParser]) ) (fun (_, ch) -> ch);;
++++
++++let stringCharParser = disj stringMetaCharParser stringLiteralCharParser;;
++++
++++let stringParser = make_spaced( pack (caten (caten gershaimParser (star stringCharParser)) gershaimParser)
++++                      (fun ((_, lst), _) -> String (list_to_string lst)) );;
++++
++++(* let numberParser = pack (disj floatParser fractionParser) (fun num -> Number num );; *)
++++(* bad number parser *)
++++
++++let openParenthasisParser = char '(';;
++++let closedParenthasisParser = char ')';;
++++
++++
++++(* let emptyListParser = make_spaced( pack (make_paired openParenthasisParser closedParenthasisParser (caten (disj nt_whitespaces make_line_comment_parser_paired) nt_whitespaces)) (fun _ -> Nil) ) *)
++++
++++
++++
++++(* let emptyListParser = pack(make_line_comment_parser_paired) (fun _-> Nil) ;;  *)
++++
++++(* let singleQuoteParser = char ''';;
++++let quoteParser =  make_spaced( pack (  caten singleQuoteParser read_   ) (fun  )  );;
++++
++++let quotingParser = NUL;; *)
++++
++++let veryGoodDotParser = pack(char '.') (fun ch -> Char ch) ;;
++++
++++
++++let rec starush nt s =
++++  try let (e, s) = (nt s) in
++++      let (es, s) = (starush nt s) in
++++      (Pair(e,es), s)
++++  with X_no_match -> (Nil, s);;
++++
++++
++++let rec starush2 nt s =
++++  try let (e, s) = (nt s) in
++++      let (es, s) = (starush nt s) in
++++      (Pair(e,es), s)
++++  with X_no_match ->
++++                     try let ((e,e2),s) = (caten veryGoodDotParser nt) s in
++++                     (e2,s)
++++                     with X_no_match -> (Nil, s);;
++++
++++let plusush nt =
++++  pack (caten nt (starush nt))
++++        (fun (e, es) -> (Pair(e,es)));;
++++
++++
++++let rec read_sexpr paparapa=
++++  let rec improperSecondArgumentParser = pack ( make_spaced( (caten veryGoodDotParser (caten nt_whitespaces read_sexpr )  ))) (fun (_,(_,e)) ->  e)
++++  and
++++
++++  starushu nt s =
++++    try let (e, s) = (nt s) in
++++        let (es, s) = (disj (improperSecondArgumentParser) (starushu nt ) ) s in
++++        (Pair(e,es), s)
++++    with X_no_match -> (Nil, s)
++++  in
++++
++++   let rec listParser = pack( (caten openParenthasisParser (caten  (disj (starushu (make_spaced read_sexpr)) (starush (make_spaced read_sexpr))) closedParenthasisParser)  )) (fun (_,(e,_)) -> e)
++++   (* let listParser = pack( make_spaced( caten openParenthasisParser (caten read_sexpr (caten (disj_list [improperSecondArgumentParser; noSecondItemInPairParser; secontItemInPairParser] ) closedParenthasisParser ))) ) (fun (_,(ent1,( ent2, _))) -> Pair(ent1, ent2)) *)
++++  and
++++
++++   lineCommentParser = pack (make_line_comment_parser_paired) (fun _ -> Nil)
++++  and sexpCommentParser = pack (caten (char '#')  (caten (char ';') read_sexpr )) (fun _ -> Nil)
++++  in let commentParser = (pack (make_spaced(disj sexpCommentParser lineCommentParser ))) (fun _ -> Nil)
++++  in let emptyListParser = pack((caten openParenthasisParser (caten (star commentParser) closedParenthasisParser))) (fun _ -> Nil)
++++  in let quoteParser = pack( (caten (make_spaced(char (char_of_int 39))) read_sexpr)) (fun (e,s) -> Pair(Symbol("quote"),Pair(s,Nil)))
++++  in let qQuoteParser =  pack( (caten (make_spaced(char '`')) read_sexpr)) (fun (e,s) -> Pair(Symbol("quasiquote"),Pair(s,Nil)))
++++  in let unQuoteParser =  pack( (caten (make_spaced(char ',')) read_sexpr)) (fun (e,s) -> Pair(Symbol("unquote"),Pair(s,Nil)))
++++  in let unQuoteSplicingParser =  pack( caten (make_spaced(caten (char ',') (char '@'))) read_sexpr) (fun (e,s) -> Pair(Symbol("unquote-splicing"),Pair(s,Nil)))
++++
++++  in pack (caten (star commentParser) (caten (disj_list [quoteParser; qQuoteParser; unQuoteParser; unQuoteSplicingParser; emptyListParser;listParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star commentParser))) (fun (_,(s,_)) -> s)
++++  paparapa
++++  ;;
++++
++++
++++(* let rec read_sexpr =
++++  pack (caten (star sexpCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star sexpCommentParser))) (fun (_,(s,_)) -> s)
++++  and lineCommentParser = (pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil) )
++++  and sexpCommentParser  = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr ))) (fun _ -> Nil)
++++  ;; *)
++++
++++(* let lineCommentParser = pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil);; *)
++++
++++(* let sexpCommentParser = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr)) (fun _ -> Nil);; *)
++++
++++(* let rec read_sexpr =   pack (caten (star lineCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star lineCommentParser))) (fun (_,(s,_)) -> s)  ;; *)
++++(* (fun c -> match c with
++++| Nil -> []
++++| _ -> c) ;; *)
++++
++++(* let read_sexpr =
++++
++++  try pack( caten commentParser (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])) (fun (e,s) -> s)
++++  with X_no_match ->  try pack( caten  (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])commentParser ) (fun (e,s) -> e)
++++    with X_no_match -> disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser];; *)
++++(* let read_sexpr str = disj_list [booleanParser ; charParser ; numberParser ; stringParser ; symbolParser ] *)
++++
++++let read_sexprs string = let (e,s) = (caten (star read_sexpr) nt_end_of_input ) (string_to_list string) in
++++            let (e2, s2)= e in
++++             e2;;
+++ end;; (* struct Reader *)
++++
+++diff --git a/readme.txt b/readme.txt
+++index e69de29..710c26c 100644
+++--- a/readme.txt
++++++ b/readme.txt
+++@@ -0,0 +1,10 @@
++++Itay Almoznino 318911187
++++Tommer Federman 212198378
++++
++++We assert that the work we submitted is 100% our own. We have not received any
++++part from any other student in the class, nor have we give parts of it for use to others.
++++Nor have we used code from other sources: Courses taught previously at this university,
++++courses taught at other universities, various bits of code found on the internet, etc.
++++We realize that should our code be found to contain code from other sources, that a
++++formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
++++action.
+++diff --git a/semantic-analyser.ml b/semantic-analyser.ml
+++index 8e684f0..370db40 100644
+++--- a/semantic-analyser.ml
++++++ b/semantic-analyser.ml
+++@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
+++   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
+++   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+++   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+++-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
+++-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+++-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+++-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
+++-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+++-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+++-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
+++-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
+++-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
+++   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
+++                                             (expr'_eq th1 th2) &&
+++                                               (expr'_eq el1 el2)
+++@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
+++   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
+++ 	 (expr'_eq e1 e2) &&
+++ 	   (List.for_all2 expr'_eq args1 args2)
+++-  | _ -> false;;
+++-
++++  | _ -> false;;
++++
++++
+++ exception X_syntax_error;;
+++
+++ module type SEMANTICS = sig
+++@@ -65,21 +57,397 @@ module type SEMANTICS = sig
+++   val annotate_lexical_addresses : expr -> expr'
+++   val annotate_tail_calls : expr' -> expr'
+++   val box_set : expr' -> expr'
+++-end;;
++++  end;;
+++
+++ module Semantics : SEMANTICS = struct
++++(*How the function works- for each lambda of depth n, i create n counters that count the minor number of vars for each bound var,
++++for that n counters are needed, except of that, i keep all the params of the lambdas in a 2d-list*)
++++let rec parse_expr_to_expr' expr env_param_list  =
++++  let callParse expr = parse_expr_to_expr' expr env_param_list in
++++  let parseVar str = parse_to_var str env_param_list in
++++  match expr with
++++| Const(sexpr) -> Const'(sexpr)
++++| Var(str) ->   Var'(parseVar str)
++++| If(e1,e2,e3) ->  If'(callParse e1 ,callParse e2,callParse e3 )
++++| Seq(exprl) -> Seq'(List.map callParse exprl)
++++| Set(Var(str),expr2) ->  Set'(parseVar str ,callParse expr2 )
++++| Def(Var(str), expr2) ->  Def'(parseVar str, callParse expr2)
++++| Or(exprl) -> Or'(List.map callParse exprl)
++++| LambdaSimple(strl, expr) -> LambdaSimple'(strl, parse_expr_to_expr' expr ((strl:: env_param_list)) )
++++| LambdaOpt(strl, opt, expr) -> LambdaOpt'(strl, opt, parse_expr_to_expr' expr ((strl@[opt])::env_param_list) )
++++| Applic(expr, exprl) -> Applic'(callParse expr,List.map callParse exprl)
++++(* test - LambdaSimple (["x"], Applic (Var "x",[LambdaSimple (["y"],Applic (Var "x",[Var "y"; LambdaSimple (["z"], Applic (Var "x", [Var "y"; Var "z"]))]))])) *)
++++and get_index_of_arr str env_params ind =
++++  let nth = List.nth env_params ind in
++++  if ind > List.length env_params then -1
++++  else if List.exists (fun x -> x = str) nth then ind
++++  else get_index_of_arr str env_params (ind+1)
+++
+++-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
++++(* and make_counter() =
++++  let x = ref(-1) in
++++  fun() -> x := !x + 1; !x  *)
+++
+++-let annotate_tail_calls e = raise X_not_yet_implemented;;
++++and printList lst = match lst with
++++| hd :: tl ->  "["^(stringList hd)^"];"^(printList tl)
++++| [] -> ""
+++
+++-let box_set e = raise X_not_yet_implemented;;
++++and stringList strl = match strl with
++++| hd ::tl -> (hd)^";"^(stringList tl)
++++| [] -> ""
+++
+++-let run_semantics expr =
++++and get_index_of_var_in_env var var_arr ind=
++++  let nth = (List.nth (var_arr) ind) in
++++  if (nth = var) then ind
++++  else get_index_of_var_in_env var var_arr (ind+1)
++++
++++and parse_to_var str env_params =
++++  let major_count =
++++    if (not (List.exists (List.exists (fun x -> str = x)) env_params)) then -1 (* no lambda params has the str and so it is free *)
++++    else get_index_of_arr str env_params 0
++++    in
++++    (* (Printf.printf "params [%s]" (printList env_params)) ; *)
++++  match major_count with
++++  | -1 -> VarFree(str)
++++  | 0 -> VarParam(str, get_index_of_var_in_env str (List.nth env_params major_count) 0)
++++  | n -> VarBound(str, major_count-1, get_index_of_var_in_env str (List.nth env_params major_count) 0);;
++++
++++let annotate_lexical_addresses e = parse_expr_to_expr' e [];;
++++
++++
++++let rec annotate_tp e tp = match e with (* https://www.cs.bgu.ac.il/~comp151/wiki.files/ps8.pdf*)
++++| Const'(cons) -> e
++++| Var'(v) -> e
++++| If'(test, dit, dif) -> If'(annotate_tp test false, annotate_tp dit tp, annotate_tp dif tp)
++++| Seq'(expl) -> Seq'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
++++| Set'(v, exp) -> Set'(v,annotate_tp exp false)
++++| Def'(v, exp) -> Def'(v, annotate_tp exp  false)
++++| Or'(expl) -> Or'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
++++| LambdaSimple'(strl, exp) -> LambdaSimple'(strl,  annotate_tp exp true)
++++| LambdaOpt'(strl, opt, exp) -> LambdaOpt'(strl, opt, annotate_tp exp true)
++++| Applic'(exp, expl) -> if tp then ApplicTP'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
++++                        else Applic'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl);;
++++
++++let annotate_tail_calls e = annotate_tp e false;;
++++
++++(* type var =
++++  | VarFree of string
++++  | VarParam of string * int
++++  | VarBound of string * int * int;; *)
++++
++++
++++
++++
++++let name_of_var v = match v with
++++|VarFree(s) -> s
++++|VarParam(s, _) -> s
++++|VarBound(s,_,_) -> s
++++|_ -> raise X_syntax_error
++++;;
++++
++++let get_number_based_on_variable var = match var with
++++|VarParam(s, minor) -> -1
++++|VarBound(s, major, minor) -> major
++++|_ -> raise X_syntax_error
++++;;
++++
++++(* receives an expression expr and var varParam, and boxes all occurences of the var,
++++ this function will be called at step 2 of boxing in closures*)
++++
++++let check_if_var_is_in_param_list params varName = match params with
++++|[] -> false
++++|_ -> List.exists (fun t -> t = varName) params;;
++++
++++let is_read_occure expr varParam = match expr with
++++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++++                  then true
++++                  else false
++++|_ -> false
++++;;
++++
++++let rec has_read_occure expr varParam = match expr with
++++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++++                  then true
++++                  else false
++++|Box'(box_var) -> has_read_occure (Var'(box_var)) varParam
++++|BoxSet'(box_set_var, box_set_val) -> has_read_occure box_set_val varParam
++++|If'(test, tCase, fCase) -> has_read_occure_in_seq ([test]@[tCase]@[fCase]) varParam
++++|Seq'(seq_list) -> has_read_occure_in_seq seq_list varParam
++++|Set'(set_var, set_val) -> has_read_occure set_val varParam
++++|Def'(def_var,def_val) -> has_read_occure def_val varParam
++++|Or'(or_list) -> has_read_occure_in_seq or_list varParam
++++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++++                                then false
++++                                else has_read_occure body varParam (* lookoo *)
++++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++++                                  then false
++++                                  else has_read_occure body varParam (* lookoo *)
++++|Applic'(proc, args) -> let proc_and_args = proc::args in
++++                              has_read_occure_in_seq proc_and_args varParam
++++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++++                              has_read_occure_in_seq proc_and_args varParam
++++|_ -> false
++++
++++and  has_read_occure_in_seq expr_list varParam = match expr_list with
++++|[] -> false
++++|_ -> List.exists (fun t -> has_read_occure t varParam) expr_list;;
++++
++++let is_write_occure expr varParam = match expr with
++++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++++                           then true
++++                           else false
++++|_ -> false
++++;;
++++(* returns true if the expression is a write occure of the var *)
++++
++++let rec has_write_occure expr varParam = match expr with
++++|BoxSet'(box_set_var, box_set_val) -> has_write_occure box_set_val varParam
++++|If'(test, tCase, fCase) -> has_write_occure_in_seq ([test]@[tCase]@[fCase]) varParam
++++|Seq'(seq_list) -> has_write_occure_in_seq seq_list varParam
++++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++++                           then true
++++                           else false
++++|Def'(def_var,def_val) -> has_write_occure def_val varParam
++++|Or'(or_list) -> has_write_occure_in_seq or_list varParam
++++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++++                                then false
++++                                else has_write_occure body varParam (* lookoo *)
++++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++++                                  then false
++++                                  else has_write_occure body varParam (* lookoo *)
++++|Applic'(proc, args) -> let proc_and_args = proc::args in
++++                         has_write_occure_in_seq proc_and_args varParam
++++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++++                          has_write_occure_in_seq proc_and_args varParam
++++|_ -> false
++++
++++
++++
++++and  has_write_occure_in_seq expr_list varParam = match expr_list with
++++|[] -> false
++++|_ -> List.exists (fun t -> has_write_occure t varParam) expr_list;;
++++
++++(* this function gets:
++++   # expr- of type expr'
++++   # varParam- of type VarParam
++++   # c_id - closure id which signifies the closure we are in. the importance of this is that
++++   we can check the first condition of boxing with it
++++   # a counter!!!! starts at 0
++++
++++  the function returns a list of all the get occurences for each occurence it gives:
++++   # c_id - closure id
++++   # depth - the depth of the variable read. if it is of type VarParam then -1.
++++   if it is of type bound then the value of the major
++++
++++   *)
++++
++++let rec make_list_of_get_occures expr varParam c_id counter_man = match expr with
++++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++++                  then [c_id,(get_number_based_on_variable var_var)]
++++                  else []
++++|Box'(box_var) ->  make_list_of_get_occures (Var'(box_var)) varParam c_id counter_man
++++|BoxSet'(box_set_var, box_set_val) -> make_list_of_get_occures box_set_val varParam c_id counter_man
++++|If'(test, tCase, fCase) -> (List.concat (has_read_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
++++|Seq'(seq_list) -> (List.concat (has_read_occure_in_seq_complex seq_list varParam c_id counter_man))
++++|Set'(set_var, set_val) -> make_list_of_get_occures set_val varParam c_id counter_man
++++|Def'(def_var,def_val) -> make_list_of_get_occures def_val varParam c_id counter_man
++++|Or'(or_list) -> (List.concat (has_read_occure_in_seq_complex or_list varParam c_id counter_man))
++++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++++                                then []
++++                                else make_list_of_get_occures body varParam (counter_man()) counter_man (* lookoo *)
++++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++++                                  then []
++++                                  else make_list_of_get_occures body varParam (counter_man()) counter_man(* lookoo *)
++++|Applic'(proc, args) -> let proc_and_args = proc::args in
++++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++++|_ -> []
++++
++++(* this function is the read occures in seq but it records what it sees yeahhhh *)
++++and  has_read_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
++++|[] -> []
++++|one::two -> match one with
++++            |LambdaSimple'(params, body) -> (make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++            |LambdaOpt'(params, opt, body) ->(make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++            |_ -> (make_list_of_get_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++;;
++++
++++
++++
++++let rec make_list_of_set_occures expr varParam c_id counter_man = match expr with
++++|BoxSet'(box_set_var, box_set_val) -> make_list_of_set_occures box_set_val varParam c_id counter_man
++++|If'(test, tCase, fCase) -> (List.concat (has_write_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
++++|Seq'(seq_list) -> (List.concat (has_write_occure_in_seq_complex seq_list varParam c_id counter_man))
++++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++++                            then [c_id,(get_number_based_on_variable set_var)]
++++                            else []
++++|Def'(def_var,def_val) -> make_list_of_set_occures def_val varParam c_id counter_man
++++|Or'(or_list) -> (List.concat (has_write_occure_in_seq_complex or_list varParam c_id counter_man))
++++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++++                                then []
++++                                else make_list_of_set_occures body varParam (counter_man()) counter_man (* lookoo *)
++++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++++                                  then []
++++                                  else make_list_of_set_occures body varParam (counter_man()) counter_man(* lookoo *)
++++|Applic'(proc, args) -> let proc_and_args = proc::args in
++++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++++|_ -> []
++++
++++(* this function is the read occures in seq but it records what it sees yeahhhh *)
++++and  has_write_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
++++|[] -> []
++++|one::two -> match one with
++++            |LambdaSimple'(params, body) -> (make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++            |LambdaOpt'(params, opt, body) ->(make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++            |_ -> (make_list_of_set_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++++;;
++++
++++
++++(* this function gets expression and varParam and checks if we need to box the param *)
++++(* let shall_we_box expr varParam =  *)
++++let make_box_id_counter() =
++++  let x = ref(0) in
++++  fun() -> x := !x + 1; !x ;;
++++
++++let rec make_lambda_params_vars params num = match params with
++++|[] -> []
++++|_ ->  (make_lambda_params_vars (List.tl params) (num+1))@[VarParam(List.hd (params), num)]
++++;;
++++(* let papa = make_box_id_counter();; *)
++++
++++(* "one" is the get and "two" is the set *)
++++let does_this_match_require_boxing  cartesian_product =
++++          let (one,two) = cartesian_product in
++++            if((fst one) = (fst two)) (* if read and write are in differnt closures*)
++++            then false
++++            else (if ((snd one) = -1 || (snd two) = -1 || (((snd one) = 0 && (snd two) = 0))) (* if both occurences do not refer to same rib *)
++++            then true
++++            else false)
++++
++++let is_boxing_needed_2 get_list set_list =
++++          let cartesian =   List.concat (List.map (fun e -> List.map (fun e' -> (e,e')) get_list) set_list) in
++++          List.exists (fun x -> does_this_match_require_boxing x) cartesian;;
++++
++++let add_set_tag_to_body_of_lambda expr varParam = match expr with
++++|LambdaSimple'(params, Seq'(seq_list)) -> (LambdaSimple'(params, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
++++|LambdaSimple'(params, other) -> (LambdaSimple'(params, Seq'([Set'(varParam,Box'(varParam));other])))
++++|LambdaOpt'(params, opt, Seq'(seq_list)) -> (LambdaOpt'(params, opt, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
++++|LambdaOpt'(params, opt, other) -> (LambdaOpt'(params, opt, Seq'([Set'(varParam,Box'(varParam));other])))
++++|_ -> raise X_syntax_error;;
++++
++++let rec replace_get_set expr varParam = match expr with
++++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++++                  then BoxGet'(var_var)
++++                  else Var'(var_var)
++++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, replace_get_set box_set_val varParam)
++++|If'(test, tCase, fCase) -> If'((replace_get_set test varParam), (replace_get_set tCase varParam), (replace_get_set fCase varParam))
++++|Seq'(seq_list) -> Seq'((List.map (fun t -> replace_get_set t varParam) seq_list))
++++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++++                           then (BoxSet'(set_var, replace_get_set set_val varParam))
++++                           else Set'(set_var, replace_get_set set_val varParam)
++++|Def'(def_var,def_val) -> Def'(def_var,replace_get_set def_val varParam)
++++|Or'(or_list) -> Or'((List.map (fun t -> replace_get_set t varParam) or_list))
++++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++++                                then LambdaSimple'(params, body)
++++                                else LambdaSimple'(params, (replace_get_set body varParam)) (* lookoo *)
++++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++++                                  then LambdaOpt'(params, opt, body)
++++                                  else LambdaOpt'(params, opt, (replace_get_set body varParam)) (* lookoo *)
++++|Applic'(proc, args) -> Applic'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
++++|ApplicTP'(proc, args) -> ApplicTP'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
++++|_ -> expr
++++;;
++++
++++
++++
++++let actually_do_the_fucking_boxing expr varParam =
++++  let expr_with_set_tag = (add_set_tag_to_body_of_lambda expr varParam) in
++++  match expr_with_set_tag with
++++  |LambdaSimple'(params, body) -> LambdaSimple'(params, replace_get_set body varParam)
++++  |_ -> raise X_syntax_error
++++  ;;
++++
++++(* the var list is (bool, the varParam) *)
++++let rec actually_do_the_fucking_boxing_2 expr varList = match expr, varList with
++++|_, [] -> expr
++++|LambdaSimple'(params,body), _ -> if(fst (List.hd varList))
++++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda (LambdaSimple'(params,(replace_get_set body (snd (List.hd varList))))) (snd(List.hd varList))) (List.tl varList)
++++      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
++++|LambdaOpt'(params, opt,body), _ -> if(fst (List.hd varList))
++++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda  (LambdaOpt'(params, opt, (replace_get_set body (snd (List.hd varList)))))(snd(List.hd varList))) (List.tl varList)
++++      else actually_do_the_fucking_boxing_2 expr (List.tl varList);;
++++
++++let  is_boxing_needed expr varParam =
++++  match expr with
++++  |LambdaSimple'(params,body)->
++++                                let goku = make_box_id_counter() in
++++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++++                                let goku = make_box_id_counter() in
++++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++++                                is_boxing_needed_2 get_list set_list
++++  |LambdaOpt'(params, opt, body)->
++++                                let goku = make_box_id_counter() in
++++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++++                                let goku = make_box_id_counter() in
++++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++++                                is_boxing_needed_2 get_list set_list
++++  |_ -> raise X_syntax_error
++++  ;;
++++
++++ (* let goku = make_box_id_counter() in
++++let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++++let goku = make_box_id_counter() in
++++let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++++if (is_boxing_needed_2 get_list set_list)
++++then (actually_do_the_fucking_boxing expr (varParam))
++++else expr *)
++++
++++
++++let gets_lambda_returns_it_boxed expr = match expr with
++++|LambdaSimple'(params, body) -> let act_params = make_lambda_params_vars params 0 in
++++                               let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
++++                               actually_do_the_fucking_boxing_2 expr box_list
++++|LambdaOpt'(params, opt, body) ->  let act_params = make_lambda_params_vars (params@[opt]) 0 in
++++                                   let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
++++                                   actually_do_the_fucking_boxing_2 expr box_list
++++|_ -> expr
++++;;
++++
++++let make_lambda_pair expr = match expr with
++++|LambdaSimple'(params, body) -> (params, body)
++++|_ ->raise X_syntax_error
++++
++++let make_lambda_triple expr = match expr with
++++|LambdaOpt'(params, opt, body) -> (params, opt, body)
++++|_ -> raise X_syntax_error
++++
++++let rec boxer_man expr = match expr with
++++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, boxer_man box_set_val)
++++|If'(test, tCase, fCase) -> If'((boxer_man test), (boxer_man tCase ), (boxer_man fCase ))
++++|Seq'(seq_list) -> Seq'((List.map (fun t -> boxer_man t ) seq_list))
++++|Set'(set_var, set_val) -> Set'(set_var, boxer_man set_val)
++++|Def'(def_var,def_val) -> Def'(def_var,boxer_man def_val)
++++|Or'(or_list) -> Or'((List.map (fun t -> boxer_man t ) or_list))
++++|LambdaSimple'(params, body) -> let (n_params, n_body) =( make_lambda_pair( gets_lambda_returns_it_boxed expr)) in
++++                                  LambdaSimple'(n_params, boxer_man n_body)
++++|LambdaOpt'(params, opt, body) -> let (n_params, n_opt, n_body ) = (make_lambda_triple (gets_lambda_returns_it_boxed expr)) in
++++                                  LambdaOpt'(n_params, n_opt, boxer_man n_body)
++++|Applic'(proc, args) -> Applic'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
++++|ApplicTP'(proc, args) -> ApplicTP'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
++++|_ -> expr
++++
++++let box_z e varParam= gets_lambda_returns_it_boxed e;;
++++
++++
++++let box_set e = boxer_man e;;
++++
++++  let run_semantics expr =
+++   box_set
+++     (annotate_tail_calls
+++        (annotate_lexical_addresses expr));;
+++-
++++
+++ end;; (* struct Semantics *)
+++
+++
+++diff --git a/tag-parser.ml b/tag-parser.ml
+++index 138249e..68edecd 100644
+++--- a/tag-parser.ml
++++++ b/tag-parser.ml
+++@@ -57,9 +57,227 @@ let reserved_word_list =
+++    "unquote-splicing"];;
+++
+++ (* work on the tag parser starts here *)
++++let rec tag_parse_expression sexpr  = match sexpr with
++++| Pair(Symbol("set!"), Pair(var, Pair(expr, Nil))) -> Set(tag_parse_expression var, tag_parse_expression expr)
++++| Pair(Symbol("pset!"), pset_sexpr) -> pset_macro_expansion pset_sexpr (* pset macro expansion*)
++++| Pair(Symbol("let"), let_sexpr) -> let_tag_parser let_sexpr
++++| Pair(Symbol("let*"), let_star_sexpr) -> let_star_tag_parser let_star_sexpr
++++| Pair(Symbol("letrec"), letrec_sexpr) -> letrec_tag_parser letrec_sexpr
++++| Pair(Symbol("lambda"), lambda_sexpr) -> lambda_tag_parser lambda_sexpr
++++| Pair(Symbol("cond"), Pair(rib,ribs)) ->cond_macro_expansion (Pair(rib,ribs)) (** cond_macro_expansion*)
++++| Pair(Symbol("if"), if_sexpr)-> if_tag_parser if_sexpr
++++| Pair(Symbol("define"), define_sexpr) -> define_tag_parser define_sexpr (*define_macro_expansion(**only MIT Style define has a macro-expansion*)*)
++++| Pair(Symbol("begin"), begin_sexpr) -> begin_tag_parser begin_sexpr
++++| Pair(Symbol("or"), or_sexpr) -> or_tag_parser or_sexpr
++++| Pair(Symbol("and"), Pair( opt1, opts)) -> and_macro_expansion (Pair(opt1, opts))(*and_macro_expansion opt1 opts *)
++++| Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
++++| Pair(Symbol("quasiquote"), sexpr) -> quasiquote_macro_expansion (sexpr) (* quasiquote macro-expansion*)
++++(* | Pair(Symbol(var),Nil) -> Var(var) *)
++++| Pair(var, Pair(expr,exprl)) -> Applic(tag_parse_expression var, (tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl)))
++++| Number(x) -> Const(Sexpr(Number(x)))
++++| Char(x) -> Const(Sexpr(Char(x)))
++++| Bool(x) -> Const(Sexpr(Bool(x)))
++++| String(x) -> Const(Sexpr(String(x)))
++++| Symbol(x) -> Var(x)
++++| Pair(x, Nil) -> Applic((tag_parse_expression x),[])
+++
+++-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
++++and cond_macro_expansion_sexpr cond_sexpr = match cond_sexpr with
++++|Nil ->  Nil
++++|Pair(Pair(Symbol("else"), body),rest) ->  Pair(Symbol("begin"), body)
++++|Pair(Pair(expr, Pair(Symbol("=>"),exprf)), rest) ->
++++(Pair (Symbol "let",
++++Pair
++++ (Pair (Pair (Symbol "value", Pair (expr, Nil)),
++++   Pair
++++    (Pair (Symbol "f",
++++      Pair (Pair (Symbol "lambda", Pair (Nil, Pair (exprf, Nil))),
++++       Nil)),
++++    Pair
++++     (Pair (Symbol "rest",
++++       Pair
++++        (Pair (Symbol "lambda", Pair (Nil, Pair (Symbol "cond-ribs", Nil))),
++++        Nil)),
++++     Nil))),
++++ Pair
++++  (Pair (Symbol "if",
++++    Pair (Symbol "value",
++++     Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
++++      Pair (Pair (Symbol "rest", Nil), Nil)))),
++++  Nil))))
++++  |Pair(Pair(test_case, ribs), rest) -> let  a = (Printf.printf "papparapa   ") in
++++  Pair(Symbol("if"), Pair(test_case, Pair(Pair(Symbol("begin"), ribs), Pair(cond_macro_expansion_sexpr (rest), Nil))))   (* (ג¨exprג© ג¨expr1ג© ֲ· ֲ· ֲ· ג¨exprmג©) *)
+++
++++
++++
++++
++++and cond_macro_expansion cond_sexpra = tag_parse_expression (cond_macro_expansion_sexpr cond_sexpra)
++++
++++
++++(* (ג¨exprג© => ג¨exprfג©) *)
++++
++++
++++(* (let ((value Jג¨expr ג©K)
++++        (f (lambda () Jג¨exprfג©K))
++++(rest (lambda () Jג¨continue with cond-ribsג©K)))
++++(if value
++++    ((f) value)
++++    (rest))) *)
++++and pset_macro_expansion pset_sexpr = tag_parse_expression (pset_macro_expansion_sexpr pset_sexpr)
++++
++++and pset_macro_expansion_sexpr pset_sexpr = match pset_sexpr with
++++| Pair(Pair(var, Pair(value, Nil)), Nil) ->  (Pair(Symbol("set!"), Pair(var, Pair(value, Nil))))
++++| Pair(Pair(Symbol(var), Pair(value, Nil)), ribs) ->  (Pair(Symbol( "let"), Pair(Pair(Pair(Symbol( "_"^var), Pair(value , Nil)), Nil), Pair(Pair(Symbol( "lambda"), Pair(Nil, Pair(Pair(Symbol( "pset!"), ribs), Nil))), Pair(Pair(Symbol( "set!"), Pair(Symbol(var), Pair(Symbol( "_"^var), Nil))), Nil)))))
++++(* (Pair(Symbol("let"), Pair(Pair(Pair(Symbol("_v1"), Pair(value, Nil)), Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(Symbol("pset!"), Pair(ribs, Nil)), Nil))), Nil)), Nil)), Pair(Pair(Symbol("rest"), Nil), Pair(Pair(Symbol("set!"), Pair(var, Pair(Symbol("_v1"), Nil))), Nil))))) *)
++++(* let  a = (Printf.printf "arrived here") in  *)
++++
++++(* and heart_of_quasiquote q_sexpr = match q_sexpr with
++++| *)
++++
++++and quasiquote_macro_expansion q_sexpr = match q_sexpr with
++++| Pair (Pair (Pair (Symbol "unquote", Pair (sexpr, Nil)), Nil), Nil) -> Applic (Var "cons", [tag_parse_expression( sexpr); Const (Sexpr Nil)])
++++| Pair (Pair (Pair (Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil), Nil) -> Const(Sexpr(Pair(Symbol("quote"), q_sexpr)))
++++(* | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil) -> raise X_syntax_error *)
++++| Nil -> Const(Sexpr(Pair(Symbol("quote"), Nil)))
++++| Pair (Pair (Symbol(s1), Nil), Nil)  -> Const(Sexpr(Pair(Symbol("quote"), Symbol(s1))))
++++(* | Pair(Pair(Pair(Symbol("unquote-splicing"), sexa)), B) ->  *)
++++
++++and and_macro_expansion and_sexpr = match and_sexpr with
++++| Nil -> Const(Sexpr(Bool(true)))
++++| Pair(op, Nil)-> tag_parse_expression op
++++| Pair(op1, opts) -> If(tag_parse_expression op1, and_macro_expansion opts, Const(Sexpr(Bool(false))))
++++
++++and or_tag_parser or_sexpr = match or_sexpr with
++++| Nil -> Or([])
++++| Pair(expr, Nil) -> tag_parse_expression expr
++++| Pair(expr, exprl) -> Or(((tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl))))
++++
++++and rib_varu_maker rimbs = match rimbs with
++++|Nil -> Nil
++++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(varu, Nil)
++++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(varu, rib_varu_maker (rimbs2))
++++
++++and rib_valu_maker rimbs = match rimbs with
++++|Nil -> Nil
++++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(valu, Nil)
++++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(valu, rib_valu_maker rimbs2)
+++
++++and let_tag_parser let_sexpr = match let_sexpr with
++++| Pair(Nil, body) ->  tag_parse_expression (Pair(Pair(Symbol("lambda"),Pair(Nil, body)), Nil))
++++| Pair(Pair(rib, ribs), body) ->  tag_parse_expression( Pair(Pair(Symbol("lambda"),Pair(rib_varu_maker (Pair(rib, ribs)), body )),rib_valu_maker (Pair(rib,ribs))))
++++
++++and let_star_tag_parser_sexpr let_star_sexpr = match let_star_sexpr with
++++| Pair(Nil, body) -> (Pair (Symbol("let"), let_star_sexpr))
++++| Pair(Pair(rib, Nil), body)->(Pair (Symbol("let"), let_star_sexpr))
++++| Pair(Pair(rib,ribs), body) ->  (Pair(Symbol("let"), Pair(Pair(rib,Nil), let_star_tag_parser_sexpr ((Pair(ribs, body)))))) (* let* macro-expansion*)
++++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
++++
++++and let_star_tag_parser let_star_sexpr = match let_star_sexpr with
++++| Pair(Nil, body) -> tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
++++| Pair(Pair(rib, Nil), body)->tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
++++| Pair(Pair(rib,ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib,Nil), Pair(Symbol("let*"), Pair(ribs, body))))) (* let* macro-expansion*)
++++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
++++
++++and create_set_sexprs ribs body= match ribs with
++++| Pair(Nil,Nil) -> Nil
++++| Pair(Pair(var,Pair(value,Nil)),Nil) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), body)
++++| Pair(Pair(var,Pair(value,Nil)),rest) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), (create_set_sexprs rest body ))
++++
++++and  letrec_tag_parser letrec_sexpr = match letrec_sexpr with
++++| Pair(Nil, body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Nil, Pair(body, Nil))))
++++| Pair(Pair(rib, ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib, ribs), (create_set_sexprs (Pair(rib,ribs)) body ))))(*letrec_macro_expansion rib ribs body*)
++++
++++and checkArguments args =
++++match args with
++++| Pair(Symbol("vs"), Nil) -> variadic_lambda
++++| Pair(arg, Nil) -> simple_lambda_tag_parser
++++| Pair(arg1, Symbol(opt)) -> (opt_lambda_tag_parser opt )
++++| Pair(arg1,rest) -> checkArguments rest
++++
++++
++++and create_string_arr sList = match sList with
++++| Symbol(vs) -> []
++++| Pair(Symbol(last), Nil) -> [last]
++++| Pair(Symbol(str1), b) -> str1::create_string_arr b
++++| Nil -> []
++++
++++and makeSequence expr_list = Seq(flattenSequence (List.map tag_parse_expression (sexpr_to_list expr_list)))
++++
++++and simple_lambda_tag_parser lambda_sexpr =
++++let  a = (Printf.printf "arrived simple tag") in
++++match lambda_sexpr with
++++| Pair (args, Pair(expr, Nil)) ->  LambdaSimple((create_string_arr args),tag_parse_expression expr)
++++| Pair( args,expr_list) ->  LambdaSimple((create_string_arr args), makeSequence expr_list)(* simple*)
++++
++++and opt_lambda_tag_parser opt lambda_sexpr =
++++let  a = (Printf.printf "arrived opt tag") in
++++match lambda_sexpr with
++++| Pair(args, Pair(expr, Nil)) -> LambdaOpt((create_string_arr args), opt, tag_parse_expression expr)(* opt*)
++++| Pair(args, expr_list) -> LambdaOpt((create_string_arr args), opt, makeSequence expr_list)(* opt*)
++++
++++and variadic_lambda lambda_sexpr =
++++let  a = (Printf.printf "arrived variadic") in
++++match lambda_sexpr with
++++| Pair(Pair(Symbol("vs"),Nil), Pair(expr, Nil)) ->  LambdaOpt([], "vs", tag_parse_expression expr)(* opt*)
++++| Pair(Pair(Symbol("vs"),Nil), expr_list) -> LambdaOpt([], "vs", makeSequence expr_list)(* opt*)
++++
++++and lambda_tag_parser lambda_sexpr = match lambda_sexpr with
++++|Pair(Nil, expr) -> simple_lambda_tag_parser lambda_sexpr
++++|Pair(args, expr) -> (checkArguments args) lambda_sexpr
++++
++++
++++
++++and define_tag_parser define_sexpr = match define_sexpr with
++++| Pair (Pair (var, arglist), Pair (exprs, Nil)) -> tag_parse_expression (Pair(Symbol "define", Pair(var, Pair(Pair(Symbol "lambda", Pair(arglist, Pair(exprs, Nil))), Nil))))
++++| Pair(name, Pair(expr, Nil)) -> Def(tag_parse_expression name,  tag_parse_expression expr )
++++(* Pair(Symbol "define", Pair(Pair(Symbol "var", Symbol "arglist"), Pair(Symbol "expr+", Nil))) *)
++++
++++and sexpr_to_list pair_list = match pair_list with
++++| Nil  -> []
++++| Pair(a , b) -> a:: (sexpr_to_list b)
++++
++++and  flattenSequence  expr_list_2 =
++++  List.fold_left (fun acc expr -> match expr with
++++  | Seq(lst) -> acc@lst
++++  (* | Const(void) -> []  *)
++++  | _ -> acc@[expr]) [] expr_list_2
++++and begin_tag_parser begin_sexpr =
++++  match begin_sexpr with
++++| Nil-> Const (Void)
++++| Pair(a, Nil) -> tag_parse_expression a
++++| sexprs -> Seq (flattenSequence (List.map tag_parse_expression ( sexpr_to_list sexprs)))
++++
++++and if_tag_parser if_sexpr = match if_sexpr with
++++| Pair(test, Pair(dit, Pair(dif, Nil)))-> let  a = (Printf.printf "babidi if" ) in
++++  If(tag_parse_expression test, tag_parse_expression dit, tag_parse_expression dif)
++++| Pair(test, Pair(dit,Nil))->
++++  If(tag_parse_expression test, tag_parse_expression dit, Const (Void));;
++++
++++
++++let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;
++++
++++
+++ end;; (* struct Tag_Parser *)
+++
++++(*
++++(define sexpr->ocaml-string
++++(lambda(e)
++++(cond
++++((boolean? e)
++++(if e "Bool true" "Bool false"))
++++((null? e) "Nil")
++++((char? e) (  format "Char '~a'" e))
++++((symbol? e) (  format "Symbol \"~a\"" e))
++++((string? e) (  format "String \"~a\"" e) )
++++((flonum? e) (  format "Number (Float ~a)" e))
++++((integer? e) (  format "Number (Fraction(~a, 1))" e))
++++((ratnum? e)
++++(format "Number (Fraction(~a, ~a))" (numeratore) (denominatore)))
++++((pair? e)
++++(format "Pair(~a, ~a)"
++++(sexpr->ocaml-string (car e))
++++(sexpr->ocaml-string (cdr e))))
++++(else(error 'sexpr->ocaml-string
++++(format "Unsupported type: ~a" e))))))
++++(define print-template
++++(lambda(sexpr)(display(sexpr->ocaml-string sexpr))))
++++(print-template'(let (rib . ribs) body)) *)
+++\ No newline at end of file
++diff --git a/omer folder/fresh_compiler b/omer folder/fresh_compiler
++new file mode 160000
++index 0000000..ea461c3
++--- /dev/null
+++++ b/omer folder/fresh_compiler
++@@ -0,0 +1 @@
+++Subproject commit ea461c365d4c85ac63bf494212989f80683e85ad-dirty
++diff --git a/reader.ml b/reader.ml
++index 32445c2..3b9ba3e 100644
++--- a/reader.ml
+++++ b/reader.ml
++@@ -1,5 +1,5 @@
++-
++ #use "pc.ml";;
+++open PC;;
++
++ exception X_not_yet_implemented;;
++ exception X_this_should_not_happen;;
++@@ -17,18 +17,20 @@ type sexpr =
++   | Symbol of string
++   | Pair of sexpr * sexpr;;
++
++-let rec sexpr_eq s1 s2 =
++-  match s1, s2 with
++-  | Bool(b1), Bool(b2) -> b1 = b2
++-  | Nil, Nil -> true
++-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
++-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
++-  | Char(c1), Char(c2) -> c1 = c2
++-  | String(s1), String(s2) -> s1 = s2
++-  | Symbol(s1), Symbol(s2) -> s1 = s2
++-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
++-  | _ -> false;;
++
+++  let rec sexpr_eq s1 s2 =
+++    match s1, s2 with
+++    | Bool(b1), Bool(b2) -> b1 = b2
+++    | Nil, Nil -> true
+++    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+++    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+++    | Char(c1), Char(c2) -> c1 = c2
+++    | String(s1), String(s2) -> s1 = s2
+++    | Symbol(s1), Symbol(s2) -> s1 = s2
+++    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+++    | _ -> false;;
+++
+++
++ module Reader: sig
++   val read_sexprs : string -> sexpr list
++ end
++@@ -40,7 +42,274 @@ let normalize_scheme_symbol str =
++ 	s) then str
++   else Printf.sprintf "|%s|" str;;
++
+++let packOnFirst nt f s =
+++  let (e, s) = (nt s) in
+++  (f e);;
++
++-let read_sexprs string = raise X_not_yet_implemented;;
+++let packOnSecond nt f s =
+++  let (e, s) = (nt s) in
+++  (f s);;
++
+++let notChar = make_char (fun ch1 ch2 -> ch1 != ch2);;
+++
+++
+++
+++let newLineParsaPred = packOnFirst   (caten (char '\\') (char 'n')) (fun _ ->  false);;
+++
+++(* let newLineParsa = pack (caten (char '\\') (char 'n')) (fun (e,s) -> s);; *)
+++let newLineParsa = char '\n';;
+++
+++let nt_whitespaces = star (char ' ');;
+++
+++
+++let make_paired nt_left nt_right nt =
+++let nt = caten nt_left nt in
+++let nt = pack nt (function (_, e) -> e) in
+++let nt = caten nt nt_right in
+++let nt = pack nt (function (e, _) -> e) in
+++nt;;
+++
+++let make_spaced nt =
+++  make_paired nt_whitespaces nt_whitespaces nt;;
+++
+++let semicolonParser = char ';';;
+++
+++
+++(* let notNewLineParser = packOnFirst( (const (newLineParsaPred))) (fun ch -> ch);; *)
+++let notNewLineParser  = const(fun p -> p!= '\n');;
+++(* let notNewLineParser = (const(fun p -> p!= "\\n")) ;; *)
+++(* let notNewLineParser = let nt = word "\\n" in
+++                       let nt = ;; *)
+++(* let notNewLineParser  = try word "\\n"
+++                        with X_no_match  ->  nt_any
+++                          ;; *)
+++
+++
+++
+++
+++(* let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');; *)
+++let notNewLineParser2 = (star (notNewLineParser)) ;;
+++(* this check as long as there is no new line *)
+++
+++let make_line_comment_parser_paired  =
+++  let nt = caten semicolonParser notNewLineParser2 in
+++  let nt = pack nt (function (_, e) -> e) in
+++  let nt = caten nt newLineParsa in
+++  let nt = packOnSecond nt (function e ->  (e,e)) in
+++  nt;;
+++
+++
+++(* let lineCommentParser = make_spaced ( pack (caten   semicolonParser (caten (star notNewLineParser)  newlineParser)) (fun _ -> [' '])  );; *)
+++
+++
+++(* Boolean, dot, CharPrefix, Digit,Natural,  Fraction, Float*)
+++let backSlashParser = char '\\';;
+++let hashParser = char '#';;
+++
+++(*
+++⟨Boolean⟩::= #f | #t
+++*)
+++let booleanParser = make_spaced( PC.pack (PC.caten hashParser (PC.disj (PC.char_ci 't') (PC.char_ci 'f') ))
+++        (fun (_, ch) -> if ch = 't' || ch = 'T' then Bool true else Bool false));;
+++
+++(* digit => Natural => Integer => Fraction => Float => *)
+++let digitParser  = range '0' '9';;  (* Parses all numbers between 0-9 <digit> *)
+++let digitSeqParser = (plus digitParser);;(* <digit>+ *)
+++let naturalParser = pack digitSeqParser (fun str ->  (int_of_string(list_to_string str)));;(*Turns a list of chars of numbers into a natural number*)
+++
+++
+++let maybeMinusPlusParser = (* Parses  (+|-)? and returns -1 if the char that is parsed is - and 1 otherwise *)
+++  let plusParser = pack (char '+') (fun _ -> 1) in  (*returns 1*)
+++  let minusParser =  pack (char '-') (fun _ -> -1) in (*returns -1*)
+++  pack (maybe(disj plusParser minusParser)) (fun opt -> match opt with Some(e) -> e | None -> 1);;
+++
+++let integerParser = pack (caten maybeMinusPlusParser naturalParser) (fun (e,s) -> e*s);; (* <Integer> catens the (+|-)? with natural number and multiplies the outputs  *)
+++
+++let rec gcd a b = (*returns greates commod divisor of a and b *)
+++  if b = 0 then a else gcd b (a mod b);;
+++
+++let fractionParser = (*<Fraction> = <Integer> / <Natural> *)
+++  let fractionPar = pack( caten( caten integerParser (char '/')) naturalParser) (fun ((i, d), n) ->
+++  let div = gcd i n in (*gets gcd if the numerator and denominator*)
+++  Fraction (i/div, n/div)) in  (*makes the smallest number of an integer and natural number*)
+++  let integerToFraction = pack integerParser (fun num -> Fraction (num, 1)) in (*an Integer is parsed into a Fraction with 1 as the denominator*)
+++    disj fractionPar integerToFraction ;;
+++
+++let mantissaParser = pack digitSeqParser (fun lst -> (* parses a list of digit chars to a mantissa*)
+++  let with0 = String.concat "" ["0."; (list_to_string lst)] in (*before the char list is turned into a float, the list ['0';'.'] is concatenated before it so the number will stay as a mantissa *)
+++  float_of_string with0);;
+++
+++let floatParser string = pack( caten( caten integerParser (char '.')) mantissaParser) (fun ((i, d), m) -> (*<Float> = ⟨Integer⟩.⟨Natural⟩*)
+++   if i > 0 then  (float_of_int i)+.m (*connect the integer with a mantissa *)
+++   else if i==0 && List.nth string 0 != '-'  then (float_of_int i) +. m
+++   else (float_of_int i) -. m) string;;
+++
+++let scientificNotationParser = (* The scientic notation is of the form of (integer | float) e|E integer*)
+++    let integerAndFloat = disj  floatParser (pack integerParser (fun num ->  float_of_int num ))  in  (** returns a Float, if the num is int it makes a Float of it*)
+++    let e = pack (char_ci 'e') (fun _ -> Nil) in
+++    pack( caten( caten integerAndFloat e) integerParser) (fun ((num, d), pow) -> num *. 10.0 ** (float_of_int pow));;
+++let numberParser = make_spaced( pack (disj (pack (disj scientificNotationParser floatParser) (fun fl -> Float fl) ) fractionParser) (fun num -> Number num ));; (* (scientifNotation | Float | Fraction)*)
+++
+++
+++let charPrefixParser = pack (caten hashParser backSlashParser) (fun _ -> Nil);;
+++
+++let visibleCharParser = pack (const (fun p -> p > ' ')) (fun ch -> Char ch);;
+++
+++let nulParser = pack( word_ci "nul") (fun _ -> Char (char_of_int 0));;
+++let newlineParser = pack( word_ci "newline") (fun _ -> Char (char_of_int 10));;
+++let returnParser = pack( word_ci "return") (fun _ -> Char (char_of_int 13));;
+++let tabParser = pack( word_ci "tab") (fun _ -> Char (char_of_int 9));;
+++let formfeedParser = pack( word_ci "page") (fun _ -> Char (char_of_int 12));;
+++let spaceParser = pack( word_ci "space") (fun _ -> Char (char_of_int 32));;
+++
+++
+++let namedCharParser = disj_list  [nulParser; newlineParser; returnParser; tabParser; formfeedParser; spaceParser];;
+++
+++let charParser = make_spaced( pack (caten charPrefixParser (disj namedCharParser visibleCharParser)) (fun (_, ch) -> ch));;
+++
+++(* need to add named char*)
+++
+++
+++let dotParser string= pack (guard (char '.') (fun _ -> List.length(string) > 1))(fun _ -> ".") string;; (**doest parse if . is alone *)
+++let symbolCharNoDotParser = (*Parses all the chars that are not a dot and turns them into a string*)
+++    let letter_ciParser = pack(range_ci 'a' 'z') (fun ch -> lowercase_ascii ch) in
+++    let punctuationParser = one_of "!$^*-_=:+<>/?" in
+++    pack (disj_list [digitParser ; letter_ciParser ; punctuationParser]) (fun sym -> String.make 1 sym);;
+++let symbolCharParser = disj symbolCharNoDotParser dotParser;; (*(<dot> | <symbolCharNoDot>)*)
+++let symbolParser =
+++    let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in (*<symbolChar><symbolChar>+, connects the strings of the symbols *)
+++    let symbolParserWithoutNumber = (disj withDotParser symbolCharNoDotParser) in
+++    pack symbolParserWithoutNumber (fun str ->
+++    try (let (e,s) = numberParser (string_to_list str) in
+++    if s == [] then e else Symbol(str))
+++    with X_no_match -> Symbol(str));; (*Constructs a symbol with a string*)
+++
+++ (* let symbolParserWithoutNumber =
+++  let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in
+++  disj withDotParser symbolCharNoDotParser;;
+++let symbolParser string=
+++  let parsedBySymbol = symbolParserWithoutNumber
+++  try (let number = numberParser )  *)
+++
+++
+++let gershaimParser = PC.char '"';;
+++
+++let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');;
+++
+++let returnStringMetaCharParser = pack (char_ci 'r') (fun _ -> char_of_int 13)
+++let newlineStringMetaCharParser = pack (char_ci 'n') (fun _ -> char_of_int 10)
+++let tabStringMetaCharParser = pack (char_ci 't') (fun _ -> char_of_int 9)
+++let pageStringMetaCharParser = pack (char_ci 'f') (fun _ -> char_of_int 12)
+++let backslashStringMetaCharParser = pack (char_ci '\\') (fun _ -> char_of_int 92)
+++let gershaimStringMetaCharParser = pack (char_ci '"') (fun _ -> char_of_int 34)
+++
+++let stringMetaCharParser = pack (caten backSlashParser (disj_list [returnStringMetaCharParser;
+++                                      newlineStringMetaCharParser;
+++                                      tabStringMetaCharParser;
+++                                      pageStringMetaCharParser;
+++                                      backslashStringMetaCharParser;
+++                                      gershaimStringMetaCharParser]) ) (fun (_, ch) -> ch);;
+++
+++let stringCharParser = disj stringMetaCharParser stringLiteralCharParser;;
+++
+++let stringParser = make_spaced( pack (caten (caten gershaimParser (star stringCharParser)) gershaimParser)
+++                      (fun ((_, lst), _) -> String (list_to_string lst)) );;
+++
+++(* let numberParser = pack (disj floatParser fractionParser) (fun num -> Number num );; *)
+++(* bad number parser *)
+++
+++let openParenthasisParser = char '(';;
+++let closedParenthasisParser = char ')';;
+++
+++
+++(* let emptyListParser = make_spaced( pack (make_paired openParenthasisParser closedParenthasisParser (caten (disj nt_whitespaces make_line_comment_parser_paired) nt_whitespaces)) (fun _ -> Nil) ) *)
+++
+++
+++
+++(* let emptyListParser = pack(make_line_comment_parser_paired) (fun _-> Nil) ;;  *)
+++
+++(* let singleQuoteParser = char ''';;
+++let quoteParser =  make_spaced( pack (  caten singleQuoteParser read_   ) (fun  )  );;
+++
+++let quotingParser = NUL;; *)
+++
+++let veryGoodDotParser = pack(char '.') (fun ch -> Char ch) ;;
+++
+++
+++let rec starush nt s =
+++  try let (e, s) = (nt s) in
+++      let (es, s) = (starush nt s) in
+++      (Pair(e,es), s)
+++  with X_no_match -> (Nil, s);;
+++
+++
+++let rec starush2 nt s =
+++  try let (e, s) = (nt s) in
+++      let (es, s) = (starush nt s) in
+++      (Pair(e,es), s)
+++  with X_no_match ->
+++                     try let ((e,e2),s) = (caten veryGoodDotParser nt) s in
+++                     (e2,s)
+++                     with X_no_match -> (Nil, s);;
+++
+++let plusush nt =
+++  pack (caten nt (starush nt))
+++        (fun (e, es) -> (Pair(e,es)));;
+++
+++
+++let rec read_sexpr paparapa=
+++  let rec improperSecondArgumentParser = pack ( make_spaced( (caten veryGoodDotParser (caten nt_whitespaces read_sexpr )  ))) (fun (_,(_,e)) ->  e)
+++  and
+++
+++  starushu nt s =
+++    try let (e, s) = (nt s) in
+++        let (es, s) = (disj (improperSecondArgumentParser) (starushu nt ) ) s in
+++        (Pair(e,es), s)
+++    with X_no_match -> (Nil, s)
+++  in
+++
+++   let rec listParser = pack( (caten openParenthasisParser (caten  (disj (starushu (make_spaced read_sexpr)) (starush (make_spaced read_sexpr))) closedParenthasisParser)  )) (fun (_,(e,_)) -> e)
+++   (* let listParser = pack( make_spaced( caten openParenthasisParser (caten read_sexpr (caten (disj_list [improperSecondArgumentParser; noSecondItemInPairParser; secontItemInPairParser] ) closedParenthasisParser ))) ) (fun (_,(ent1,( ent2, _))) -> Pair(ent1, ent2)) *)
+++  and
+++
+++   lineCommentParser = pack (make_line_comment_parser_paired) (fun _ -> Nil)
+++  and sexpCommentParser = pack (caten (char '#')  (caten (char ';') read_sexpr )) (fun _ -> Nil)
+++  in let commentParser = (pack (make_spaced(disj sexpCommentParser lineCommentParser ))) (fun _ -> Nil)
+++  in let emptyListParser = pack((caten openParenthasisParser (caten (star commentParser) closedParenthasisParser))) (fun _ -> Nil)
+++  in let quoteParser = pack( (caten (make_spaced(char (char_of_int 39))) read_sexpr)) (fun (e,s) -> Pair(Symbol("quote"),Pair(s,Nil)))
+++  in let qQuoteParser =  pack( (caten (make_spaced(char '`')) read_sexpr)) (fun (e,s) -> Pair(Symbol("quasiquote"),Pair(s,Nil)))
+++  in let unQuoteParser =  pack( (caten (make_spaced(char ',')) read_sexpr)) (fun (e,s) -> Pair(Symbol("unquote"),Pair(s,Nil)))
+++  in let unQuoteSplicingParser =  pack( caten (make_spaced(caten (char ',') (char '@'))) read_sexpr) (fun (e,s) -> Pair(Symbol("unquote-splicing"),Pair(s,Nil)))
+++
+++  in pack (caten (star commentParser) (caten (disj_list [quoteParser; qQuoteParser; unQuoteParser; unQuoteSplicingParser; emptyListParser;listParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star commentParser))) (fun (_,(s,_)) -> s)
+++  paparapa
+++  ;;
+++
+++
+++(* let rec read_sexpr =
+++  pack (caten (star sexpCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star sexpCommentParser))) (fun (_,(s,_)) -> s)
+++  and lineCommentParser = (pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil) )
+++  and sexpCommentParser  = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr ))) (fun _ -> Nil)
+++  ;; *)
+++
+++(* let lineCommentParser = pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil);; *)
+++
+++(* let sexpCommentParser = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr)) (fun _ -> Nil);; *)
+++
+++(* let rec read_sexpr =   pack (caten (star lineCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star lineCommentParser))) (fun (_,(s,_)) -> s)  ;; *)
+++(* (fun c -> match c with
+++| Nil -> []
+++| _ -> c) ;; *)
+++
+++(* let read_sexpr =
+++
+++  try pack( caten commentParser (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])) (fun (e,s) -> s)
+++  with X_no_match ->  try pack( caten  (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])commentParser ) (fun (e,s) -> e)
+++    with X_no_match -> disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser];; *)
+++(* let read_sexpr str = disj_list [booleanParser ; charParser ; numberParser ; stringParser ; symbolParser ] *)
+++
+++let read_sexprs string = let (e,s) = (caten (star read_sexpr) nt_end_of_input ) (string_to_list string) in
+++            let (e2, s2)= e in
+++             e2;;
++ end;; (* struct Reader *)
+++
++diff --git a/readme.txt b/readme.txt
++index e69de29..710c26c 100644
++--- a/readme.txt
+++++ b/readme.txt
++@@ -0,0 +1,10 @@
+++Itay Almoznino 318911187
+++Tommer Federman 212198378
+++
+++We assert that the work we submitted is 100% our own. We have not received any
+++part from any other student in the class, nor have we give parts of it for use to others.
+++Nor have we used code from other sources: Courses taught previously at this university,
+++courses taught at other universities, various bits of code found on the internet, etc.
+++We realize that should our code be found to contain code from other sources, that a
+++formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+++action.
++diff --git a/semantic-analyser.ml b/semantic-analyser.ml
++index 8e684f0..370db40 100644
++--- a/semantic-analyser.ml
+++++ b/semantic-analyser.ml
++@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
++   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
++   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
++   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
++-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
++-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
++-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
++-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
++-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
++-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
++-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
++-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
++-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
++   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
++                                             (expr'_eq th1 th2) &&
++                                               (expr'_eq el1 el2)
++@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
++   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
++ 	 (expr'_eq e1 e2) &&
++ 	   (List.for_all2 expr'_eq args1 args2)
++-  | _ -> false;;
++-
+++  | _ -> false;;
+++
+++
++ exception X_syntax_error;;
++
++ module type SEMANTICS = sig
++@@ -65,21 +57,397 @@ module type SEMANTICS = sig
++   val annotate_lexical_addresses : expr -> expr'
++   val annotate_tail_calls : expr' -> expr'
++   val box_set : expr' -> expr'
++-end;;
+++  end;;
++
++ module Semantics : SEMANTICS = struct
+++(*How the function works- for each lambda of depth n, i create n counters that count the minor number of vars for each bound var,
+++for that n counters are needed, except of that, i keep all the params of the lambdas in a 2d-list*)
+++let rec parse_expr_to_expr' expr env_param_list  =
+++  let callParse expr = parse_expr_to_expr' expr env_param_list in
+++  let parseVar str = parse_to_var str env_param_list in
+++  match expr with
+++| Const(sexpr) -> Const'(sexpr)
+++| Var(str) ->   Var'(parseVar str)
+++| If(e1,e2,e3) ->  If'(callParse e1 ,callParse e2,callParse e3 )
+++| Seq(exprl) -> Seq'(List.map callParse exprl)
+++| Set(Var(str),expr2) ->  Set'(parseVar str ,callParse expr2 )
+++| Def(Var(str), expr2) ->  Def'(parseVar str, callParse expr2)
+++| Or(exprl) -> Or'(List.map callParse exprl)
+++| LambdaSimple(strl, expr) -> LambdaSimple'(strl, parse_expr_to_expr' expr ((strl:: env_param_list)) )
+++| LambdaOpt(strl, opt, expr) -> LambdaOpt'(strl, opt, parse_expr_to_expr' expr ((strl@[opt])::env_param_list) )
+++| Applic(expr, exprl) -> Applic'(callParse expr,List.map callParse exprl)
+++(* test - LambdaSimple (["x"], Applic (Var "x",[LambdaSimple (["y"],Applic (Var "x",[Var "y"; LambdaSimple (["z"], Applic (Var "x", [Var "y"; Var "z"]))]))])) *)
+++and get_index_of_arr str env_params ind =
+++  let nth = List.nth env_params ind in
+++  if ind > List.length env_params then -1
+++  else if List.exists (fun x -> x = str) nth then ind
+++  else get_index_of_arr str env_params (ind+1)
++
++-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+++(* and make_counter() =
+++  let x = ref(-1) in
+++  fun() -> x := !x + 1; !x  *)
++
++-let annotate_tail_calls e = raise X_not_yet_implemented;;
+++and printList lst = match lst with
+++| hd :: tl ->  "["^(stringList hd)^"];"^(printList tl)
+++| [] -> ""
++
++-let box_set e = raise X_not_yet_implemented;;
+++and stringList strl = match strl with
+++| hd ::tl -> (hd)^";"^(stringList tl)
+++| [] -> ""
++
++-let run_semantics expr =
+++and get_index_of_var_in_env var var_arr ind=
+++  let nth = (List.nth (var_arr) ind) in
+++  if (nth = var) then ind
+++  else get_index_of_var_in_env var var_arr (ind+1)
+++
+++and parse_to_var str env_params =
+++  let major_count =
+++    if (not (List.exists (List.exists (fun x -> str = x)) env_params)) then -1 (* no lambda params has the str and so it is free *)
+++    else get_index_of_arr str env_params 0
+++    in
+++    (* (Printf.printf "params [%s]" (printList env_params)) ; *)
+++  match major_count with
+++  | -1 -> VarFree(str)
+++  | 0 -> VarParam(str, get_index_of_var_in_env str (List.nth env_params major_count) 0)
+++  | n -> VarBound(str, major_count-1, get_index_of_var_in_env str (List.nth env_params major_count) 0);;
+++
+++let annotate_lexical_addresses e = parse_expr_to_expr' e [];;
+++
+++
+++let rec annotate_tp e tp = match e with (* https://www.cs.bgu.ac.il/~comp151/wiki.files/ps8.pdf*)
+++| Const'(cons) -> e
+++| Var'(v) -> e
+++| If'(test, dit, dif) -> If'(annotate_tp test false, annotate_tp dit tp, annotate_tp dif tp)
+++| Seq'(expl) -> Seq'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
+++| Set'(v, exp) -> Set'(v,annotate_tp exp false)
+++| Def'(v, exp) -> Def'(v, annotate_tp exp  false)
+++| Or'(expl) -> Or'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
+++| LambdaSimple'(strl, exp) -> LambdaSimple'(strl,  annotate_tp exp true)
+++| LambdaOpt'(strl, opt, exp) -> LambdaOpt'(strl, opt, annotate_tp exp true)
+++| Applic'(exp, expl) -> if tp then ApplicTP'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
+++                        else Applic'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl);;
+++
+++let annotate_tail_calls e = annotate_tp e false;;
+++
+++(* type var =
+++  | VarFree of string
+++  | VarParam of string * int
+++  | VarBound of string * int * int;; *)
+++
+++
+++
+++
+++let name_of_var v = match v with
+++|VarFree(s) -> s
+++|VarParam(s, _) -> s
+++|VarBound(s,_,_) -> s
+++|_ -> raise X_syntax_error
+++;;
+++
+++let get_number_based_on_variable var = match var with
+++|VarParam(s, minor) -> -1
+++|VarBound(s, major, minor) -> major
+++|_ -> raise X_syntax_error
+++;;
+++
+++(* receives an expression expr and var varParam, and boxes all occurences of the var,
+++ this function will be called at step 2 of boxing in closures*)
+++
+++let check_if_var_is_in_param_list params varName = match params with
+++|[] -> false
+++|_ -> List.exists (fun t -> t = varName) params;;
+++
+++let is_read_occure expr varParam = match expr with
+++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+++                  then true
+++                  else false
+++|_ -> false
+++;;
+++
+++let rec has_read_occure expr varParam = match expr with
+++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+++                  then true
+++                  else false
+++|Box'(box_var) -> has_read_occure (Var'(box_var)) varParam
+++|BoxSet'(box_set_var, box_set_val) -> has_read_occure box_set_val varParam
+++|If'(test, tCase, fCase) -> has_read_occure_in_seq ([test]@[tCase]@[fCase]) varParam
+++|Seq'(seq_list) -> has_read_occure_in_seq seq_list varParam
+++|Set'(set_var, set_val) -> has_read_occure set_val varParam
+++|Def'(def_var,def_val) -> has_read_occure def_val varParam
+++|Or'(or_list) -> has_read_occure_in_seq or_list varParam
+++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+++                                then false
+++                                else has_read_occure body varParam (* lookoo *)
+++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+++                                  then false
+++                                  else has_read_occure body varParam (* lookoo *)
+++|Applic'(proc, args) -> let proc_and_args = proc::args in
+++                              has_read_occure_in_seq proc_and_args varParam
+++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+++                              has_read_occure_in_seq proc_and_args varParam
+++|_ -> false
+++
+++and  has_read_occure_in_seq expr_list varParam = match expr_list with
+++|[] -> false
+++|_ -> List.exists (fun t -> has_read_occure t varParam) expr_list;;
+++
+++let is_write_occure expr varParam = match expr with
+++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+++                           then true
+++                           else false
+++|_ -> false
+++;;
+++(* returns true if the expression is a write occure of the var *)
+++
+++let rec has_write_occure expr varParam = match expr with
+++|BoxSet'(box_set_var, box_set_val) -> has_write_occure box_set_val varParam
+++|If'(test, tCase, fCase) -> has_write_occure_in_seq ([test]@[tCase]@[fCase]) varParam
+++|Seq'(seq_list) -> has_write_occure_in_seq seq_list varParam
+++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+++                           then true
+++                           else false
+++|Def'(def_var,def_val) -> has_write_occure def_val varParam
+++|Or'(or_list) -> has_write_occure_in_seq or_list varParam
+++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+++                                then false
+++                                else has_write_occure body varParam (* lookoo *)
+++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+++                                  then false
+++                                  else has_write_occure body varParam (* lookoo *)
+++|Applic'(proc, args) -> let proc_and_args = proc::args in
+++                         has_write_occure_in_seq proc_and_args varParam
+++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+++                          has_write_occure_in_seq proc_and_args varParam
+++|_ -> false
+++
+++
+++
+++and  has_write_occure_in_seq expr_list varParam = match expr_list with
+++|[] -> false
+++|_ -> List.exists (fun t -> has_write_occure t varParam) expr_list;;
+++
+++(* this function gets:
+++   # expr- of type expr'
+++   # varParam- of type VarParam
+++   # c_id - closure id which signifies the closure we are in. the importance of this is that
+++   we can check the first condition of boxing with it
+++   # a counter!!!! starts at 0
+++
+++  the function returns a list of all the get occurences for each occurence it gives:
+++   # c_id - closure id
+++   # depth - the depth of the variable read. if it is of type VarParam then -1.
+++   if it is of type bound then the value of the major
+++
+++   *)
+++
+++let rec make_list_of_get_occures expr varParam c_id counter_man = match expr with
+++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+++                  then [c_id,(get_number_based_on_variable var_var)]
+++                  else []
+++|Box'(box_var) ->  make_list_of_get_occures (Var'(box_var)) varParam c_id counter_man
+++|BoxSet'(box_set_var, box_set_val) -> make_list_of_get_occures box_set_val varParam c_id counter_man
+++|If'(test, tCase, fCase) -> (List.concat (has_read_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
+++|Seq'(seq_list) -> (List.concat (has_read_occure_in_seq_complex seq_list varParam c_id counter_man))
+++|Set'(set_var, set_val) -> make_list_of_get_occures set_val varParam c_id counter_man
+++|Def'(def_var,def_val) -> make_list_of_get_occures def_val varParam c_id counter_man
+++|Or'(or_list) -> (List.concat (has_read_occure_in_seq_complex or_list varParam c_id counter_man))
+++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+++                                then []
+++                                else make_list_of_get_occures body varParam (counter_man()) counter_man (* lookoo *)
+++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+++                                  then []
+++                                  else make_list_of_get_occures body varParam (counter_man()) counter_man(* lookoo *)
+++|Applic'(proc, args) -> let proc_and_args = proc::args in
+++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+++|_ -> []
+++
+++(* this function is the read occures in seq but it records what it sees yeahhhh *)
+++and  has_read_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
+++|[] -> []
+++|one::two -> match one with
+++            |LambdaSimple'(params, body) -> (make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++            |LambdaOpt'(params, opt, body) ->(make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++            |_ -> (make_list_of_get_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++;;
+++
+++
+++
+++let rec make_list_of_set_occures expr varParam c_id counter_man = match expr with
+++|BoxSet'(box_set_var, box_set_val) -> make_list_of_set_occures box_set_val varParam c_id counter_man
+++|If'(test, tCase, fCase) -> (List.concat (has_write_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
+++|Seq'(seq_list) -> (List.concat (has_write_occure_in_seq_complex seq_list varParam c_id counter_man))
+++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+++                            then [c_id,(get_number_based_on_variable set_var)]
+++                            else []
+++|Def'(def_var,def_val) -> make_list_of_set_occures def_val varParam c_id counter_man
+++|Or'(or_list) -> (List.concat (has_write_occure_in_seq_complex or_list varParam c_id counter_man))
+++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+++                                then []
+++                                else make_list_of_set_occures body varParam (counter_man()) counter_man (* lookoo *)
+++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+++                                  then []
+++                                  else make_list_of_set_occures body varParam (counter_man()) counter_man(* lookoo *)
+++|Applic'(proc, args) -> let proc_and_args = proc::args in
+++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+++|_ -> []
+++
+++(* this function is the read occures in seq but it records what it sees yeahhhh *)
+++and  has_write_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
+++|[] -> []
+++|one::two -> match one with
+++            |LambdaSimple'(params, body) -> (make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++            |LambdaOpt'(params, opt, body) ->(make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++            |_ -> (make_list_of_set_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+++;;
+++
+++
+++(* this function gets expression and varParam and checks if we need to box the param *)
+++(* let shall_we_box expr varParam =  *)
+++let make_box_id_counter() =
+++  let x = ref(0) in
+++  fun() -> x := !x + 1; !x ;;
+++
+++let rec make_lambda_params_vars params num = match params with
+++|[] -> []
+++|_ ->  (make_lambda_params_vars (List.tl params) (num+1))@[VarParam(List.hd (params), num)]
+++;;
+++(* let papa = make_box_id_counter();; *)
+++
+++(* "one" is the get and "two" is the set *)
+++let does_this_match_require_boxing  cartesian_product =
+++          let (one,two) = cartesian_product in
+++            if((fst one) = (fst two)) (* if read and write are in differnt closures*)
+++            then false
+++            else (if ((snd one) = -1 || (snd two) = -1 || (((snd one) = 0 && (snd two) = 0))) (* if both occurences do not refer to same rib *)
+++            then true
+++            else false)
+++
+++let is_boxing_needed_2 get_list set_list =
+++          let cartesian =   List.concat (List.map (fun e -> List.map (fun e' -> (e,e')) get_list) set_list) in
+++          List.exists (fun x -> does_this_match_require_boxing x) cartesian;;
+++
+++let add_set_tag_to_body_of_lambda expr varParam = match expr with
+++|LambdaSimple'(params, Seq'(seq_list)) -> (LambdaSimple'(params, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
+++|LambdaSimple'(params, other) -> (LambdaSimple'(params, Seq'([Set'(varParam,Box'(varParam));other])))
+++|LambdaOpt'(params, opt, Seq'(seq_list)) -> (LambdaOpt'(params, opt, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
+++|LambdaOpt'(params, opt, other) -> (LambdaOpt'(params, opt, Seq'([Set'(varParam,Box'(varParam));other])))
+++|_ -> raise X_syntax_error;;
+++
+++let rec replace_get_set expr varParam = match expr with
+++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+++                  then BoxGet'(var_var)
+++                  else Var'(var_var)
+++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, replace_get_set box_set_val varParam)
+++|If'(test, tCase, fCase) -> If'((replace_get_set test varParam), (replace_get_set tCase varParam), (replace_get_set fCase varParam))
+++|Seq'(seq_list) -> Seq'((List.map (fun t -> replace_get_set t varParam) seq_list))
+++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+++                           then (BoxSet'(set_var, replace_get_set set_val varParam))
+++                           else Set'(set_var, replace_get_set set_val varParam)
+++|Def'(def_var,def_val) -> Def'(def_var,replace_get_set def_val varParam)
+++|Or'(or_list) -> Or'((List.map (fun t -> replace_get_set t varParam) or_list))
+++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+++                                then LambdaSimple'(params, body)
+++                                else LambdaSimple'(params, (replace_get_set body varParam)) (* lookoo *)
+++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+++                                  then LambdaOpt'(params, opt, body)
+++                                  else LambdaOpt'(params, opt, (replace_get_set body varParam)) (* lookoo *)
+++|Applic'(proc, args) -> Applic'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
+++|ApplicTP'(proc, args) -> ApplicTP'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
+++|_ -> expr
+++;;
+++
+++
+++
+++let actually_do_the_fucking_boxing expr varParam =
+++  let expr_with_set_tag = (add_set_tag_to_body_of_lambda expr varParam) in
+++  match expr_with_set_tag with
+++  |LambdaSimple'(params, body) -> LambdaSimple'(params, replace_get_set body varParam)
+++  |_ -> raise X_syntax_error
+++  ;;
+++
+++(* the var list is (bool, the varParam) *)
+++let rec actually_do_the_fucking_boxing_2 expr varList = match expr, varList with
+++|_, [] -> expr
+++|LambdaSimple'(params,body), _ -> if(fst (List.hd varList))
+++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda (LambdaSimple'(params,(replace_get_set body (snd (List.hd varList))))) (snd(List.hd varList))) (List.tl varList)
+++      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
+++|LambdaOpt'(params, opt,body), _ -> if(fst (List.hd varList))
+++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda  (LambdaOpt'(params, opt, (replace_get_set body (snd (List.hd varList)))))(snd(List.hd varList))) (List.tl varList)
+++      else actually_do_the_fucking_boxing_2 expr (List.tl varList);;
+++
+++let  is_boxing_needed expr varParam =
+++  match expr with
+++  |LambdaSimple'(params,body)->
+++                                let goku = make_box_id_counter() in
+++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+++                                let goku = make_box_id_counter() in
+++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+++                                is_boxing_needed_2 get_list set_list
+++  |LambdaOpt'(params, opt, body)->
+++                                let goku = make_box_id_counter() in
+++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+++                                let goku = make_box_id_counter() in
+++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+++                                is_boxing_needed_2 get_list set_list
+++  |_ -> raise X_syntax_error
+++  ;;
+++
+++ (* let goku = make_box_id_counter() in
+++let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+++let goku = make_box_id_counter() in
+++let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+++if (is_boxing_needed_2 get_list set_list)
+++then (actually_do_the_fucking_boxing expr (varParam))
+++else expr *)
+++
+++
+++let gets_lambda_returns_it_boxed expr = match expr with
+++|LambdaSimple'(params, body) -> let act_params = make_lambda_params_vars params 0 in
+++                               let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
+++                               actually_do_the_fucking_boxing_2 expr box_list
+++|LambdaOpt'(params, opt, body) ->  let act_params = make_lambda_params_vars (params@[opt]) 0 in
+++                                   let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
+++                                   actually_do_the_fucking_boxing_2 expr box_list
+++|_ -> expr
+++;;
+++
+++let make_lambda_pair expr = match expr with
+++|LambdaSimple'(params, body) -> (params, body)
+++|_ ->raise X_syntax_error
+++
+++let make_lambda_triple expr = match expr with
+++|LambdaOpt'(params, opt, body) -> (params, opt, body)
+++|_ -> raise X_syntax_error
+++
+++let rec boxer_man expr = match expr with
+++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, boxer_man box_set_val)
+++|If'(test, tCase, fCase) -> If'((boxer_man test), (boxer_man tCase ), (boxer_man fCase ))
+++|Seq'(seq_list) -> Seq'((List.map (fun t -> boxer_man t ) seq_list))
+++|Set'(set_var, set_val) -> Set'(set_var, boxer_man set_val)
+++|Def'(def_var,def_val) -> Def'(def_var,boxer_man def_val)
+++|Or'(or_list) -> Or'((List.map (fun t -> boxer_man t ) or_list))
+++|LambdaSimple'(params, body) -> let (n_params, n_body) =( make_lambda_pair( gets_lambda_returns_it_boxed expr)) in
+++                                  LambdaSimple'(n_params, boxer_man n_body)
+++|LambdaOpt'(params, opt, body) -> let (n_params, n_opt, n_body ) = (make_lambda_triple (gets_lambda_returns_it_boxed expr)) in
+++                                  LambdaOpt'(n_params, n_opt, boxer_man n_body)
+++|Applic'(proc, args) -> Applic'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
+++|ApplicTP'(proc, args) -> ApplicTP'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
+++|_ -> expr
+++
+++let box_z e varParam= gets_lambda_returns_it_boxed e;;
+++
+++
+++let box_set e = boxer_man e;;
+++
+++  let run_semantics expr =
++   box_set
++     (annotate_tail_calls
++        (annotate_lexical_addresses expr));;
++-
+++
++ end;; (* struct Semantics *)
++
++
++diff --git a/tag-parser.ml b/tag-parser.ml
++index 138249e..68edecd 100644
++--- a/tag-parser.ml
+++++ b/tag-parser.ml
++@@ -57,9 +57,227 @@ let reserved_word_list =
++    "unquote-splicing"];;
++
++ (* work on the tag parser starts here *)
+++let rec tag_parse_expression sexpr  = match sexpr with
+++| Pair(Symbol("set!"), Pair(var, Pair(expr, Nil))) -> Set(tag_parse_expression var, tag_parse_expression expr)
+++| Pair(Symbol("pset!"), pset_sexpr) -> pset_macro_expansion pset_sexpr (* pset macro expansion*)
+++| Pair(Symbol("let"), let_sexpr) -> let_tag_parser let_sexpr
+++| Pair(Symbol("let*"), let_star_sexpr) -> let_star_tag_parser let_star_sexpr
+++| Pair(Symbol("letrec"), letrec_sexpr) -> letrec_tag_parser letrec_sexpr
+++| Pair(Symbol("lambda"), lambda_sexpr) -> lambda_tag_parser lambda_sexpr
+++| Pair(Symbol("cond"), Pair(rib,ribs)) ->cond_macro_expansion (Pair(rib,ribs)) (** cond_macro_expansion*)
+++| Pair(Symbol("if"), if_sexpr)-> if_tag_parser if_sexpr
+++| Pair(Symbol("define"), define_sexpr) -> define_tag_parser define_sexpr (*define_macro_expansion(**only MIT Style define has a macro-expansion*)*)
+++| Pair(Symbol("begin"), begin_sexpr) -> begin_tag_parser begin_sexpr
+++| Pair(Symbol("or"), or_sexpr) -> or_tag_parser or_sexpr
+++| Pair(Symbol("and"), Pair( opt1, opts)) -> and_macro_expansion (Pair(opt1, opts))(*and_macro_expansion opt1 opts *)
+++| Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+++| Pair(Symbol("quasiquote"), sexpr) -> quasiquote_macro_expansion (sexpr) (* quasiquote macro-expansion*)
+++(* | Pair(Symbol(var),Nil) -> Var(var) *)
+++| Pair(var, Pair(expr,exprl)) -> Applic(tag_parse_expression var, (tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl)))
+++| Number(x) -> Const(Sexpr(Number(x)))
+++| Char(x) -> Const(Sexpr(Char(x)))
+++| Bool(x) -> Const(Sexpr(Bool(x)))
+++| String(x) -> Const(Sexpr(String(x)))
+++| Symbol(x) -> Var(x)
+++| Pair(x, Nil) -> Applic((tag_parse_expression x),[])
++
++-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+++and cond_macro_expansion_sexpr cond_sexpr = match cond_sexpr with
+++|Nil ->  Nil
+++|Pair(Pair(Symbol("else"), body),rest) ->  Pair(Symbol("begin"), body)
+++|Pair(Pair(expr, Pair(Symbol("=>"),exprf)), rest) ->
+++(Pair (Symbol "let",
+++Pair
+++ (Pair (Pair (Symbol "value", Pair (expr, Nil)),
+++   Pair
+++    (Pair (Symbol "f",
+++      Pair (Pair (Symbol "lambda", Pair (Nil, Pair (exprf, Nil))),
+++       Nil)),
+++    Pair
+++     (Pair (Symbol "rest",
+++       Pair
+++        (Pair (Symbol "lambda", Pair (Nil, Pair (Symbol "cond-ribs", Nil))),
+++        Nil)),
+++     Nil))),
+++ Pair
+++  (Pair (Symbol "if",
+++    Pair (Symbol "value",
+++     Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
+++      Pair (Pair (Symbol "rest", Nil), Nil)))),
+++  Nil))))
+++  |Pair(Pair(test_case, ribs), rest) -> let  a = (Printf.printf "papparapa   ") in
+++  Pair(Symbol("if"), Pair(test_case, Pair(Pair(Symbol("begin"), ribs), Pair(cond_macro_expansion_sexpr (rest), Nil))))   (* (ג¨exprג© ג¨expr1ג© ֲ· ֲ· ֲ· ג¨exprmג©) *)
++
+++
+++
+++
+++and cond_macro_expansion cond_sexpra = tag_parse_expression (cond_macro_expansion_sexpr cond_sexpra)
+++
+++
+++(* (ג¨exprג© => ג¨exprfג©) *)
+++
+++
+++(* (let ((value Jג¨expr ג©K)
+++        (f (lambda () Jג¨exprfג©K))
+++(rest (lambda () Jג¨continue with cond-ribsג©K)))
+++(if value
+++    ((f) value)
+++    (rest))) *)
+++and pset_macro_expansion pset_sexpr = tag_parse_expression (pset_macro_expansion_sexpr pset_sexpr)
+++
+++and pset_macro_expansion_sexpr pset_sexpr = match pset_sexpr with
+++| Pair(Pair(var, Pair(value, Nil)), Nil) ->  (Pair(Symbol("set!"), Pair(var, Pair(value, Nil))))
+++| Pair(Pair(Symbol(var), Pair(value, Nil)), ribs) ->  (Pair(Symbol( "let"), Pair(Pair(Pair(Symbol( "_"^var), Pair(value , Nil)), Nil), Pair(Pair(Symbol( "lambda"), Pair(Nil, Pair(Pair(Symbol( "pset!"), ribs), Nil))), Pair(Pair(Symbol( "set!"), Pair(Symbol(var), Pair(Symbol( "_"^var), Nil))), Nil)))))
+++(* (Pair(Symbol("let"), Pair(Pair(Pair(Symbol("_v1"), Pair(value, Nil)), Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(Symbol("pset!"), Pair(ribs, Nil)), Nil))), Nil)), Nil)), Pair(Pair(Symbol("rest"), Nil), Pair(Pair(Symbol("set!"), Pair(var, Pair(Symbol("_v1"), Nil))), Nil))))) *)
+++(* let  a = (Printf.printf "arrived here") in  *)
+++
+++(* and heart_of_quasiquote q_sexpr = match q_sexpr with
+++| *)
+++
+++and quasiquote_macro_expansion q_sexpr = match q_sexpr with
+++| Pair (Pair (Pair (Symbol "unquote", Pair (sexpr, Nil)), Nil), Nil) -> Applic (Var "cons", [tag_parse_expression( sexpr); Const (Sexpr Nil)])
+++| Pair (Pair (Pair (Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil), Nil) -> Const(Sexpr(Pair(Symbol("quote"), q_sexpr)))
+++(* | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil) -> raise X_syntax_error *)
+++| Nil -> Const(Sexpr(Pair(Symbol("quote"), Nil)))
+++| Pair (Pair (Symbol(s1), Nil), Nil)  -> Const(Sexpr(Pair(Symbol("quote"), Symbol(s1))))
+++(* | Pair(Pair(Pair(Symbol("unquote-splicing"), sexa)), B) ->  *)
+++
+++and and_macro_expansion and_sexpr = match and_sexpr with
+++| Nil -> Const(Sexpr(Bool(true)))
+++| Pair(op, Nil)-> tag_parse_expression op
+++| Pair(op1, opts) -> If(tag_parse_expression op1, and_macro_expansion opts, Const(Sexpr(Bool(false))))
+++
+++and or_tag_parser or_sexpr = match or_sexpr with
+++| Nil -> Or([])
+++| Pair(expr, Nil) -> tag_parse_expression expr
+++| Pair(expr, exprl) -> Or(((tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl))))
+++
+++and rib_varu_maker rimbs = match rimbs with
+++|Nil -> Nil
+++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(varu, Nil)
+++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(varu, rib_varu_maker (rimbs2))
+++
+++and rib_valu_maker rimbs = match rimbs with
+++|Nil -> Nil
+++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(valu, Nil)
+++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(valu, rib_valu_maker rimbs2)
++
+++and let_tag_parser let_sexpr = match let_sexpr with
+++| Pair(Nil, body) ->  tag_parse_expression (Pair(Pair(Symbol("lambda"),Pair(Nil, body)), Nil))
+++| Pair(Pair(rib, ribs), body) ->  tag_parse_expression( Pair(Pair(Symbol("lambda"),Pair(rib_varu_maker (Pair(rib, ribs)), body )),rib_valu_maker (Pair(rib,ribs))))
+++
+++and let_star_tag_parser_sexpr let_star_sexpr = match let_star_sexpr with
+++| Pair(Nil, body) -> (Pair (Symbol("let"), let_star_sexpr))
+++| Pair(Pair(rib, Nil), body)->(Pair (Symbol("let"), let_star_sexpr))
+++| Pair(Pair(rib,ribs), body) ->  (Pair(Symbol("let"), Pair(Pair(rib,Nil), let_star_tag_parser_sexpr ((Pair(ribs, body)))))) (* let* macro-expansion*)
+++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
+++
+++and let_star_tag_parser let_star_sexpr = match let_star_sexpr with
+++| Pair(Nil, body) -> tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
+++| Pair(Pair(rib, Nil), body)->tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
+++| Pair(Pair(rib,ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib,Nil), Pair(Symbol("let*"), Pair(ribs, body))))) (* let* macro-expansion*)
+++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
+++
+++and create_set_sexprs ribs body= match ribs with
+++| Pair(Nil,Nil) -> Nil
+++| Pair(Pair(var,Pair(value,Nil)),Nil) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), body)
+++| Pair(Pair(var,Pair(value,Nil)),rest) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), (create_set_sexprs rest body ))
+++
+++and  letrec_tag_parser letrec_sexpr = match letrec_sexpr with
+++| Pair(Nil, body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Nil, Pair(body, Nil))))
+++| Pair(Pair(rib, ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib, ribs), (create_set_sexprs (Pair(rib,ribs)) body ))))(*letrec_macro_expansion rib ribs body*)
+++
+++and checkArguments args =
+++match args with
+++| Pair(Symbol("vs"), Nil) -> variadic_lambda
+++| Pair(arg, Nil) -> simple_lambda_tag_parser
+++| Pair(arg1, Symbol(opt)) -> (opt_lambda_tag_parser opt )
+++| Pair(arg1,rest) -> checkArguments rest
+++
+++
+++and create_string_arr sList = match sList with
+++| Symbol(vs) -> []
+++| Pair(Symbol(last), Nil) -> [last]
+++| Pair(Symbol(str1), b) -> str1::create_string_arr b
+++| Nil -> []
+++
+++and makeSequence expr_list = Seq(flattenSequence (List.map tag_parse_expression (sexpr_to_list expr_list)))
+++
+++and simple_lambda_tag_parser lambda_sexpr =
+++let  a = (Printf.printf "arrived simple tag") in
+++match lambda_sexpr with
+++| Pair (args, Pair(expr, Nil)) ->  LambdaSimple((create_string_arr args),tag_parse_expression expr)
+++| Pair( args,expr_list) ->  LambdaSimple((create_string_arr args), makeSequence expr_list)(* simple*)
+++
+++and opt_lambda_tag_parser opt lambda_sexpr =
+++let  a = (Printf.printf "arrived opt tag") in
+++match lambda_sexpr with
+++| Pair(args, Pair(expr, Nil)) -> LambdaOpt((create_string_arr args), opt, tag_parse_expression expr)(* opt*)
+++| Pair(args, expr_list) -> LambdaOpt((create_string_arr args), opt, makeSequence expr_list)(* opt*)
+++
+++and variadic_lambda lambda_sexpr =
+++let  a = (Printf.printf "arrived variadic") in
+++match lambda_sexpr with
+++| Pair(Pair(Symbol("vs"),Nil), Pair(expr, Nil)) ->  LambdaOpt([], "vs", tag_parse_expression expr)(* opt*)
+++| Pair(Pair(Symbol("vs"),Nil), expr_list) -> LambdaOpt([], "vs", makeSequence expr_list)(* opt*)
+++
+++and lambda_tag_parser lambda_sexpr = match lambda_sexpr with
+++|Pair(Nil, expr) -> simple_lambda_tag_parser lambda_sexpr
+++|Pair(args, expr) -> (checkArguments args) lambda_sexpr
+++
+++
+++
+++and define_tag_parser define_sexpr = match define_sexpr with
+++| Pair (Pair (var, arglist), Pair (exprs, Nil)) -> tag_parse_expression (Pair(Symbol "define", Pair(var, Pair(Pair(Symbol "lambda", Pair(arglist, Pair(exprs, Nil))), Nil))))
+++| Pair(name, Pair(expr, Nil)) -> Def(tag_parse_expression name,  tag_parse_expression expr )
+++(* Pair(Symbol "define", Pair(Pair(Symbol "var", Symbol "arglist"), Pair(Symbol "expr+", Nil))) *)
+++
+++and sexpr_to_list pair_list = match pair_list with
+++| Nil  -> []
+++| Pair(a , b) -> a:: (sexpr_to_list b)
+++
+++and  flattenSequence  expr_list_2 =
+++  List.fold_left (fun acc expr -> match expr with
+++  | Seq(lst) -> acc@lst
+++  (* | Const(void) -> []  *)
+++  | _ -> acc@[expr]) [] expr_list_2
+++and begin_tag_parser begin_sexpr =
+++  match begin_sexpr with
+++| Nil-> Const (Void)
+++| Pair(a, Nil) -> tag_parse_expression a
+++| sexprs -> Seq (flattenSequence (List.map tag_parse_expression ( sexpr_to_list sexprs)))
+++
+++and if_tag_parser if_sexpr = match if_sexpr with
+++| Pair(test, Pair(dit, Pair(dif, Nil)))-> let  a = (Printf.printf "babidi if" ) in
+++  If(tag_parse_expression test, tag_parse_expression dit, tag_parse_expression dif)
+++| Pair(test, Pair(dit,Nil))->
+++  If(tag_parse_expression test, tag_parse_expression dit, Const (Void));;
+++
+++
+++let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;
+++
+++
++ end;; (* struct Tag_Parser *)
++
+++(*
+++(define sexpr->ocaml-string
+++(lambda(e)
+++(cond
+++((boolean? e)
+++(if e "Bool true" "Bool false"))
+++((null? e) "Nil")
+++((char? e) (  format "Char '~a'" e))
+++((symbol? e) (  format "Symbol \"~a\"" e))
+++((string? e) (  format "String \"~a\"" e) )
+++((flonum? e) (  format "Number (Float ~a)" e))
+++((integer? e) (  format "Number (Fraction(~a, 1))" e))
+++((ratnum? e)
+++(format "Number (Fraction(~a, ~a))" (numeratore) (denominatore)))
+++((pair? e)
+++(format "Pair(~a, ~a)"
+++(sexpr->ocaml-string (car e))
+++(sexpr->ocaml-string (cdr e))))
+++(else(error 'sexpr->ocaml-string
+++(format "Unsupported type: ~a" e))))))
+++(define print-template
+++(lambda(sexpr)(display(sexpr->ocaml-string sexpr))))
+++(print-template'(let (rib . ribs) body)) *)
++\ No newline at end of file
+diff --git a/omer folder/fresh_compiler b/omer folder/fresh_compiler
+new file mode 160000
+index 0000000..ea461c3
+--- /dev/null
++++ b/omer folder/fresh_compiler
+@@ -0,0 +1 @@
++Subproject commit ea461c365d4c85ac63bf494212989f80683e85ad-dirty
+diff --git a/reader.ml b/reader.ml
+index 32445c2..24c92e3 100644
+--- a/reader.ml
++++ b/reader.ml
+@@ -1,5 +1,5 @@
+-
+ #use "pc.ml";;
++open PC;;
+
+ exception X_not_yet_implemented;;
+ exception X_this_should_not_happen;;
+@@ -17,18 +17,20 @@ type sexpr =
+   | Symbol of string
+   | Pair of sexpr * sexpr;;
+
+-let rec sexpr_eq s1 s2 =
+-  match s1, s2 with
+-  | Bool(b1), Bool(b2) -> b1 = b2
+-  | Nil, Nil -> true
+-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+-  | Char(c1), Char(c2) -> c1 = c2
+-  | String(s1), String(s2) -> s1 = s2
+-  | Symbol(s1), Symbol(s2) -> s1 = s2
+-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+-  | _ -> false;;
+
++  let rec sexpr_eq s1 s2 =
++    match s1, s2 with
++    | Bool(b1), Bool(b2) -> b1 = b2
++    | Nil, Nil -> true
++    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
++    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
++    | Char(c1), Char(c2) -> c1 = c2
++    | String(s1), String(s2) -> s1 = s2
++    | Symbol(s1), Symbol(s2) -> s1 = s2
++    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
++    | _ -> false;;
++
++
+ module Reader: sig
+   val read_sexprs : string -> sexpr list
+ end
+@@ -40,7 +42,274 @@ let normalize_scheme_symbol str =
+	s) then str
+   else Printf.sprintf "|%s|" str;;
+
++let packOnFirst nt f s =
++  let (e, s) = (nt s) in
++  (f e);;
+
+-let read_sexprs string = raise X_not_yet_implemented;;
++let packOnSecond nt f s =
++  let (e, s) = (nt s) in
++  (f s);;
+
++let notChar = make_char (fun ch1 ch2 -> ch1 != ch2);;
++
++
++
++let newLineParsaPred = packOnFirst   (caten (char '\\') (char 'n')) (fun _ ->  false);;
++
++(* let newLineParsa = pack (caten (char '\\') (char 'n')) (fun (e,s) -> s);; *)
++let newLineParsa = char '\n';;
++
++let nt_whitespaces = star (char ' ');;
++
++
++let make_paired nt_left nt_right nt =
++let nt = caten nt_left nt in
++let nt = pack nt (function (_, e) -> e) in
++let nt = caten nt nt_right in
++let nt = pack nt (function (e, _) -> e) in
++nt;;
++
++let make_spaced nt =
++  make_paired nt_whitespaces nt_whitespaces nt;;
++
++let semicolonParser = char ';';;
++
++
++(* let notNewLineParser = packOnFirst( (const (newLineParsaPred))) (fun ch -> ch);; *)
++let notNewLineParser  = const(fun p -> p!= '\n');;
++(* let notNewLineParser = (const(fun p -> p!= "\\n")) ;; *)
++(* let notNewLineParser = let nt = word "\\n" in
++                       let nt = ;; *)
++(* let notNewLineParser  = try word "\\n"
++                        with X_no_match  ->  nt_any
++                          ;; *)
++
++
++
++
++(* let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');; *)
++let notNewLineParser2 = (star (notNewLineParser)) ;;
++(* this check as long as there is no new line *)
++
++let make_line_comment_parser_paired  =
++  let nt = caten semicolonParser notNewLineParser2 in
++  let nt = pack nt (function (_, e) -> e) in
++  let nt = caten nt newLineParsa in
++  let nt = packOnSecond nt (function e ->  (e,e)) in
++  nt;;
++
++
++(* let lineCommentParser = make_spaced ( pack (caten   semicolonParser (caten (star notNewLineParser)  newlineParser)) (fun _ -> [' '])  );; *)
++
++
++(* Boolean, dot, CharPrefix, Digit,Natural,  Fraction, Float*)
++let backSlashParser = char '\\';;
++let hashParser = char '#';;
++
++(*
++⟨Boolean⟩::= #f | #t
++*)
++let booleanParser = make_spaced( PC.pack (PC.caten hashParser (PC.disj (PC.char_ci 't') (PC.char_ci 'f') ))
++        (fun (_, ch) -> if ch = 't' || ch = 'T' then Bool true else Bool false));;
++
++(* digit => Natural => Integer => Fraction => Float => *)
++let digitParser  = range '0' '9';;  (* Parses all numbers between 0-9 <digit> *)
++let digitSeqParser = (plus digitParser);;(* <digit>+ *)
++let naturalParser = pack digitSeqParser (fun str ->  (int_of_string(list_to_string str)));;(*Turns a list of chars of numbers into a natural number*)
++
++
++let maybeMinusPlusParser = (* Parses  (+|-)? and returns -1 if the char that is parsed is - and 1 otherwise *)
++  let plusParser = pack (char '+') (fun _ -> 1) in  (*returns 1*)
++  let minusParser =  pack (char '-') (fun _ -> -1) in (*returns -1*)
++  pack (maybe(disj plusParser minusParser)) (fun opt -> match opt with Some(e) -> e | None -> 1);;
++
++let integerParser = pack (caten maybeMinusPlusParser naturalParser) (fun (e,s) -> e*s);; (* <Integer> catens the (+|-)? with natural number and multiplies the outputs  *)
++
++let rec gcd a b = (*returns greates commod divisor of a and b *)
++  if b = 0 then a else gcd b (a mod b);;
++
++let fractionParser = (*<Fraction> = <Integer> / <Natural> *)
++  let fractionPar = pack( caten( caten integerParser (char '/')) naturalParser) (fun ((i, d), n) ->
++  let div = gcd i n in (*gets gcd if the numerator and denominator*)
++  Fraction (i/div, n/div)) in  (*makes the smallest number of an integer and natural number*)
++  let integerToFraction = pack integerParser (fun num -> Fraction (num, 1)) in (*an Integer is parsed into a Fraction with 1 as the denominator*)
++    disj fractionPar integerToFraction ;;
++
++let mantissaParser = pack digitSeqParser (fun lst -> (* parses a list of digit chars to a mantissa*)
++  let with0 = String.concat "" ["0."; (list_to_string lst)] in (*before the char list is turned into a float, the list ['0';'.'] is concatenated before it so the number will stay as a mantissa *)
++  float_of_string with0);;
++
++let floatParser string = pack( caten( caten integerParser (char '.')) mantissaParser) (fun ((i, d), m) -> (*<Float> = ⟨Integer⟩.⟨Natural⟩*)
++   if i > 0 then  (float_of_int i)+.m (*connect the integer with a mantissa *)
++   else if i==0 && List.nth string 0 != '-'  then (float_of_int i) +. m
++   else (float_of_int i) -. m) string;;
++
++let scientificNotationParser = (* The scientic notation is of the form of (integer | float) e|E integer*)
++    let integerAndFloat = disj  floatParser (pack integerParser (fun num ->  float_of_int num ))  in  (** returns a Float, if the num is int it makes a Float of it*)
++    let e = pack (char_ci 'e') (fun _ -> Nil) in
++    pack( caten( caten integerAndFloat e) integerParser) (fun ((num, d), pow) -> num *. 10.0 ** (float_of_int pow));;
++let numberParser = make_spaced( pack (disj (pack (disj scientificNotationParser floatParser) (fun fl -> Float fl) ) fractionParser) (fun num -> Number num ));; (* (scientifNotation | Float | Fraction)*)
++
++
++let charPrefixParser = pack (caten hashParser backSlashParser) (fun _ -> Nil);;
++
++let visibleCharParser = pack (const (fun p -> p > ' ')) (fun ch -> Char ch);;
++
++let nulParser = pack( word_ci "nul") (fun _ -> Char (char_of_int 0));;
++let newlineParser = pack( word_ci "newline") (fun _ -> Char (char_of_int 10));;
++let returnParser = pack( word_ci "return") (fun _ -> Char (char_of_int 13));;
++let tabParser = pack( word_ci "tab") (fun _ -> Char (char_of_int 9));;
++let formfeedParser = pack( word_ci "page") (fun _ -> Char (char_of_int 12));;
++let spaceParser = pack( word_ci "space") (fun _ -> Char (char_of_int 32));;
++
++
++let namedCharParser = disj_list  [nulParser; newlineParser; returnParser; tabParser; formfeedParser; spaceParser];;
++
++let charParser = make_spaced( pack (caten charPrefixParser (disj namedCharParser visibleCharParser)) (fun (_, ch) -> ch));;
++
++(* need to add named char*)
++
++
++let dotParser string= pack (guard (char '.') (fun _ -> List.length(string) > 1))(fun _ -> ".") string;; (**doest parse if . is alone *)
++let symbolCharNoDotParser = (*Parses all the chars that are not a dot and turns them into a string*)
++    let letter_ciParser = pack(range_ci 'a' 'z') (fun ch -> lowercase_ascii ch) in
++    let punctuationParser = one_of "!$^*-_=:+<>/?" in
++    pack (disj_list [digitParser ; letter_ciParser ; punctuationParser]) (fun sym -> String.make 1 sym);;
++let symbolCharParser = disj symbolCharNoDotParser dotParser;; (*(<dot> | <symbolCharNoDot>)*)
++let symbolParser =
++    let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in (*<symbolChar><symbolChar>+, connects the strings of the symbols *)
++    let symbolParserWithoutNumber = (disj withDotParser symbolCharNoDotParser) in
++    pack symbolParserWithoutNumber (fun str ->
++    try (let (e,s) = numberParser (string_to_list str) in
++    if s == [] then e else Symbol(str))
++    with X_no_match -> Symbol(str));; (*Constructs a symbol with a string*)
++
++ (* let symbolParserWithoutNumber =
++  let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in
++  disj withDotParser symbolCharNoDotParser;;
++let symbolParser string=
++  let parsedBySymbol = symbolParserWithoutNumber
++  try (let number = numberParser )  *)
++
++
++let gershaimParser = PC.char '"';;
++
++let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');;
++
++let returnStringMetaCharParser = pack (char_ci 'r') (fun _ -> char_of_int 13)
++let newlineStringMetaCharParser = pack (char_ci 'n') (fun _ -> char_of_int 10)
++let tabStringMetaCharParser = pack (char_ci 't') (fun _ -> char_of_int 9)
++let pageStringMetaCharParser = pack (char_ci 'f') (fun _ -> char_of_int 12)
++let backslashStringMetaCharParser = pack (char_ci '\\') (fun _ -> char_of_int 92)
++let gershaimStringMetaCharParser = pack (char_ci '"') (fun _ -> char_of_int 34)
++
++let stringMetaCharParser = pack (caten backSlashParser (disj_list [returnStringMetaCharParser;
++                                      newlineStringMetaCharParser;
++                                      tabStringMetaCharParser;
++                                      pageStringMetaCharParser;
++                                      backslashStringMetaCharParser;
++                                      gershaimStringMetaCharParser]) ) (fun (_, ch) -> ch);;
++
++let stringCharParser = disj stringMetaCharParser stringLiteralCharParser;;
++
++let stringParser = make_spaced( pack (caten (caten gershaimParser (star stringCharParser)) gershaimParser)
++                      (fun ((_, lst), _) -> String (list_to_string lst)) );;
++
++(* let numberParser = pack (disj floatParser fractionParser) (fun num -> Number num );; *)
++(* bad number parser *)
++
++let openParenthasisParser = char '(';;
++let closedParenthasisParser = char ')';;
++
++
++(* let emptyListParser = make_spaced( pack (make_paired openParenthasisParser closedParenthasisParser (caten (disj nt_whitespaces make_line_comment_parser_paired) nt_whitespaces)) (fun _ -> Nil) ) *)
++
++
++
++(* let emptyListParser = pack(make_line_comment_parser_paired) (fun _-> Nil) ;;  *)
++
++(* let singleQuoteParser = char ''';;
++let quoteParser =  make_spaced( pack (  caten singleQuoteParser read_   ) (fun  )  );;
++
++let quotingParser = NUL;; *)
++
++let veryGoodDotParser = pack(char '.') (fun ch -> Char ch) ;;
++
++
++let rec starush nt s =
++  try let (e, s) = (nt s) in
++      let (es, s) = (starush nt s) in
++      (Pair(e,es), s)
++  with X_no_match -> (Nil, s);;
++
++
++let rec starush2 nt s =
++  try let (e, s) = (nt s) in
++      let (es, s) = (starush nt s) in
++      (Pair(e,es), s)
++  with X_no_match ->
++                     try let ((e,e2),s) = (caten veryGoodDotParser nt) s in
++                     (e2,s)
++                     with X_no_match -> (Nil, s);;
++
++let plusush nt =
++  pack (caten nt (starush nt))
++        (fun (e, es) -> (Pair(e,es)));;
++
++
++let rec read_sexpr paparapa=
++  let rec improperSecondArgumentParser = pack ( make_spaced( (caten veryGoodDotParser (caten nt_whitespaces read_sexpr )  ))) (fun (_,(_,e)) ->  e)
++  and
++
++  starushu nt s =
++    try let (e, s) = (nt s) in
++        let (es, s) = (disj (improperSecondArgumentParser) (starushu nt ) ) s in
++        (Pair(e,es), s)
++    with X_no_match -> (Nil, s)
++  in
++
++   let rec listParser = pack( (caten openParenthasisParser (caten  (disj (starushu (make_spaced read_sexpr)) (starush (make_spaced read_sexpr))) closedParenthasisParser)  )) (fun (_,(e,_)) -> e)
++   (* let listParser = pack( make_spaced( caten openParenthasisParser (caten read_sexpr (caten (disj_list [improperSecondArgumentParser; noSecondItemInPairParser; secontItemInPairParser] ) closedParenthasisParser ))) ) (fun (_,(ent1,( ent2, _))) -> Pair(ent1, ent2)) *)
++  and
++
++   lineCommentParser = pack (make_line_comment_parser_paired) (fun _ -> Nil)
++  and sexpCommentParser = pack (caten (char '#')  (caten (char ';') read_sexpr )) (fun _ -> Nil)
++  in let commentParser = (pack (make_spaced(disj sexpCommentParser lineCommentParser ))) (fun _ -> Nil)
++  in let emptyListParser = pack((caten openParenthasisParser (caten (star commentParser) closedParenthasisParser))) (fun _ -> Nil)
++  in let quoteParser = pack( (caten (make_spaced(char (char_of_int 39))) read_sexpr)) (fun (e,s) -> Pair(Symbol("quote"),Pair(s,Nil)))
++  in let qQuoteParser =  pack( (caten (make_spaced(char '`')) read_sexpr)) (fun (e,s) -> Pair(Symbol("quasiquote"),Pair(s,Nil)))
++  in let unQuoteParser =  pack( (caten (make_spaced(char ',')) read_sexpr)) (fun (e,s) -> Pair(Symbol("unquote"),Pair(s,Nil)))
++  in let unQuoteSplicingParser =  pack( caten (make_spaced(caten (char ',') (char '@'))) read_sexpr) (fun (e,s) -> Pair(Symbol("unquote-splicing"),Pair(s,Nil)))
++
++  in pack (caten (star commentParser) (caten (disj_list [quoteParser; qQuoteParser; unQuoteParser; unQuoteSplicingParser; emptyListParser;listParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star commentParser))) (fun (_,(s,_)) -> s)
++  paparapa
++  ;;
++
++
++(* let rec read_sexpr =
++  pack (caten (star sexpCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star sexpCommentParser))) (fun (_,(s,_)) -> s)
++  and lineCommentParser = (pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil) )
++  and sexpCommentParser  = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr ))) (fun _ -> Nil)
++  ;; *)
++
++(* let lineCommentParser = pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil);; *)
++
++(* let sexpCommentParser = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr)) (fun _ -> Nil);; *)
++
++(* let rec read_sexpr =   pack (caten (star lineCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star lineCommentParser))) (fun (_,(s,_)) -> s)  ;; *)
++(* (fun c -> match c with
++| Nil -> []
++| _ -> c) ;; *)
++
++(* let read_sexpr =
++
++  try pack( caten commentParser (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])) (fun (e,s) -> s)
++  with X_no_match ->  try pack( caten  (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])commentParser ) (fun (e,s) -> e)
++    with X_no_match -> disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser];; *)
++(* let read_sexpr str = disj_list [booleanParser ; charParser ; numberParser ; stringParser ; symbolParser ] *)
++
++let read_sexprs string = let (e,s) = (caten (star read_sexpr) nt_end_of_input ) (string_to_list string) in
++            let (e2, s2)= e in
++             e2;;
+ end;; (* struct Reader *)
++
+diff --git a/readme.txt b/readme.txt
+index e69de29..710c26c 100644
+--- a/readme.txt
++++ b/readme.txt
+@@ -0,0 +1,10 @@
++Itay Almoznino 318911187
++Tommer Federman 212198378
++
++We assert that the work we submitted is 100% our own. We have not received any
++part from any other student in the class, nor have we give parts of it for use to others.
++Nor have we used code from other sources: Courses taught previously at this university,
++courses taught at other universities, various bits of code found on the internet, etc.
++We realize that should our code be found to contain code from other sources, that a
++formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
++action.
+diff --git a/semantic-analyser.ml b/semantic-analyser.ml
+index 8e684f0..21afec3 100644
+--- a/semantic-analyser.ml
++++ b/semantic-analyser.ml
+@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
+   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
+   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
+-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
+-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
+-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
+-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
+   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
+                                             (expr'_eq th1 th2) &&
+                                               (expr'_eq el1 el2)
+@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
+   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
+	(expr'_eq e1 e2) &&
+	(List.for_all2 expr'_eq args1 args2)
+-  | _ -> false;;
+-
++  | _ -> false;;
++
++
+ exception X_syntax_error;;
+
+ module type SEMANTICS = sig
+@@ -65,21 +57,397 @@ module type SEMANTICS = sig
+   val annotate_lexical_addresses : expr -> expr'
+   val annotate_tail_calls : expr' -> expr'
+   val box_set : expr' -> expr'
+-end;;
++  end;;
+
+ module Semantics : SEMANTICS = struct
++(*How the function works- for each lambda of depth n, i create n counters that count the minor number of vars for each bound var,
++for that n counters are needed, except of that, i keep all the params of the lambdas in a 2d-list*)
++let rec parse_expr_to_expr' expr env_param_list  =
++  let callParse expr = parse_expr_to_expr' expr env_param_list in
++  let parseVar str = parse_to_var str env_param_list in
++  match expr with
++| Const(sexpr) -> Const'(sexpr)
++| Var(str) ->   Var'(parseVar str)
++| If(e1,e2,e3) ->  If'(callParse e1 ,callParse e2,callParse e3 )
++| Seq(exprl) -> Seq'(List.map callParse exprl)
++| Set(Var(str),expr2) ->  Set'(parseVar str ,callParse expr2 )
++| Def(Var(str), expr2) ->  Def'(parseVar str, callParse expr2)
++| Or(exprl) -> Or'(List.map callParse exprl)
++| LambdaSimple(strl, expr) -> LambdaSimple'(strl, parse_expr_to_expr' expr ((strl:: env_param_list)) )
++| LambdaOpt(strl, opt, expr) -> LambdaOpt'(strl, opt, parse_expr_to_expr' expr ((strl@[opt])::env_param_list) )
++| Applic(expr, exprl) -> Applic'(callParse expr,List.map callParse exprl)
++|_ -> raise X_syntax_error
++(* test - LambdaSimple (["x"], Applic (Var "x",[LambdaSimple (["y"],Applic (Var "x",[Var "y"; LambdaSimple (["z"], Applic (Var "x", [Var "y"; Var "z"]))]))])) *)
++and get_index_of_arr str env_params ind =
++  let nth = List.nth env_params ind in
++  if ind > List.length env_params then -1
++  else if List.exists (fun x -> x = str) nth then ind
++  else get_index_of_arr str env_params (ind+1)
+
+-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
++(* and make_counter() =
++  let x = ref(-1) in
++  fun() -> x := !x + 1; !x  *)
+
+-let annotate_tail_calls e = raise X_not_yet_implemented;;
++and printList lst = match lst with
++| hd :: tl ->  "["^(stringList hd)^"];"^(printList tl)
++| [] -> ""
+
+-let box_set e = raise X_not_yet_implemented;;
++and stringList strl = match strl with
++| hd ::tl -> (hd)^";"^(stringList tl)
++| [] -> ""
+
+-let run_semantics expr =
++and get_index_of_var_in_env var var_arr ind=
++  let nth = (List.nth (var_arr) ind) in
++  if (nth = var) then ind
++  else get_index_of_var_in_env var var_arr (ind+1)
++
++and parse_to_var str env_params =
++  let major_count =
++    if (not (List.exists (List.exists (fun x -> str = x)) env_params)) then -1 (* no lambda params has the str and so it is free *)
++    else get_index_of_arr str env_params 0
++    in
++    (* (Printf.printf "params [%s]" (printList env_params)) ; *)
++  match major_count with
++  | -1 -> VarFree(str)
++  | 0 -> VarParam(str, get_index_of_var_in_env str (List.nth env_params major_count) 0)
++  | n -> VarBound(str, major_count-1, get_index_of_var_in_env str (List.nth env_params major_count) 0);;
++let annotate_lexical_addresses e = parse_expr_to_expr' e [];;
++
++
++let rec annotate_tp e tp = match e with (* https://www.cs.bgu.ac.il/~comp151/wiki.files/ps8.pdf*)
++| Const'(cons) -> e
++| Var'(v) -> e
++| If'(test, dit, dif) -> If'(annotate_tp test false, annotate_tp dit tp, annotate_tp dif tp)
++| Seq'(expl) -> Seq'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
++| Set'(v, exp) -> Set'(v,annotate_tp exp false)
++| Def'(v, exp) -> Def'(v, annotate_tp exp  false)
++| Or'(expl) -> Or'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
++| LambdaSimple'(strl, exp) -> LambdaSimple'(strl,  annotate_tp exp true)
++| LambdaOpt'(strl, opt, exp) -> LambdaOpt'(strl, opt, annotate_tp exp true)
++| Applic'(exp, expl) -> if tp then ApplicTP'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
++                        else Applic'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
++|_ -> raise X_syntax_error;;
++let annotate_tail_calls e = annotate_tp e false;;
++
++(* type var =
++  | VarFree of string
++  | VarParam of string * int
++  | VarBound of string * int * int;; *)
++
++
++
++
++let name_of_var v = match v with
++|VarFree(s) -> s
++|VarParam(s, _) -> s
++|VarBound(s,_,_) -> s
++;;
++
++let get_number_based_on_variable var = match var with
++|VarParam(s, minor) -> -1
++|VarBound(s, major, minor) -> major
++|_ -> raise X_syntax_error
++;;
++
++(* receives an expression expr and var varParam, and boxes all occurences of the var,
++ this function will be called at step 2 of boxing in closures*)
++
++let check_if_var_is_in_param_list params varName = match params with
++|[] -> false
++|_ -> List.exists (fun t -> t = varName) params;;
++
++let is_read_occure expr varParam = match expr with
++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++                  then true
++                  else false
++|_ -> false
++;;
++
++let rec has_read_occure expr varParam = match expr with
++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++                  then true
++                  else false
++|Box'(box_var) -> has_read_occure (Var'(box_var)) varParam
++|BoxSet'(box_set_var, box_set_val) -> has_read_occure box_set_val varParam
++|If'(test, tCase, fCase) -> has_read_occure_in_seq ([test]@[tCase]@[fCase]) varParam
++|Seq'(seq_list) -> has_read_occure_in_seq seq_list varParam
++|Set'(set_var, set_val) -> has_read_occure set_val varParam
++|Def'(def_var,def_val) -> has_read_occure def_val varParam
++|Or'(or_list) -> has_read_occure_in_seq or_list varParam
++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++                                then false
++                                else has_read_occure body varParam (* lookoo *)
++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++                                  then false
++                                  else has_read_occure body varParam (* lookoo *)
++|Applic'(proc, args) -> let proc_and_args = proc::args in
++                              has_read_occure_in_seq proc_and_args varParam
++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++                              has_read_occure_in_seq proc_and_args varParam
++|_ -> false
++
++and  has_read_occure_in_seq expr_list varParam = match expr_list with
++|[] -> false
++|_ -> List.exists (fun t -> has_read_occure t varParam) expr_list;;
++
++let is_write_occure expr varParam = match expr with
++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++                           then true
++                           else false
++|_ -> false
++;;
++(* returns true if the expression is a write occure of the var *)
++
++let rec has_write_occure expr varParam = match expr with
++|BoxSet'(box_set_var, box_set_val) -> has_write_occure box_set_val varParam
++|If'(test, tCase, fCase) -> has_write_occure_in_seq ([test]@[tCase]@[fCase]) varParam
++|Seq'(seq_list) -> has_write_occure_in_seq seq_list varParam
++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++                           then true
++                           else false
++|Def'(def_var,def_val) -> has_write_occure def_val varParam
++|Or'(or_list) -> has_write_occure_in_seq or_list varParam
++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++                                then false
++                                else has_write_occure body varParam (* lookoo *)
++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++                                  then false
++                                  else has_write_occure body varParam (* lookoo *)
++|Applic'(proc, args) -> let proc_and_args = proc::args in
++                         has_write_occure_in_seq proc_and_args varParam
++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++                          has_write_occure_in_seq proc_and_args varParam
++|_ -> false
++
++
++
++and  has_write_occure_in_seq expr_list varParam = match expr_list with
++|[] -> false
++|_ -> List.exists (fun t -> has_write_occure t varParam) expr_list;;
++
++(* this function gets:
++   # expr- of type expr'
++   # varParam- of type VarParam
++   # c_id - closure id which signifies the closure we are in. the importance of this is that
++   we can check the first condition of boxing with it
++   # a counter!!!! starts at 0
++
++  the function returns a list of all the get occurences for each occurence it gives:
++   # c_id - closure id
++   # depth - the depth of the variable read. if it is of type VarParam then -1.
++   if it is of type bound then the value of the major
++
++   *)
++
++let rec make_list_of_get_occures expr varParam c_id counter_man = match expr with
++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++                  then [c_id,(get_number_based_on_variable var_var)]
++                  else []
++|Box'(box_var) ->  make_list_of_get_occures (Var'(box_var)) varParam c_id counter_man
++|BoxSet'(box_set_var, box_set_val) -> make_list_of_get_occures box_set_val varParam c_id counter_man
++|If'(test, tCase, fCase) -> (List.concat (has_read_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
++|Seq'(seq_list) -> (List.concat (has_read_occure_in_seq_complex seq_list varParam c_id counter_man))
++|Set'(set_var, set_val) -> make_list_of_get_occures set_val varParam c_id counter_man
++|Def'(def_var,def_val) -> make_list_of_get_occures def_val varParam c_id counter_man
++|Or'(or_list) -> (List.concat (has_read_occure_in_seq_complex or_list varParam c_id counter_man))
++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++                                then []
++                                else make_list_of_get_occures body varParam (counter_man()) counter_man (* lookoo *)
++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++                                  then []
++                                  else make_list_of_get_occures body varParam (counter_man()) counter_man(* lookoo *)
++|Applic'(proc, args) -> let proc_and_args = proc::args in
++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++|_ -> []
++
++(* this function is the read occures in seq but it records what it sees yeahhhh *)
++and  has_read_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
++|[] -> []
++|one::two -> match one with
++            |LambdaSimple'(params, body) -> (make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++            |LambdaOpt'(params, opt, body) ->(make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++            |_ -> (make_list_of_get_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++;;
++
++
++
++let rec make_list_of_set_occures expr varParam c_id counter_man = match expr with
++|BoxSet'(box_set_var, box_set_val) -> make_list_of_set_occures box_set_val varParam c_id counter_man
++|If'(test, tCase, fCase) -> (List.concat (has_write_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
++|Seq'(seq_list) -> (List.concat (has_write_occure_in_seq_complex seq_list varParam c_id counter_man))
++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++                            then [c_id,(get_number_based_on_variable set_var)]
++                            else []
++|Def'(def_var,def_val) -> make_list_of_set_occures def_val varParam c_id counter_man
++|Or'(or_list) -> (List.concat (has_write_occure_in_seq_complex or_list varParam c_id counter_man))
++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++                                then []
++                                else make_list_of_set_occures body varParam (counter_man()) counter_man (* lookoo *)
++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++                                  then []
++                                  else make_list_of_set_occures body varParam (counter_man()) counter_man(* lookoo *)
++|Applic'(proc, args) -> let proc_and_args = proc::args in
++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
++                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
++|_ -> []
++
++(* this function is the read occures in seq but it records what it sees yeahhhh *)
++and  has_write_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
++|[] -> []
++|one::two -> match one with
++            |LambdaSimple'(params, body) -> (make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++            |LambdaOpt'(params, opt, body) ->(make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++            |_ -> (make_list_of_set_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
++;;
++
++
++(* this function gets expression and varParam and checks if we need to box the param *)
++(* let shall_we_box expr varParam =  *)
++let make_box_id_counter() =
++  let x = ref(0) in
++  fun() -> x := !x + 1; !x ;;
++
++let rec make_lambda_params_vars params num = match params with
++|[] -> []
++|_ ->  (make_lambda_params_vars (List.tl params) (num+1))@[VarParam(List.hd (params), num)]
++;;
++(* let papa = make_box_id_counter();; *)
++
++(* "one" is the get and "two" is the set *)
++let does_this_match_require_boxing  cartesian_product =
++          let (one,two) = cartesian_product in
++            if((fst one) = (fst two)) (* if read and write are in differnt closures*)
++            then false
++            else (if ((snd one) = -1 || (snd two) = -1 || (((snd one) = 0 && (snd two) = 0))) (* if both occurences do not refer to same rib *)
++            then true
++            else false)
++
++let is_boxing_needed_2 get_list set_list =
++          let cartesian =   List.concat (List.map (fun e -> List.map (fun e' -> (e,e')) get_list) set_list) in
++          List.exists (fun x -> does_this_match_require_boxing x) cartesian;;
++
++let add_set_tag_to_body_of_lambda expr varParam = match expr with
++|LambdaSimple'(params, Seq'(seq_list)) -> (LambdaSimple'(params, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
++|LambdaSimple'(params, other) -> (LambdaSimple'(params, Seq'([Set'(varParam,Box'(varParam));other])))
++|LambdaOpt'(params, opt, Seq'(seq_list)) -> (LambdaOpt'(params, opt, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
++|LambdaOpt'(params, opt, other) -> (LambdaOpt'(params, opt, Seq'([Set'(varParam,Box'(varParam));other])))
++|_ -> raise X_syntax_error;;
++
++let rec replace_get_set expr varParam = match expr with
++|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
++                  then BoxGet'(var_var)
++                  else Var'(var_var)
++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, replace_get_set box_set_val varParam)
++|If'(test, tCase, fCase) -> If'((replace_get_set test varParam), (replace_get_set tCase varParam), (replace_get_set fCase varParam))
++|Seq'(seq_list) -> Seq'((List.map (fun t -> replace_get_set t varParam) seq_list))
++|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
++                           then (BoxSet'(set_var, replace_get_set set_val varParam))
++                           else Set'(set_var, replace_get_set set_val varParam)
++|Def'(def_var,def_val) -> Def'(def_var,replace_get_set def_val varParam)
++|Or'(or_list) -> Or'((List.map (fun t -> replace_get_set t varParam) or_list))
++|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
++                                then LambdaSimple'(params, body)
++                                else LambdaSimple'(params, (replace_get_set body varParam)) (* lookoo *)
++|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
++                                  then LambdaOpt'(params, opt, body)
++                                  else LambdaOpt'(params, opt, (replace_get_set body varParam)) (* lookoo *)
++|Applic'(proc, args) -> Applic'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
++|ApplicTP'(proc, args) -> ApplicTP'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
++|_ -> expr
++;;
++
++
++
++let actually_do_the_fucking_boxing expr varParam =
++  let expr_with_set_tag = (add_set_tag_to_body_of_lambda expr varParam) in
++  match expr_with_set_tag with
++  |LambdaSimple'(params, body) -> LambdaSimple'(params, replace_get_set body varParam)
++  |_ -> raise X_syntax_error
++  ;;
++
++(* the var list is (bool, the varParam) *)
++let rec actually_do_the_fucking_boxing_2 expr varList = match expr, varList with
++|_, [] -> expr
++|LambdaSimple'(params,body), _ -> if(fst (List.hd varList))
++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda (LambdaSimple'(params,(replace_get_set body (snd (List.hd varList))))) (snd(List.hd varList))) (List.tl varList)
++      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
++|LambdaOpt'(params, opt,body), _ -> if(fst (List.hd varList))
++      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda  (LambdaOpt'(params, opt, (replace_get_set body (snd (List.hd varList)))))(snd(List.hd varList))) (List.tl varList)
++      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
++| _,_ -> raise X_syntax_error;;
++
++let  is_boxing_needed expr varParam =
++  match expr with
++  |LambdaSimple'(params,body)->
++                                let goku = make_box_id_counter() in
++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++                                let goku = make_box_id_counter() in
++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++                                is_boxing_needed_2 get_list set_list
++  |LambdaOpt'(params, opt, body)->
++                                let goku = make_box_id_counter() in
++                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++                                let goku = make_box_id_counter() in
++                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++                                is_boxing_needed_2 get_list set_list
++  |_ -> raise X_syntax_error
++  ;;
++
++ (* let goku = make_box_id_counter() in
++let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
++let goku = make_box_id_counter() in
++let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
++if (is_boxing_needed_2 get_list set_list)
++then (actually_do_the_fucking_boxing expr (varParam))
++else expr *)
++
++
++let gets_lambda_returns_it_boxed expr = match expr with
++|LambdaSimple'(params, body) -> let act_params = make_lambda_params_vars params 0 in
++                               let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
++                               actually_do_the_fucking_boxing_2 expr box_list
++|LambdaOpt'(params, opt, body) ->  let act_params = make_lambda_params_vars (params@[opt]) 0 in
++                                   let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
++                                   actually_do_the_fucking_boxing_2 expr box_list
++|_ -> expr
++;;
++
++let make_lambda_pair expr = match expr with
++|LambdaSimple'(params, body) -> (params, body)
++|_ ->raise X_syntax_error
++
++let make_lambda_triple expr = match expr with
++|LambdaOpt'(params, opt, body) -> (params, opt, body)
++|_ -> raise X_syntax_error
++
++let rec boxer_man expr = match expr with
++|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, boxer_man box_set_val)
++|If'(test, tCase, fCase) -> If'((boxer_man test), (boxer_man tCase ), (boxer_man fCase ))
++|Seq'(seq_list) -> Seq'((List.map (fun t -> boxer_man t ) seq_list))
++|Set'(set_var, set_val) -> Set'(set_var, boxer_man set_val)
++|Def'(def_var,def_val) -> Def'(def_var,boxer_man def_val)
++|Or'(or_list) -> Or'((List.map (fun t -> boxer_man t ) or_list))
++|LambdaSimple'(params, body) -> let (n_params, n_body) =( make_lambda_pair( gets_lambda_returns_it_boxed expr)) in
++                                  LambdaSimple'(n_params, boxer_man n_body)
++|LambdaOpt'(params, opt, body) -> let (n_params, n_opt, n_body ) = (make_lambda_triple (gets_lambda_returns_it_boxed expr)) in
++                                  LambdaOpt'(n_params, n_opt, boxer_man n_body)
++|Applic'(proc, args) -> Applic'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
++|ApplicTP'(proc, args) -> ApplicTP'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
++|_ -> expr
++
++let box_z e varParam= gets_lambda_returns_it_boxed e;;
++
++
++let box_set e = boxer_man e;;
++
++  let run_semantics expr =
+   box_set
+     (annotate_tail_calls
+        (annotate_lexical_addresses expr));;
+-
++
+ end;; (* struct Semantics *)
+
+
+diff --git a/tag-parser.ml b/tag-parser.ml
+index 138249e..942e8bd 100644
+--- a/tag-parser.ml
++++ b/tag-parser.ml
+@@ -57,9 +57,239 @@ let reserved_word_list =
+    "unquote-splicing"];;
+
+ (* work on the tag parser starts here *)
++let rec tag_parse_expression sexpr  = match sexpr with
++| Pair(Symbol("set!"), Pair(var, Pair(expr, Nil))) -> Set(tag_parse_expression var, tag_parse_expression expr)
++| Pair(Symbol("pset!"), pset_sexpr) -> pset_macro_expansion pset_sexpr (* pset macro expansion*)
++| Pair(Symbol("let"), let_sexpr) -> let_tag_parser let_sexpr
++| Pair(Symbol("let*"), let_star_sexpr) -> let_star_tag_parser let_star_sexpr
++| Pair(Symbol("letrec"), letrec_sexpr) -> letrec_tag_parser letrec_sexpr
++| Pair(Symbol("lambda"), lambda_sexpr) -> lambda_tag_parser lambda_sexpr
++| Pair(Symbol("cond"), Pair(rib,ribs)) ->cond_macro_expansion (Pair(rib,ribs)) (** cond_macro_expansion*)
++| Pair(Symbol("if"), if_sexpr)-> if_tag_parser if_sexpr
++| Pair(Symbol("define"), define_sexpr) -> define_tag_parser define_sexpr (*define_macro_expansion(**only MIT Style define has a macro-expansion*)*)
++| Pair(Symbol("begin"), begin_sexpr) -> begin_tag_parser begin_sexpr
++| Pair(Symbol("or"), or_sexpr) -> or_tag_parser or_sexpr
++| Pair(Symbol("and"), Pair( opt1, opts)) -> and_macro_expansion (Pair(opt1, opts))(*and_macro_expansion opt1 opts *)
++| Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
++| Pair(Symbol("quasiquote"), sexpr) -> quasiquote_macro_expansion (sexpr) (* quasiquote macro-expansion*)
++(* | Pair(Symbol(var),Nil) -> Var(var) *)
++| Pair(var, Pair(expr,exprl)) -> Applic(tag_parse_expression var, (tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl)))
++| Number(x) -> Const(Sexpr(Number(x)))
++| Char(x) -> Const(Sexpr(Char(x)))
++| Bool(x) -> Const(Sexpr(Bool(x)))
++| String(x) -> Const(Sexpr(String(x)))
++| Symbol(x) -> Var(x)
++| Pair(x, Nil) -> Applic((tag_parse_expression x),[])
++|_ -> raise X_syntax_error
++
++and cond_macro_expansion_sexpr cond_sexpr = match cond_sexpr with
++|Nil ->  Nil
++|Pair(Pair(Symbol("else"), body),rest) ->  Pair(Symbol("begin"), body)
++|Pair(Pair(expr, Pair(Symbol("=>"),exprf)), rest) ->
++(Pair (Symbol "let",
++Pair
++ (Pair (Pair (Symbol "value", Pair (expr, Nil)),
++   Pair
++    (Pair (Symbol "f",
++      Pair (Pair (Symbol "lambda", Pair (Nil, Pair (exprf, Nil))),
++       Nil)),
++    Pair
++     (Pair (Symbol "rest",
++       Pair
++        (Pair (Symbol "lambda", Pair (Nil, Pair (Symbol "cond-ribs", Nil))),
++        Nil)),
++     Nil))),
++ Pair
++  (Pair (Symbol "if",
++    Pair (Symbol "value",
++     Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
++      Pair (Pair (Symbol "rest", Nil), Nil)))),
++  Nil))))
++  |Pair(Pair(test_case, ribs), rest) ->  Pair(Symbol("if"), Pair(test_case, Pair(Pair(Symbol("begin"), ribs), Pair(cond_macro_expansion_sexpr (rest), Nil))))   (* (ג¨exprג© ג¨expr1ג© ֲ· ֲ· ֲ· ג¨exprmג©) *)
++  | _ -> raise X_syntax_error
++
++
++
++and cond_macro_expansion cond_sexpra = tag_parse_expression (cond_macro_expansion_sexpr cond_sexpra)
++
++
++(* (ג¨exprג© => ג¨exprfג©) *)
++
++
++(* (let ((value Jג¨expr ג©K)
++        (f (lambda () Jג¨exprfג©K))
++(rest (lambda () Jג¨continue with cond-ribsג©K)))
++(if value
++    ((f) value)
++    (rest))) *)
++and pset_macro_expansion pset_sexpr = tag_parse_expression (pset_macro_expansion_sexpr pset_sexpr)
++
++and pset_macro_expansion_sexpr pset_sexpr = match pset_sexpr with
++| Pair(Pair(var, Pair(value, Nil)), Nil) ->  (Pair(Symbol("set!"), Pair(var, Pair(value, Nil))))
++| Pair(Pair(Symbol(var), Pair(value, Nil)), ribs) ->  (Pair(Symbol( "let"), Pair(Pair(Pair(Symbol( "_"^var), Pair(value , Nil)), Nil), Pair(Pair(Symbol( "lambda"), Pair(Nil, Pair(Pair(Symbol( "pset!"), ribs), Nil))), Pair(Pair(Symbol( "set!"), Pair(Symbol(var), Pair(Symbol( "_"^var), Nil))), Nil)))))
++| _ -> raise X_syntax_error
++(* (Pair(Symbol("let"), Pair(Pair(Pair(Symbol("_v1"), Pair(value, Nil)), Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(Symbol("pset!"), Pair(ribs, Nil)), Nil))), Nil)), Nil)), Pair(Pair(Symbol("rest"), Nil), Pair(Pair(Symbol("set!"), Pair(var, Pair(Symbol("_v1"), Nil))), Nil))))) *)
++(* let  a = (Printf.printf "arrived here") in  *)
++
++(* and heart_of_quasiquote q_sexpr = match q_sexpr with
++| *)
++
++and quasiquote_macro_expansion q_sexpr = match q_sexpr with
++| Pair (Pair (Pair (Symbol "unquote", Pair (sexpr, Nil)), Nil), Nil) -> Applic (Var "cons", [tag_parse_expression( sexpr); Const (Sexpr Nil)])
++| Pair (Pair (Pair (Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil), Nil) -> Const(Sexpr(Pair(Symbol("quote"), q_sexpr)))
++(* | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil) -> raise X_syntax_error *)
++| Nil -> Const(Sexpr(Pair(Symbol("quote"), Nil)))
++| Pair (Pair (Symbol(s1), Nil), Nil)  -> Const(Sexpr(Pair(Symbol("quote"), Symbol(s1))))
++| _ -> raise X_syntax_error
++(* | Pair(Pair(Pair(Symbol("unquote-splicing"), sexa)), B) ->  *)
++
++and and_macro_expansion and_sexpr = match and_sexpr with
++| Nil -> Const(Sexpr(Bool(true)))
++| Pair(op, Nil)-> tag_parse_expression op
++| Pair(op1, opts) -> If(tag_parse_expression op1, and_macro_expansion opts, Const(Sexpr(Bool(false))))
++| _ -> raise X_syntax_error
++
++and or_tag_parser or_sexpr = match or_sexpr with
++| Nil -> Or([])
++| Pair(expr, Nil) -> tag_parse_expression expr
++| Pair(expr, exprl) -> Or(((tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl))))
++| _ -> raise X_syntax_error
++
++and rib_varu_maker rimbs = match rimbs with
++|Nil -> Nil
++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(varu, Nil)
++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(varu, rib_varu_maker (rimbs2))
++|_ -> raise X_syntax_error
++
++and rib_valu_maker rimbs = match rimbs with
++|Nil -> Nil
++|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(valu, Nil)
++|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(valu, rib_valu_maker rimbs2)
++| _ -> raise X_syntax_error
++
++and let_tag_parser let_sexpr = match let_sexpr with
++| Pair(Nil, body) ->  tag_parse_expression (Pair(Pair(Symbol("lambda"),Pair(Nil, body)), Nil))
++| Pair(Pair(rib, ribs), body) ->  tag_parse_expression( Pair(Pair(Symbol("lambda"),Pair(rib_varu_maker (Pair(rib, ribs)), body )),rib_valu_maker (Pair(rib,ribs))))
++| _ -> raise X_syntax_error
++and let_star_tag_parser_sexpr let_star_sexpr = match let_star_sexpr with
++| Pair(Nil, body) -> (Pair (Symbol("let"), let_star_sexpr))
++| Pair(Pair(rib, Nil), body)->(Pair (Symbol("let"), let_star_sexpr))
++| Pair(Pair(rib,ribs), body) ->  (Pair(Symbol("let"), Pair(Pair(rib,Nil), let_star_tag_parser_sexpr ((Pair(ribs, body)))))) (* let* macro-expansion*)
++|_ -> raise X_syntax_error
++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
++
++and let_star_tag_parser let_star_sexpr = match let_star_sexpr with
++| Pair(Nil, body) -> tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
++| Pair(Pair(rib, Nil), body)->tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
++| Pair(Pair(rib,ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib,Nil), Pair(Symbol("let*"), Pair(ribs, body))))) (* let* macro-expansion*)
++| _ -> raise X_syntax_error
++(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
++
++and create_set_sexprs ribs body= match ribs with
++| Pair(Nil,Nil) -> Nil
++| Pair(Pair(var,Pair(value,Nil)),Nil) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), body)
++| Pair(Pair(var,Pair(value,Nil)),rest) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), (create_set_sexprs rest body ))
++| _ -> raise X_syntax_error
++
++and  letrec_tag_parser letrec_sexpr = match letrec_sexpr with
++| Pair(Nil, body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Nil, Pair(body, Nil))))
++| Pair(Pair(rib, ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib, ribs), (create_set_sexprs (Pair(rib,ribs)) body ))))(*letrec_macro_expansion rib ribs body*)
++| _ -> raise X_syntax_error
++
++and checkArguments args =
++match args with
++| Pair(Symbol("vs"), Nil) -> variadic_lambda
++| Pair(arg, Nil) -> simple_lambda_tag_parser
++| Pair(arg1, Symbol(opt)) -> (opt_lambda_tag_parser opt )
++| Pair(arg1,rest) -> checkArguments rest
++| _ -> raise X_syntax_error
++
++and create_string_arr sList = match sList with
++| Symbol(vs) -> []
++| Pair(Symbol(last), Nil) -> [last]
++| Pair(Symbol(str1), b) -> str1::create_string_arr b
++| Nil -> []
++| _ -> raise X_syntax_error
++
++and makeSequence expr_list = Seq(flattenSequence (List.map tag_parse_expression (sexpr_to_list expr_list)))
++
++and simple_lambda_tag_parser lambda_sexpr =
++match lambda_sexpr with
++| Pair (args, Pair(expr, Nil)) ->  LambdaSimple((create_string_arr args),tag_parse_expression expr)
++| Pair( args,expr_list) ->  LambdaSimple((create_string_arr args), makeSequence expr_list)(* simple*)
++| _ -> raise X_syntax_error
++
++and opt_lambda_tag_parser opt lambda_sexpr =
++match lambda_sexpr with
++| Pair(args, Pair(expr, Nil)) -> LambdaOpt((create_string_arr args), opt, tag_parse_expression expr)(* opt*)
++| Pair(args, expr_list) -> LambdaOpt((create_string_arr args), opt, makeSequence expr_list)(* opt*)
++| _ -> raise X_syntax_error
++
++and variadic_lambda lambda_sexpr =
++match lambda_sexpr with
++| Pair(Pair(Symbol("vs"),Nil), Pair(expr, Nil)) ->  LambdaOpt([], "vs", tag_parse_expression expr)(* opt*)
++| Pair(Pair(Symbol("vs"),Nil), expr_list) -> LambdaOpt([], "vs", makeSequence expr_list)(* opt*)
++| _ -> raise X_syntax_error
++and lambda_tag_parser lambda_sexpr = match lambda_sexpr with
++|Pair(Nil, expr) -> simple_lambda_tag_parser lambda_sexpr
++|Pair(args, expr) -> (checkArguments args) lambda_sexpr
++|_ -> raise X_syntax_error
++
++
++and define_tag_parser define_sexpr = match define_sexpr with
++| Pair (Pair (var, arglist), Pair (exprs, Nil)) -> tag_parse_expression (Pair(Symbol "define", Pair(var, Pair(Pair(Symbol "lambda", Pair(arglist, Pair(exprs, Nil))), Nil))))
++| Pair(name, Pair(expr, Nil)) -> Def(tag_parse_expression name,  tag_parse_expression expr )
++| _ -> raise X_syntax_error
++(* Pair(Symbol "define", Pair(Pair(Symbol "var", Symbol "arglist"), Pair(Symbol "expr+", Nil))) *)
++
++and sexpr_to_list pair_list = match pair_list with
++| Nil  -> []
++| Pair(a , b) -> a:: (sexpr_to_list b)
++|_ -> raise X_syntax_error
++
++and  flattenSequence  expr_list_2 =
++  List.fold_left (fun acc expr -> match expr with
++  | Seq(lst) -> acc@lst
++  (* | Const(void) -> []  *)
++  | _ -> acc@[expr]) [] expr_list_2
++and begin_tag_parser begin_sexpr =
++  match begin_sexpr with
++| Nil-> Const (Void)
++| Pair(a, Nil) -> tag_parse_expression a
++| sexprs -> Seq (flattenSequence (List.map tag_parse_expression ( sexpr_to_list sexprs)))
++
++and if_tag_parser if_sexpr = match if_sexpr with
++| Pair(test, Pair(dit, Pair(dif, Nil)))->
++  If(tag_parse_expression test, tag_parse_expression dit, tag_parse_expression dif)
++| Pair(test, Pair(dit,Nil))->
++  If(tag_parse_expression test, tag_parse_expression dit, Const (Void))
++|_ -> raise X_syntax_error;;
++
++let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;
+
+-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+
+-
+ end;; (* struct Tag_Parser *)
+
++(*
++(define sexpr->ocaml-string
++(lambda(e)
++(cond
++((boolean? e)
++(if e "Bool true" "Bool false"))
++((null? e) "Nil")
++((char? e) (  format "Char '~a'" e))
++((symbol? e) (  format "Symbol \"~a\"" e))
++((string? e) (  format "String \"~a\"" e) )
++((flonum? e) (  format "Number (Float ~a)" e))
++((integer? e) (  format "Number (Fraction(~a, 1))" e))
++((ratnum? e)
++(format "Number (Fraction(~a, ~a))" (numeratore) (denominatore)))
++((pair? e)
++(format "Pair(~a, ~a)"
++(sexpr->ocaml-string (car e))
++(sexpr->ocaml-string (cdr e))))
++(else(error 'sexpr->ocaml-string
++(format "Unsupported type: ~a" e))))))
++(define print-template
++(lambda(sexpr)(display(sexpr->ocaml-string sexpr))))
++(print-template'(let (rib . ribs) body)) *)
+\ No newline at end of file
diff --git a/reader.ml b/reader.ml
index 32445c2..24c92e3 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,5 @@
-
 #use "pc.ml";;
+open PC;;

 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -17,18 +17,20 @@ type sexpr =
   | Symbol of string
   | Pair of sexpr * sexpr;;

-let rec sexpr_eq s1 s2 =
-  match s1, s2 with
-  | Bool(b1), Bool(b2) -> b1 = b2
-  | Nil, Nil -> true
-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
-  | Char(c1), Char(c2) -> c1 = c2
-  | String(s1), String(s2) -> s1 = s2
-  | Symbol(s1), Symbol(s2) -> s1 = s2
-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
-  | _ -> false;;

+  let rec sexpr_eq s1 s2 =
+    match s1, s2 with
+    | Bool(b1), Bool(b2) -> b1 = b2
+    | Nil, Nil -> true
+    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+    | Char(c1), Char(c2) -> c1 = c2
+    | String(s1), String(s2) -> s1 = s2
+    | Symbol(s1), Symbol(s2) -> s1 = s2
+    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+    | _ -> false;;
+
+
 module Reader: sig
   val read_sexprs : string -> sexpr list
 end
@@ -40,7 +42,274 @@ let normalize_scheme_symbol str =
 	s) then str
   else Printf.sprintf "|%s|" str;;

+let packOnFirst nt f s =
+  let (e, s) = (nt s) in
+  (f e);;

-let read_sexprs string = raise X_not_yet_implemented;;
+let packOnSecond nt f s =
+  let (e, s) = (nt s) in
+  (f s);;

+let notChar = make_char (fun ch1 ch2 -> ch1 != ch2);;
+
+
+
+let newLineParsaPred = packOnFirst   (caten (char '\\') (char 'n')) (fun _ ->  false);;
+
+(* let newLineParsa = pack (caten (char '\\') (char 'n')) (fun (e,s) -> s);; *)
+let newLineParsa = char '\n';;
+
+let nt_whitespaces = star (char ' ');;
+
+
+let make_paired nt_left nt_right nt =
+let nt = caten nt_left nt in
+let nt = pack nt (function (_, e) -> e) in
+let nt = caten nt nt_right in
+let nt = pack nt (function (e, _) -> e) in
+nt;;
+
+let make_spaced nt =
+  make_paired nt_whitespaces nt_whitespaces nt;;
+
+let semicolonParser = char ';';;
+
+
+(* let notNewLineParser = packOnFirst( (const (newLineParsaPred))) (fun ch -> ch);; *)
+let notNewLineParser  = const(fun p -> p!= '\n');;
+(* let notNewLineParser = (const(fun p -> p!= "\\n")) ;; *)
+(* let notNewLineParser = let nt = word "\\n" in
+                       let nt = ;; *)
+(* let notNewLineParser  = try word "\\n"
+                        with X_no_match  ->  nt_any
+                          ;; *)
+
+
+
+
+(* let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');; *)
+let notNewLineParser2 = (star (notNewLineParser)) ;;
+(* this check as long as there is no new line *)
+
+let make_line_comment_parser_paired  =
+  let nt = caten semicolonParser notNewLineParser2 in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt newLineParsa in
+  let nt = packOnSecond nt (function e ->  (e,e)) in
+  nt;;
+
+
+(* let lineCommentParser = make_spaced ( pack (caten   semicolonParser (caten (star notNewLineParser)  newlineParser)) (fun _ -> [' '])  );; *)
+
+
+(* Boolean, dot, CharPrefix, Digit,Natural,  Fraction, Float*)
+let backSlashParser = char '\\';;
+let hashParser = char '#';;
+
+(*
+⟨Boolean⟩::= #f | #t
+*)
+let booleanParser = make_spaced( PC.pack (PC.caten hashParser (PC.disj (PC.char_ci 't') (PC.char_ci 'f') ))
+        (fun (_, ch) -> if ch = 't' || ch = 'T' then Bool true else Bool false));;
+
+(* digit => Natural => Integer => Fraction => Float => *)
+let digitParser  = range '0' '9';;  (* Parses all numbers between 0-9 <digit> *)
+let digitSeqParser = (plus digitParser);;(* <digit>+ *)
+let naturalParser = pack digitSeqParser (fun str ->  (int_of_string(list_to_string str)));;(*Turns a list of chars of numbers into a natural number*)
+
+
+let maybeMinusPlusParser = (* Parses  (+|-)? and returns -1 if the char that is parsed is - and 1 otherwise *)
+  let plusParser = pack (char '+') (fun _ -> 1) in  (*returns 1*)
+  let minusParser =  pack (char '-') (fun _ -> -1) in (*returns -1*)
+  pack (maybe(disj plusParser minusParser)) (fun opt -> match opt with Some(e) -> e | None -> 1);;
+
+let integerParser = pack (caten maybeMinusPlusParser naturalParser) (fun (e,s) -> e*s);; (* <Integer> catens the (+|-)? with natural number and multiplies the outputs  *)
+
+let rec gcd a b = (*returns greates commod divisor of a and b *)
+  if b = 0 then a else gcd b (a mod b);;
+
+let fractionParser = (*<Fraction> = <Integer> / <Natural> *)
+  let fractionPar = pack( caten( caten integerParser (char '/')) naturalParser) (fun ((i, d), n) ->
+  let div = gcd i n in (*gets gcd if the numerator and denominator*)
+  Fraction (i/div, n/div)) in  (*makes the smallest number of an integer and natural number*)
+  let integerToFraction = pack integerParser (fun num -> Fraction (num, 1)) in (*an Integer is parsed into a Fraction with 1 as the denominator*)
+    disj fractionPar integerToFraction ;;
+
+let mantissaParser = pack digitSeqParser (fun lst -> (* parses a list of digit chars to a mantissa*)
+  let with0 = String.concat "" ["0."; (list_to_string lst)] in (*before the char list is turned into a float, the list ['0';'.'] is concatenated before it so the number will stay as a mantissa *)
+  float_of_string with0);;
+
+let floatParser string = pack( caten( caten integerParser (char '.')) mantissaParser) (fun ((i, d), m) -> (*<Float> = ⟨Integer⟩.⟨Natural⟩*)
+   if i > 0 then  (float_of_int i)+.m (*connect the integer with a mantissa *)
+   else if i==0 && List.nth string 0 != '-'  then (float_of_int i) +. m
+   else (float_of_int i) -. m) string;;
+
+let scientificNotationParser = (* The scientic notation is of the form of (integer | float) e|E integer*)
+    let integerAndFloat = disj  floatParser (pack integerParser (fun num ->  float_of_int num ))  in  (** returns a Float, if the num is int it makes a Float of it*)
+    let e = pack (char_ci 'e') (fun _ -> Nil) in
+    pack( caten( caten integerAndFloat e) integerParser) (fun ((num, d), pow) -> num *. 10.0 ** (float_of_int pow));;
+let numberParser = make_spaced( pack (disj (pack (disj scientificNotationParser floatParser) (fun fl -> Float fl) ) fractionParser) (fun num -> Number num ));; (* (scientifNotation | Float | Fraction)*)
+
+
+let charPrefixParser = pack (caten hashParser backSlashParser) (fun _ -> Nil);;
+
+let visibleCharParser = pack (const (fun p -> p > ' ')) (fun ch -> Char ch);;
+
+let nulParser = pack( word_ci "nul") (fun _ -> Char (char_of_int 0));;
+let newlineParser = pack( word_ci "newline") (fun _ -> Char (char_of_int 10));;
+let returnParser = pack( word_ci "return") (fun _ -> Char (char_of_int 13));;
+let tabParser = pack( word_ci "tab") (fun _ -> Char (char_of_int 9));;
+let formfeedParser = pack( word_ci "page") (fun _ -> Char (char_of_int 12));;
+let spaceParser = pack( word_ci "space") (fun _ -> Char (char_of_int 32));;
+
+
+let namedCharParser = disj_list  [nulParser; newlineParser; returnParser; tabParser; formfeedParser; spaceParser];;
+
+let charParser = make_spaced( pack (caten charPrefixParser (disj namedCharParser visibleCharParser)) (fun (_, ch) -> ch));;
+
+(* need to add named char*)
+
+
+let dotParser string= pack (guard (char '.') (fun _ -> List.length(string) > 1))(fun _ -> ".") string;; (**doest parse if . is alone *)
+let symbolCharNoDotParser = (*Parses all the chars that are not a dot and turns them into a string*)
+    let letter_ciParser = pack(range_ci 'a' 'z') (fun ch -> lowercase_ascii ch) in
+    let punctuationParser = one_of "!$^*-_=:+<>/?" in
+    pack (disj_list [digitParser ; letter_ciParser ; punctuationParser]) (fun sym -> String.make 1 sym);;
+let symbolCharParser = disj symbolCharNoDotParser dotParser;; (*(<dot> | <symbolCharNoDot>)*)
+let symbolParser =
+    let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in (*<symbolChar><symbolChar>+, connects the strings of the symbols *)
+    let symbolParserWithoutNumber = (disj withDotParser symbolCharNoDotParser) in
+    pack symbolParserWithoutNumber (fun str ->
+    try (let (e,s) = numberParser (string_to_list str) in
+    if s == [] then e else Symbol(str))
+    with X_no_match -> Symbol(str));; (*Constructs a symbol with a string*)
+
+ (* let symbolParserWithoutNumber =
+  let withDotParser = make_spaced( pack (caten symbolCharParser (plus symbolCharParser))(fun (e,s) -> String.concat "" (e::s))) in
+  disj withDotParser symbolCharNoDotParser;;
+let symbolParser string=
+  let parsedBySymbol = symbolParserWithoutNumber
+  try (let number = numberParser )  *)
+
+
+let gershaimParser = PC.char '"';;
+
+let stringLiteralCharParser = const (fun p -> p != '\\' && p!= '"');;
+
+let returnStringMetaCharParser = pack (char_ci 'r') (fun _ -> char_of_int 13)
+let newlineStringMetaCharParser = pack (char_ci 'n') (fun _ -> char_of_int 10)
+let tabStringMetaCharParser = pack (char_ci 't') (fun _ -> char_of_int 9)
+let pageStringMetaCharParser = pack (char_ci 'f') (fun _ -> char_of_int 12)
+let backslashStringMetaCharParser = pack (char_ci '\\') (fun _ -> char_of_int 92)
+let gershaimStringMetaCharParser = pack (char_ci '"') (fun _ -> char_of_int 34)
+
+let stringMetaCharParser = pack (caten backSlashParser (disj_list [returnStringMetaCharParser;
+                                      newlineStringMetaCharParser;
+                                      tabStringMetaCharParser;
+                                      pageStringMetaCharParser;
+                                      backslashStringMetaCharParser;
+                                      gershaimStringMetaCharParser]) ) (fun (_, ch) -> ch);;
+
+let stringCharParser = disj stringMetaCharParser stringLiteralCharParser;;
+
+let stringParser = make_spaced( pack (caten (caten gershaimParser (star stringCharParser)) gershaimParser)
+                      (fun ((_, lst), _) -> String (list_to_string lst)) );;
+
+(* let numberParser = pack (disj floatParser fractionParser) (fun num -> Number num );; *)
+(* bad number parser *)
+
+let openParenthasisParser = char '(';;
+let closedParenthasisParser = char ')';;
+
+
+(* let emptyListParser = make_spaced( pack (make_paired openParenthasisParser closedParenthasisParser (caten (disj nt_whitespaces make_line_comment_parser_paired) nt_whitespaces)) (fun _ -> Nil) ) *)
+
+
+
+(* let emptyListParser = pack(make_line_comment_parser_paired) (fun _-> Nil) ;;  *)
+
+(* let singleQuoteParser = char ''';;
+let quoteParser =  make_spaced( pack (  caten singleQuoteParser read_   ) (fun  )  );;
+
+let quotingParser = NUL;; *)
+
+let veryGoodDotParser = pack(char '.') (fun ch -> Char ch) ;;
+
+
+let rec starush nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (starush nt s) in
+      (Pair(e,es), s)
+  with X_no_match -> (Nil, s);;
+
+
+let rec starush2 nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (starush nt s) in
+      (Pair(e,es), s)
+  with X_no_match ->
+                     try let ((e,e2),s) = (caten veryGoodDotParser nt) s in
+                     (e2,s)
+                     with X_no_match -> (Nil, s);;
+
+let plusush nt =
+  pack (caten nt (starush nt))
+        (fun (e, es) -> (Pair(e,es)));;
+
+
+let rec read_sexpr paparapa=
+  let rec improperSecondArgumentParser = pack ( make_spaced( (caten veryGoodDotParser (caten nt_whitespaces read_sexpr )  ))) (fun (_,(_,e)) ->  e)
+  and
+
+  starushu nt s =
+    try let (e, s) = (nt s) in
+        let (es, s) = (disj (improperSecondArgumentParser) (starushu nt ) ) s in
+        (Pair(e,es), s)
+    with X_no_match -> (Nil, s)
+  in
+
+   let rec listParser = pack( (caten openParenthasisParser (caten  (disj (starushu (make_spaced read_sexpr)) (starush (make_spaced read_sexpr))) closedParenthasisParser)  )) (fun (_,(e,_)) -> e)
+   (* let listParser = pack( make_spaced( caten openParenthasisParser (caten read_sexpr (caten (disj_list [improperSecondArgumentParser; noSecondItemInPairParser; secontItemInPairParser] ) closedParenthasisParser ))) ) (fun (_,(ent1,( ent2, _))) -> Pair(ent1, ent2)) *)
+  and
+
+   lineCommentParser = pack (make_line_comment_parser_paired) (fun _ -> Nil)
+  and sexpCommentParser = pack (caten (char '#')  (caten (char ';') read_sexpr )) (fun _ -> Nil)
+  in let commentParser = (pack (make_spaced(disj sexpCommentParser lineCommentParser ))) (fun _ -> Nil)
+  in let emptyListParser = pack((caten openParenthasisParser (caten (star commentParser) closedParenthasisParser))) (fun _ -> Nil)
+  in let quoteParser = pack( (caten (make_spaced(char (char_of_int 39))) read_sexpr)) (fun (e,s) -> Pair(Symbol("quote"),Pair(s,Nil)))
+  in let qQuoteParser =  pack( (caten (make_spaced(char '`')) read_sexpr)) (fun (e,s) -> Pair(Symbol("quasiquote"),Pair(s,Nil)))
+  in let unQuoteParser =  pack( (caten (make_spaced(char ',')) read_sexpr)) (fun (e,s) -> Pair(Symbol("unquote"),Pair(s,Nil)))
+  in let unQuoteSplicingParser =  pack( caten (make_spaced(caten (char ',') (char '@'))) read_sexpr) (fun (e,s) -> Pair(Symbol("unquote-splicing"),Pair(s,Nil)))
+
+  in pack (caten (star commentParser) (caten (disj_list [quoteParser; qQuoteParser; unQuoteParser; unQuoteSplicingParser; emptyListParser;listParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star commentParser))) (fun (_,(s,_)) -> s)
+  paparapa
+  ;;
+
+
+(* let rec read_sexpr =
+  pack (caten (star sexpCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star sexpCommentParser))) (fun (_,(s,_)) -> s)
+  and lineCommentParser = (pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil) )
+  and sexpCommentParser  = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr ))) (fun _ -> Nil)
+  ;; *)
+
+(* let lineCommentParser = pack (make_spaced( make_line_comment_parser_paired)) (fun _-> Nil);; *)
+
+(* let sexpCommentParser = pack (make_spaced( caten (char '#')  (caten (char ';') read_sexpr)) (fun _ -> Nil);; *)
+
+(* let rec read_sexpr =   pack (caten (star lineCommentParser) (caten (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser]) (star lineCommentParser))) (fun (_,(s,_)) -> s)  ;; *)
+(* (fun c -> match c with
+| Nil -> []
+| _ -> c) ;; *)
+
+(* let read_sexpr =
+
+  try pack( caten commentParser (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])) (fun (e,s) -> s)
+  with X_no_match ->  try pack( caten  (disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser])commentParser ) (fun (e,s) -> e)
+    with X_no_match -> disj_list [emptyListParser; booleanParser ;symbolParser;numberParser; charParser; stringParser];; *)
+(* let read_sexpr str = disj_list [booleanParser ; charParser ; numberParser ; stringParser ; symbolParser ] *)
+
+let read_sexprs string = let (e,s) = (caten (star read_sexpr) nt_end_of_input ) (string_to_list string) in
+            let (e2, s2)= e in
+             e2;;
 end;; (* struct Reader *)
+
diff --git a/readme.txt b/readme.txt
index e69de29..710c26c 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Itay Almoznino 318911187
+Tommer Federman 212198378
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..21afec3 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
                                             (expr'_eq th1 th2) &&
                                               (expr'_eq el1 el2)
@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;
-
+  | _ -> false;;
+
+
 exception X_syntax_error;;

 module type SEMANTICS = sig
@@ -65,21 +57,397 @@ module type SEMANTICS = sig
   val annotate_lexical_addresses : expr -> expr'
   val annotate_tail_calls : expr' -> expr'
   val box_set : expr' -> expr'
-end;;
+  end;;

 module Semantics : SEMANTICS = struct
+(*How the function works- for each lambda of depth n, i create n counters that count the minor number of vars for each bound var,
+for that n counters are needed, except of that, i keep all the params of the lambdas in a 2d-list*)
+let rec parse_expr_to_expr' expr env_param_list  =
+  let callParse expr = parse_expr_to_expr' expr env_param_list in
+  let parseVar str = parse_to_var str env_param_list in
+  match expr with
+| Const(sexpr) -> Const'(sexpr)
+| Var(str) ->   Var'(parseVar str)
+| If(e1,e2,e3) ->  If'(callParse e1 ,callParse e2,callParse e3 )
+| Seq(exprl) -> Seq'(List.map callParse exprl)
+| Set(Var(str),expr2) ->  Set'(parseVar str ,callParse expr2 )
+| Def(Var(str), expr2) ->  Def'(parseVar str, callParse expr2)
+| Or(exprl) -> Or'(List.map callParse exprl)
+| LambdaSimple(strl, expr) -> LambdaSimple'(strl, parse_expr_to_expr' expr ((strl:: env_param_list)) )
+| LambdaOpt(strl, opt, expr) -> LambdaOpt'(strl, opt, parse_expr_to_expr' expr ((strl@[opt])::env_param_list) )
+| Applic(expr, exprl) -> Applic'(callParse expr,List.map callParse exprl)
+|_ -> raise X_syntax_error
+(* test - LambdaSimple (["x"], Applic (Var "x",[LambdaSimple (["y"],Applic (Var "x",[Var "y"; LambdaSimple (["z"], Applic (Var "x", [Var "y"; Var "z"]))]))])) *)
+and get_index_of_arr str env_params ind =
+  let nth = List.nth env_params ind in
+  if ind > List.length env_params then -1
+  else if List.exists (fun x -> x = str) nth then ind
+  else get_index_of_arr str env_params (ind+1)

-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+(* and make_counter() =
+  let x = ref(-1) in
+  fun() -> x := !x + 1; !x  *)

-let annotate_tail_calls e = raise X_not_yet_implemented;;
+and printList lst = match lst with
+| hd :: tl ->  "["^(stringList hd)^"];"^(printList tl)
+| [] -> ""

-let box_set e = raise X_not_yet_implemented;;
+and stringList strl = match strl with
+| hd ::tl -> (hd)^";"^(stringList tl)
+| [] -> ""

-let run_semantics expr =
+and get_index_of_var_in_env var var_arr ind=
+  let nth = (List.nth (var_arr) ind) in
+  if (nth = var) then ind
+  else get_index_of_var_in_env var var_arr (ind+1)
+
+and parse_to_var str env_params =
+  let major_count =
+    if (not (List.exists (List.exists (fun x -> str = x)) env_params)) then -1 (* no lambda params has the str and so it is free *)
+    else get_index_of_arr str env_params 0
+    in
+    (* (Printf.printf "params [%s]" (printList env_params)) ; *)
+  match major_count with
+  | -1 -> VarFree(str)
+  | 0 -> VarParam(str, get_index_of_var_in_env str (List.nth env_params major_count) 0)
+  | n -> VarBound(str, major_count-1, get_index_of_var_in_env str (List.nth env_params major_count) 0);;
+let annotate_lexical_addresses e = parse_expr_to_expr' e [];;
+
+
+let rec annotate_tp e tp = match e with (* https://www.cs.bgu.ac.il/~comp151/wiki.files/ps8.pdf*)
+| Const'(cons) -> e
+| Var'(v) -> e
+| If'(test, dit, dif) -> If'(annotate_tp test false, annotate_tp dit tp, annotate_tp dif tp)
+| Seq'(expl) -> Seq'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
+| Set'(v, exp) -> Set'(v,annotate_tp exp false)
+| Def'(v, exp) -> Def'(v, annotate_tp exp  false)
+| Or'(expl) -> Or'(List.mapi (fun ind x -> if ind == ((List.length expl)-1) then annotate_tp x tp else annotate_tp x false) expl)
+| LambdaSimple'(strl, exp) -> LambdaSimple'(strl,  annotate_tp exp true)
+| LambdaOpt'(strl, opt, exp) -> LambdaOpt'(strl, opt, annotate_tp exp true)
+| Applic'(exp, expl) -> if tp then ApplicTP'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
+                        else Applic'(annotate_tp exp false, List.map (fun x -> annotate_tp x false) expl)
+|_ -> raise X_syntax_error;;
+let annotate_tail_calls e = annotate_tp e false;;
+
+(* type var =
+  | VarFree of string
+  | VarParam of string * int
+  | VarBound of string * int * int;; *)
+
+
+
+
+let name_of_var v = match v with
+|VarFree(s) -> s
+|VarParam(s, _) -> s
+|VarBound(s,_,_) -> s
+;;
+
+let get_number_based_on_variable var = match var with
+|VarParam(s, minor) -> -1
+|VarBound(s, major, minor) -> major
+|_ -> raise X_syntax_error
+;;
+
+(* receives an expression expr and var varParam, and boxes all occurences of the var,
+ this function will be called at step 2 of boxing in closures*)
+
+let check_if_var_is_in_param_list params varName = match params with
+|[] -> false
+|_ -> List.exists (fun t -> t = varName) params;;
+
+let is_read_occure expr varParam = match expr with
+|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+                  then true
+                  else false
+|_ -> false
+;;
+
+let rec has_read_occure expr varParam = match expr with
+|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+                  then true
+                  else false
+|Box'(box_var) -> has_read_occure (Var'(box_var)) varParam
+|BoxSet'(box_set_var, box_set_val) -> has_read_occure box_set_val varParam
+|If'(test, tCase, fCase) -> has_read_occure_in_seq ([test]@[tCase]@[fCase]) varParam
+|Seq'(seq_list) -> has_read_occure_in_seq seq_list varParam
+|Set'(set_var, set_val) -> has_read_occure set_val varParam
+|Def'(def_var,def_val) -> has_read_occure def_val varParam
+|Or'(or_list) -> has_read_occure_in_seq or_list varParam
+|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+                                then false
+                                else has_read_occure body varParam (* lookoo *)
+|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+                                  then false
+                                  else has_read_occure body varParam (* lookoo *)
+|Applic'(proc, args) -> let proc_and_args = proc::args in
+                              has_read_occure_in_seq proc_and_args varParam
+|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+                              has_read_occure_in_seq proc_and_args varParam
+|_ -> false
+
+and  has_read_occure_in_seq expr_list varParam = match expr_list with
+|[] -> false
+|_ -> List.exists (fun t -> has_read_occure t varParam) expr_list;;
+
+let is_write_occure expr varParam = match expr with
+|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+                           then true
+                           else false
+|_ -> false
+;;
+(* returns true if the expression is a write occure of the var *)
+
+let rec has_write_occure expr varParam = match expr with
+|BoxSet'(box_set_var, box_set_val) -> has_write_occure box_set_val varParam
+|If'(test, tCase, fCase) -> has_write_occure_in_seq ([test]@[tCase]@[fCase]) varParam
+|Seq'(seq_list) -> has_write_occure_in_seq seq_list varParam
+|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+                           then true
+                           else false
+|Def'(def_var,def_val) -> has_write_occure def_val varParam
+|Or'(or_list) -> has_write_occure_in_seq or_list varParam
+|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+                                then false
+                                else has_write_occure body varParam (* lookoo *)
+|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+                                  then false
+                                  else has_write_occure body varParam (* lookoo *)
+|Applic'(proc, args) -> let proc_and_args = proc::args in
+                         has_write_occure_in_seq proc_and_args varParam
+|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+                          has_write_occure_in_seq proc_and_args varParam
+|_ -> false
+
+
+
+and  has_write_occure_in_seq expr_list varParam = match expr_list with
+|[] -> false
+|_ -> List.exists (fun t -> has_write_occure t varParam) expr_list;;
+
+(* this function gets:
+   # expr- of type expr'
+   # varParam- of type VarParam
+   # c_id - closure id which signifies the closure we are in. the importance of this is that
+   we can check the first condition of boxing with it
+   # a counter!!!! starts at 0
+
+  the function returns a list of all the get occurences for each occurence it gives:
+   # c_id - closure id
+   # depth - the depth of the variable read. if it is of type VarParam then -1.
+   if it is of type bound then the value of the major
+
+   *)
+
+let rec make_list_of_get_occures expr varParam c_id counter_man = match expr with
+|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+                  then [c_id,(get_number_based_on_variable var_var)]
+                  else []
+|Box'(box_var) ->  make_list_of_get_occures (Var'(box_var)) varParam c_id counter_man
+|BoxSet'(box_set_var, box_set_val) -> make_list_of_get_occures box_set_val varParam c_id counter_man
+|If'(test, tCase, fCase) -> (List.concat (has_read_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
+|Seq'(seq_list) -> (List.concat (has_read_occure_in_seq_complex seq_list varParam c_id counter_man))
+|Set'(set_var, set_val) -> make_list_of_get_occures set_val varParam c_id counter_man
+|Def'(def_var,def_val) -> make_list_of_get_occures def_val varParam c_id counter_man
+|Or'(or_list) -> (List.concat (has_read_occure_in_seq_complex or_list varParam c_id counter_man))
+|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+                                then []
+                                else make_list_of_get_occures body varParam (counter_man()) counter_man (* lookoo *)
+|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+                                  then []
+                                  else make_list_of_get_occures body varParam (counter_man()) counter_man(* lookoo *)
+|Applic'(proc, args) -> let proc_and_args = proc::args in
+                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+                              (List.concat (has_read_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+|_ -> []
+
+(* this function is the read occures in seq but it records what it sees yeahhhh *)
+and  has_read_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
+|[] -> []
+|one::two -> match one with
+            |LambdaSimple'(params, body) -> (make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+            |LambdaOpt'(params, opt, body) ->(make_list_of_get_occures (List.hd expr_list) varParam c_id counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+            |_ -> (make_list_of_get_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_read_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+;;
+
+
+
+let rec make_list_of_set_occures expr varParam c_id counter_man = match expr with
+|BoxSet'(box_set_var, box_set_val) -> make_list_of_set_occures box_set_val varParam c_id counter_man
+|If'(test, tCase, fCase) -> (List.concat (has_write_occure_in_seq_complex ([test]@[tCase]@[fCase]) varParam c_id counter_man))
+|Seq'(seq_list) -> (List.concat (has_write_occure_in_seq_complex seq_list varParam c_id counter_man))
+|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+                            then [c_id,(get_number_based_on_variable set_var)]
+                            else []
+|Def'(def_var,def_val) -> make_list_of_set_occures def_val varParam c_id counter_man
+|Or'(or_list) -> (List.concat (has_write_occure_in_seq_complex or_list varParam c_id counter_man))
+|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+                                then []
+                                else make_list_of_set_occures body varParam (counter_man()) counter_man (* lookoo *)
+|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+                                  then []
+                                  else make_list_of_set_occures body varParam (counter_man()) counter_man(* lookoo *)
+|Applic'(proc, args) -> let proc_and_args = proc::args in
+                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+|ApplicTP'(proc, args) -> let proc_and_args = proc::args in
+                              (List.concat (has_write_occure_in_seq_complex proc_and_args varParam c_id counter_man))
+|_ -> []
+
+(* this function is the read occures in seq but it records what it sees yeahhhh *)
+and  has_write_occure_in_seq_complex expr_list varParam c_id counter_man= match expr_list with
+|[] -> []
+|one::two -> match one with
+            |LambdaSimple'(params, body) -> (make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+            |LambdaOpt'(params, opt, body) ->(make_list_of_set_occures (List.hd expr_list) varParam c_id counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+            |_ -> (make_list_of_set_occures (List.hd expr_list) varParam (c_id) counter_man)::(has_write_occure_in_seq_complex (List.tl expr_list) varParam (c_id) counter_man)
+;;
+
+
+(* this function gets expression and varParam and checks if we need to box the param *)
+(* let shall_we_box expr varParam =  *)
+let make_box_id_counter() =
+  let x = ref(0) in
+  fun() -> x := !x + 1; !x ;;
+
+let rec make_lambda_params_vars params num = match params with
+|[] -> []
+|_ ->  (make_lambda_params_vars (List.tl params) (num+1))@[VarParam(List.hd (params), num)]
+;;
+(* let papa = make_box_id_counter();; *)
+
+(* "one" is the get and "two" is the set *)
+let does_this_match_require_boxing  cartesian_product =
+          let (one,two) = cartesian_product in
+            if((fst one) = (fst two)) (* if read and write are in differnt closures*)
+            then false
+            else (if ((snd one) = -1 || (snd two) = -1 || (((snd one) = 0 && (snd two) = 0))) (* if both occurences do not refer to same rib *)
+            then true
+            else false)
+
+let is_boxing_needed_2 get_list set_list =
+          let cartesian =   List.concat (List.map (fun e -> List.map (fun e' -> (e,e')) get_list) set_list) in
+          List.exists (fun x -> does_this_match_require_boxing x) cartesian;;
+
+let add_set_tag_to_body_of_lambda expr varParam = match expr with
+|LambdaSimple'(params, Seq'(seq_list)) -> (LambdaSimple'(params, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
+|LambdaSimple'(params, other) -> (LambdaSimple'(params, Seq'([Set'(varParam,Box'(varParam));other])))
+|LambdaOpt'(params, opt, Seq'(seq_list)) -> (LambdaOpt'(params, opt, Seq'(Set'(varParam,Box'(varParam))::seq_list)))
+|LambdaOpt'(params, opt, other) -> (LambdaOpt'(params, opt, Seq'([Set'(varParam,Box'(varParam));other])))
+|_ -> raise X_syntax_error;;
+
+let rec replace_get_set expr varParam = match expr with
+|Var'(var_var) -> if((name_of_var varParam) = (name_of_var var_var))
+                  then BoxGet'(var_var)
+                  else Var'(var_var)
+|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, replace_get_set box_set_val varParam)
+|If'(test, tCase, fCase) -> If'((replace_get_set test varParam), (replace_get_set tCase varParam), (replace_get_set fCase varParam))
+|Seq'(seq_list) -> Seq'((List.map (fun t -> replace_get_set t varParam) seq_list))
+|Set'(set_var, set_val) -> if((name_of_var varParam) = (name_of_var set_var))
+                           then (BoxSet'(set_var, replace_get_set set_val varParam))
+                           else Set'(set_var, replace_get_set set_val varParam)
+|Def'(def_var,def_val) -> Def'(def_var,replace_get_set def_val varParam)
+|Or'(or_list) -> Or'((List.map (fun t -> replace_get_set t varParam) or_list))
+|LambdaSimple'(params, body) -> if (check_if_var_is_in_param_list params (name_of_var varParam))
+                                then LambdaSimple'(params, body)
+                                else LambdaSimple'(params, (replace_get_set body varParam)) (* lookoo *)
+|LambdaOpt'(params, opt, body) -> if(check_if_var_is_in_param_list (opt::params) (name_of_var varParam))
+                                  then LambdaOpt'(params, opt, body)
+                                  else LambdaOpt'(params, opt, (replace_get_set body varParam)) (* lookoo *)
+|Applic'(proc, args) -> Applic'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
+|ApplicTP'(proc, args) -> ApplicTP'(replace_get_set proc varParam, (List.map (fun t -> replace_get_set t varParam) args))
+|_ -> expr
+;;
+
+
+
+let actually_do_the_fucking_boxing expr varParam =
+  let expr_with_set_tag = (add_set_tag_to_body_of_lambda expr varParam) in
+  match expr_with_set_tag with
+  |LambdaSimple'(params, body) -> LambdaSimple'(params, replace_get_set body varParam)
+  |_ -> raise X_syntax_error
+  ;;
+
+(* the var list is (bool, the varParam) *)
+let rec actually_do_the_fucking_boxing_2 expr varList = match expr, varList with
+|_, [] -> expr
+|LambdaSimple'(params,body), _ -> if(fst (List.hd varList))
+      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda (LambdaSimple'(params,(replace_get_set body (snd (List.hd varList))))) (snd(List.hd varList))) (List.tl varList)
+      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
+|LambdaOpt'(params, opt,body), _ -> if(fst (List.hd varList))
+      then actually_do_the_fucking_boxing_2 (add_set_tag_to_body_of_lambda  (LambdaOpt'(params, opt, (replace_get_set body (snd (List.hd varList)))))(snd(List.hd varList))) (List.tl varList)
+      else actually_do_the_fucking_boxing_2 expr (List.tl varList)
+| _,_ -> raise X_syntax_error;;
+
+let  is_boxing_needed expr varParam =
+  match expr with
+  |LambdaSimple'(params,body)->
+                                let goku = make_box_id_counter() in
+                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+                                let goku = make_box_id_counter() in
+                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+                                is_boxing_needed_2 get_list set_list
+  |LambdaOpt'(params, opt, body)->
+                                let goku = make_box_id_counter() in
+                                let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+                                let goku = make_box_id_counter() in
+                                let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+                                is_boxing_needed_2 get_list set_list
+  |_ -> raise X_syntax_error
+  ;;
+
+ (* let goku = make_box_id_counter() in
+let get_list = make_list_of_get_occures body (varParam) (goku()) goku in
+let goku = make_box_id_counter() in
+let set_list = make_list_of_set_occures body (varParam) (goku()) goku in
+if (is_boxing_needed_2 get_list set_list)
+then (actually_do_the_fucking_boxing expr (varParam))
+else expr *)
+
+
+let gets_lambda_returns_it_boxed expr = match expr with
+|LambdaSimple'(params, body) -> let act_params = make_lambda_params_vars params 0 in
+                               let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
+                               actually_do_the_fucking_boxing_2 expr box_list
+|LambdaOpt'(params, opt, body) ->  let act_params = make_lambda_params_vars (params@[opt]) 0 in
+                                   let box_list =  List.map (fun t -> (is_boxing_needed expr t, t)) act_params in
+                                   actually_do_the_fucking_boxing_2 expr box_list
+|_ -> expr
+;;
+
+let make_lambda_pair expr = match expr with
+|LambdaSimple'(params, body) -> (params, body)
+|_ ->raise X_syntax_error
+
+let make_lambda_triple expr = match expr with
+|LambdaOpt'(params, opt, body) -> (params, opt, body)
+|_ -> raise X_syntax_error
+
+let rec boxer_man expr = match expr with
+|BoxSet'(box_set_var, box_set_val) -> BoxSet'(box_set_var, boxer_man box_set_val)
+|If'(test, tCase, fCase) -> If'((boxer_man test), (boxer_man tCase ), (boxer_man fCase ))
+|Seq'(seq_list) -> Seq'((List.map (fun t -> boxer_man t ) seq_list))
+|Set'(set_var, set_val) -> Set'(set_var, boxer_man set_val)
+|Def'(def_var,def_val) -> Def'(def_var,boxer_man def_val)
+|Or'(or_list) -> Or'((List.map (fun t -> boxer_man t ) or_list))
+|LambdaSimple'(params, body) -> let (n_params, n_body) =( make_lambda_pair( gets_lambda_returns_it_boxed expr)) in
+                                  LambdaSimple'(n_params, boxer_man n_body)
+|LambdaOpt'(params, opt, body) -> let (n_params, n_opt, n_body ) = (make_lambda_triple (gets_lambda_returns_it_boxed expr)) in
+                                  LambdaOpt'(n_params, n_opt, boxer_man n_body)
+|Applic'(proc, args) -> Applic'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
+|ApplicTP'(proc, args) -> ApplicTP'(boxer_man proc , (List.map (fun t -> boxer_man t ) args))
+|_ -> expr
+
+let box_z e varParam= gets_lambda_returns_it_boxed e;;
+
+
+let box_set e = boxer_man e;;
+
+  let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-
+
 end;; (* struct Semantics *)


diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..942e8bd 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -57,9 +57,239 @@ let reserved_word_list =
    "unquote-splicing"];;

 (* work on the tag parser starts here *)
+let rec tag_parse_expression sexpr  = match sexpr with
+| Pair(Symbol("set!"), Pair(var, Pair(expr, Nil))) -> Set(tag_parse_expression var, tag_parse_expression expr)
+| Pair(Symbol("pset!"), pset_sexpr) -> pset_macro_expansion pset_sexpr (* pset macro expansion*)
+| Pair(Symbol("let"), let_sexpr) -> let_tag_parser let_sexpr
+| Pair(Symbol("let*"), let_star_sexpr) -> let_star_tag_parser let_star_sexpr
+| Pair(Symbol("letrec"), letrec_sexpr) -> letrec_tag_parser letrec_sexpr
+| Pair(Symbol("lambda"), lambda_sexpr) -> lambda_tag_parser lambda_sexpr
+| Pair(Symbol("cond"), Pair(rib,ribs)) ->cond_macro_expansion (Pair(rib,ribs)) (** cond_macro_expansion*)
+| Pair(Symbol("if"), if_sexpr)-> if_tag_parser if_sexpr
+| Pair(Symbol("define"), define_sexpr) -> define_tag_parser define_sexpr (*define_macro_expansion(**only MIT Style define has a macro-expansion*)*)
+| Pair(Symbol("begin"), begin_sexpr) -> begin_tag_parser begin_sexpr
+| Pair(Symbol("or"), or_sexpr) -> or_tag_parser or_sexpr
+| Pair(Symbol("and"), Pair( opt1, opts)) -> and_macro_expansion (Pair(opt1, opts))(*and_macro_expansion opt1 opts *)
+| Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+| Pair(Symbol("quasiquote"), sexpr) -> quasiquote_macro_expansion (sexpr) (* quasiquote macro-expansion*)
+(* | Pair(Symbol(var),Nil) -> Var(var) *)
+| Pair(var, Pair(expr,exprl)) -> Applic(tag_parse_expression var, (tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl)))
+| Number(x) -> Const(Sexpr(Number(x)))
+| Char(x) -> Const(Sexpr(Char(x)))
+| Bool(x) -> Const(Sexpr(Bool(x)))
+| String(x) -> Const(Sexpr(String(x)))
+| Symbol(x) -> Var(x)
+| Pair(x, Nil) -> Applic((tag_parse_expression x),[])
+|_ -> raise X_syntax_error
+
+and cond_macro_expansion_sexpr cond_sexpr = match cond_sexpr with
+|Nil ->  Nil
+|Pair(Pair(Symbol("else"), body),rest) ->  Pair(Symbol("begin"), body)
+|Pair(Pair(expr, Pair(Symbol("=>"),exprf)), rest) ->
+(Pair (Symbol "let",
+Pair
+ (Pair (Pair (Symbol "value", Pair (expr, Nil)),
+   Pair
+    (Pair (Symbol "f",
+      Pair (Pair (Symbol "lambda", Pair (Nil, Pair (exprf, Nil))),
+       Nil)),
+    Pair
+     (Pair (Symbol "rest",
+       Pair
+        (Pair (Symbol "lambda", Pair (Nil, Pair (Symbol "cond-ribs", Nil))),
+        Nil)),
+     Nil))),
+ Pair
+  (Pair (Symbol "if",
+    Pair (Symbol "value",
+     Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
+      Pair (Pair (Symbol "rest", Nil), Nil)))),
+  Nil))))
+  |Pair(Pair(test_case, ribs), rest) ->  Pair(Symbol("if"), Pair(test_case, Pair(Pair(Symbol("begin"), ribs), Pair(cond_macro_expansion_sexpr (rest), Nil))))   (* (ג¨exprג© ג¨expr1ג© ֲ· ֲ· ֲ· ג¨exprmג©) *)
+  | _ -> raise X_syntax_error
+
+
+
+and cond_macro_expansion cond_sexpra = tag_parse_expression (cond_macro_expansion_sexpr cond_sexpra)
+
+
+(* (ג¨exprג© => ג¨exprfג©) *)
+
+
+(* (let ((value Jג¨expr ג©K)
+        (f (lambda () Jג¨exprfג©K))
+(rest (lambda () Jג¨continue with cond-ribsג©K)))
+(if value
+    ((f) value)
+    (rest))) *)
+and pset_macro_expansion pset_sexpr = tag_parse_expression (pset_macro_expansion_sexpr pset_sexpr)
+
+and pset_macro_expansion_sexpr pset_sexpr = match pset_sexpr with
+| Pair(Pair(var, Pair(value, Nil)), Nil) ->  (Pair(Symbol("set!"), Pair(var, Pair(value, Nil))))
+| Pair(Pair(Symbol(var), Pair(value, Nil)), ribs) ->  (Pair(Symbol( "let"), Pair(Pair(Pair(Symbol( "_"^var), Pair(value , Nil)), Nil), Pair(Pair(Symbol( "lambda"), Pair(Nil, Pair(Pair(Symbol( "pset!"), ribs), Nil))), Pair(Pair(Symbol( "set!"), Pair(Symbol(var), Pair(Symbol( "_"^var), Nil))), Nil)))))
+| _ -> raise X_syntax_error
+(* (Pair(Symbol("let"), Pair(Pair(Pair(Symbol("_v1"), Pair(value, Nil)), Pair(Pair(Symbol("rest"), Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(Symbol("pset!"), Pair(ribs, Nil)), Nil))), Nil)), Nil)), Pair(Pair(Symbol("rest"), Nil), Pair(Pair(Symbol("set!"), Pair(var, Pair(Symbol("_v1"), Nil))), Nil))))) *)
+(* let  a = (Printf.printf "arrived here") in  *)
+
+(* and heart_of_quasiquote q_sexpr = match q_sexpr with
+| *)
+
+and quasiquote_macro_expansion q_sexpr = match q_sexpr with
+| Pair (Pair (Pair (Symbol "unquote", Pair (sexpr, Nil)), Nil), Nil) -> Applic (Var "cons", [tag_parse_expression( sexpr); Const (Sexpr Nil)])
+| Pair (Pair (Pair (Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil), Nil) -> Const(Sexpr(Pair(Symbol("quote"), q_sexpr)))
+(* | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr1, Nil)), Nil) -> raise X_syntax_error *)
+| Nil -> Const(Sexpr(Pair(Symbol("quote"), Nil)))
+| Pair (Pair (Symbol(s1), Nil), Nil)  -> Const(Sexpr(Pair(Symbol("quote"), Symbol(s1))))
+| _ -> raise X_syntax_error
+(* | Pair(Pair(Pair(Symbol("unquote-splicing"), sexa)), B) ->  *)
+
+and and_macro_expansion and_sexpr = match and_sexpr with
+| Nil -> Const(Sexpr(Bool(true)))
+| Pair(op, Nil)-> tag_parse_expression op
+| Pair(op1, opts) -> If(tag_parse_expression op1, and_macro_expansion opts, Const(Sexpr(Bool(false))))
+| _ -> raise X_syntax_error
+
+and or_tag_parser or_sexpr = match or_sexpr with
+| Nil -> Or([])
+| Pair(expr, Nil) -> tag_parse_expression expr
+| Pair(expr, exprl) -> Or(((tag_parse_expression expr) :: (List.map tag_parse_expression (sexpr_to_list exprl))))
+| _ -> raise X_syntax_error
+
+and rib_varu_maker rimbs = match rimbs with
+|Nil -> Nil
+|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(varu, Nil)
+|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(varu, rib_varu_maker (rimbs2))
+|_ -> raise X_syntax_error
+
+and rib_valu_maker rimbs = match rimbs with
+|Nil -> Nil
+|Pair(Pair(varu, Pair(valu, Nil)), Nil) -> Pair(valu, Nil)
+|Pair(Pair(varu, Pair(valu, Nil)), rimbs2) -> Pair(valu, rib_valu_maker rimbs2)
+| _ -> raise X_syntax_error
+
+and let_tag_parser let_sexpr = match let_sexpr with
+| Pair(Nil, body) ->  tag_parse_expression (Pair(Pair(Symbol("lambda"),Pair(Nil, body)), Nil))
+| Pair(Pair(rib, ribs), body) ->  tag_parse_expression( Pair(Pair(Symbol("lambda"),Pair(rib_varu_maker (Pair(rib, ribs)), body )),rib_valu_maker (Pair(rib,ribs))))
+| _ -> raise X_syntax_error
+and let_star_tag_parser_sexpr let_star_sexpr = match let_star_sexpr with
+| Pair(Nil, body) -> (Pair (Symbol("let"), let_star_sexpr))
+| Pair(Pair(rib, Nil), body)->(Pair (Symbol("let"), let_star_sexpr))
+| Pair(Pair(rib,ribs), body) ->  (Pair(Symbol("let"), Pair(Pair(rib,Nil), let_star_tag_parser_sexpr ((Pair(ribs, body)))))) (* let* macro-expansion*)
+|_ -> raise X_syntax_error
+(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
+
+and let_star_tag_parser let_star_sexpr = match let_star_sexpr with
+| Pair(Nil, body) -> tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
+| Pair(Pair(rib, Nil), body)->tag_parse_expression (Pair (Symbol("let"), let_star_sexpr))
+| Pair(Pair(rib,ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib,Nil), Pair(Symbol("let*"), Pair(ribs, body))))) (* let* macro-expansion*)
+| _ -> raise X_syntax_error
+(* Pair(Symbol "let", Pair(Pair(Pair(Symbol "v1", Pair(Symbol "Expr1", Nil)), Nil), Pair(Pair(Symbol "let*", Pair(Pair(Pair(Symbol "v2", Pair(Symbol "Expr2", Nil)), Pair(Pair(Symbol "vn", Pair(Symbol "Exprn", Nil)), Nil)), Pair(Symbol "expr1", Pair(Symbol "exprm", Nil)))), Nil))) *)
+
+and create_set_sexprs ribs body= match ribs with
+| Pair(Nil,Nil) -> Nil
+| Pair(Pair(var,Pair(value,Nil)),Nil) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), body)
+| Pair(Pair(var,Pair(value,Nil)),rest) -> Pair(Pair(Symbol("set!"), Pair(var, Pair(value, Nil))), (create_set_sexprs rest body ))
+| _ -> raise X_syntax_error
+
+and  letrec_tag_parser letrec_sexpr = match letrec_sexpr with
+| Pair(Nil, body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Nil, Pair(body, Nil))))
+| Pair(Pair(rib, ribs), body) -> tag_parse_expression (Pair(Symbol("let"), Pair(Pair(rib, ribs), (create_set_sexprs (Pair(rib,ribs)) body ))))(*letrec_macro_expansion rib ribs body*)
+| _ -> raise X_syntax_error
+
+and checkArguments args =
+match args with
+| Pair(Symbol("vs"), Nil) -> variadic_lambda
+| Pair(arg, Nil) -> simple_lambda_tag_parser
+| Pair(arg1, Symbol(opt)) -> (opt_lambda_tag_parser opt )
+| Pair(arg1,rest) -> checkArguments rest
+| _ -> raise X_syntax_error
+
+and create_string_arr sList = match sList with
+| Symbol(vs) -> []
+| Pair(Symbol(last), Nil) -> [last]
+| Pair(Symbol(str1), b) -> str1::create_string_arr b
+| Nil -> []
+| _ -> raise X_syntax_error
+
+and makeSequence expr_list = Seq(flattenSequence (List.map tag_parse_expression (sexpr_to_list expr_list)))
+
+and simple_lambda_tag_parser lambda_sexpr =
+match lambda_sexpr with
+| Pair (args, Pair(expr, Nil)) ->  LambdaSimple((create_string_arr args),tag_parse_expression expr)
+| Pair( args,expr_list) ->  LambdaSimple((create_string_arr args), makeSequence expr_list)(* simple*)
+| _ -> raise X_syntax_error
+
+and opt_lambda_tag_parser opt lambda_sexpr =
+match lambda_sexpr with
+| Pair(args, Pair(expr, Nil)) -> LambdaOpt((create_string_arr args), opt, tag_parse_expression expr)(* opt*)
+| Pair(args, expr_list) -> LambdaOpt((create_string_arr args), opt, makeSequence expr_list)(* opt*)
+| _ -> raise X_syntax_error
+
+and variadic_lambda lambda_sexpr =
+match lambda_sexpr with
+| Pair(Pair(Symbol("vs"),Nil), Pair(expr, Nil)) ->  LambdaOpt([], "vs", tag_parse_expression expr)(* opt*)
+| Pair(Pair(Symbol("vs"),Nil), expr_list) -> LambdaOpt([], "vs", makeSequence expr_list)(* opt*)
+| _ -> raise X_syntax_error
+and lambda_tag_parser lambda_sexpr = match lambda_sexpr with
+|Pair(Nil, expr) -> simple_lambda_tag_parser lambda_sexpr
+|Pair(args, expr) -> (checkArguments args) lambda_sexpr
+|_ -> raise X_syntax_error
+
+
+and define_tag_parser define_sexpr = match define_sexpr with
+| Pair (Pair (var, arglist), Pair (exprs, Nil)) -> tag_parse_expression (Pair(Symbol "define", Pair(var, Pair(Pair(Symbol "lambda", Pair(arglist, Pair(exprs, Nil))), Nil))))
+| Pair(name, Pair(expr, Nil)) -> Def(tag_parse_expression name,  tag_parse_expression expr )
+| _ -> raise X_syntax_error
+(* Pair(Symbol "define", Pair(Pair(Symbol "var", Symbol "arglist"), Pair(Symbol "expr+", Nil))) *)
+
+and sexpr_to_list pair_list = match pair_list with
+| Nil  -> []
+| Pair(a , b) -> a:: (sexpr_to_list b)
+|_ -> raise X_syntax_error
+
+and  flattenSequence  expr_list_2 =
+  List.fold_left (fun acc expr -> match expr with
+  | Seq(lst) -> acc@lst
+  (* | Const(void) -> []  *)
+  | _ -> acc@[expr]) [] expr_list_2
+and begin_tag_parser begin_sexpr =
+  match begin_sexpr with
+| Nil-> Const (Void)
+| Pair(a, Nil) -> tag_parse_expression a
+| sexprs -> Seq (flattenSequence (List.map tag_parse_expression ( sexpr_to_list sexprs)))
+
+and if_tag_parser if_sexpr = match if_sexpr with
+| Pair(test, Pair(dit, Pair(dif, Nil)))->
+  If(tag_parse_expression test, tag_parse_expression dit, tag_parse_expression dif)
+| Pair(test, Pair(dit,Nil))->
+  If(tag_parse_expression test, tag_parse_expression dit, Const (Void))
+|_ -> raise X_syntax_error;;
+
+let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;

-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;

-
 end;; (* struct Tag_Parser *)

+(*
+(define sexpr->ocaml-string
+(lambda(e)
+(cond
+((boolean? e)
+(if e "Bool true" "Bool false"))
+((null? e) "Nil")
+((char? e) (  format "Char '~a'" e))
+((symbol? e) (  format "Symbol \"~a\"" e))
+((string? e) (  format "String \"~a\"" e) )
+((flonum? e) (  format "Number (Float ~a)" e))
+((integer? e) (  format "Number (Fraction(~a, 1))" e))
+((ratnum? e)
+(format "Number (Fraction(~a, ~a))" (numeratore) (denominatore)))
+((pair? e)
+(format "Pair(~a, ~a)"
+(sexpr->ocaml-string (car e))
+(sexpr->ocaml-string (cdr e))))
+(else(error 'sexpr->ocaml-string
+(format "Unsupported type: ~a" e))))))
+(define print-template
+(lambda(sexpr)(display(sexpr->ocaml-string sexpr))))
+(print-template'(let (rib . ribs) body)) *)
\ No newline at end of file
