diff --git a/reader.ml b/reader.ml
index 32445c2..e429570 100644
--- a/reader.ml
+++ b/reader.ml
@@ -15,6 +15,7 @@ type sexpr =
   | Char of char
   | String of string
   | Symbol of string
+  | Comment of sexpr
   | Pair of sexpr * sexpr;;
 
 let rec sexpr_eq s1 s2 =
@@ -29,6 +30,259 @@ let rec sexpr_eq s1 s2 =
   | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
   | _ -> false;;
 
+
+
+open PC;;
+
+
+
+
+(*   __________________SYMBOL_________________   *)
+let _letter_ = range_ci 'a' 'z';;
+let _digits_ = range '0' '9';;
+let _punctuations_ = one_of "!$^*-_=+<>/?";;
+let _dot_ = char '.';;
+
+let _dot_pred_ = (fun e -> (not (sexpr_eq e (Symbol ".") )) && (not (sexpr_eq e (Symbol "") ))  );;
+let _symbol_ =pack (plus (pack (disj_list[_letter_; _digits_; _punctuations_;_dot_]) (fun (e) -> (lowercase_ascii e))))   (fun e -> Symbol (list_to_string e));;
+let symbol_NT= guard _symbol_ _dot_pred_;;
+
+(*          ___BOOLEAN___________                          *)
+let _t_ =  char_ci 't';;
+let _hash_ = (char '#');;
+let _f_ = (char_ci 'f');;
+
+let true_NT= pack (caten _hash_ _t_) (fun e-> Bool(true)) ;;
+let false_NT =pack (caten _hash_ _f_ ) (fun e-> Bool(false));;
+let bool_NT = not_followed_by (disj true_NT false_NT) _symbol_;;
+
+(*    ______________STRING_________________          *)
+
+let _quote_ = char '"';;
+let _stringChars_ = const (fun ch -> ch != '"' )    ;;
+
+
+let string_NT =
+fun s -> 
+let (q1, s) = (_quote_ s) in
+let (e, s) = ((pack (star _stringChars_) (fun e->String (list_to_string e))) s) in
+let (q2, s) = (_quote_ s) in
+(e, s);;
+
+(*    ____________COMENT____________   *)
+
+let nt_end_of_line = char '\n';;
+let _commentChars_ = const (fun ch -> ch != ';' && ch != '\n');;
+let _semicolon_ = (char ';');;
+
+let comment_NT =
+fun s -> 
+let (q1, s) = (_semicolon_ s) in
+let (e, s) = ((pack (star _commentChars_) (fun e->Comment (String (list_to_string e)))) s) in
+let (q2, s) = ((disj_list [ pack nt_end_of_input (fun e-> 'e')  ; nt_end_of_line; _semicolon_ ]) s) in 
+(e, s);;
+
+let _sexperCommentPrefix_ = word "#;";; 
+
+let rec sexperComment_NT readsexper =
+fun s->
+let (e, s) = ( _sexperCommentPrefix_ s) in
+let (e,s) = ((star nt_whitespace) s) in
+let (e,s) = (readsexper s) in
+(Comment ( e),s);;
+
+
+
+
+(* __________________CHAR_________________ *)
+
+
+let _CharPrefix_ = caten (char '#') (char '\\');;
+let _nulC_ = word_ci "nul";;
+let _newlineC_ = word_ci "newline";;
+let _returnC_ = word_ci "return";;
+let _tabC_ = word_ci "tab";;
+let _pageC_ = word_ci "page";;
+let _spaceC_ = word_ci "space";;
+
+
+
+let _charsC_ = const (fun ch -> ch > ' ');;
+
+let char_NT = 
+fun s->
+let (e1, s) = (_CharPrefix_ s) in
+try ((pack  _nulC_ (fun e-> Char (char_of_int 0)  )  ) s  )
+with X_no_match ->
+try ((pack  _newlineC_ (fun e-> Char '\n' )  ) s  )
+with X_no_match ->
+try ((pack  _returnC_ (fun e-> Char (char_of_int 13)  )  ) s  )
+with X_no_match ->
+try ((pack  _tabC_ (fun e-> Char (char_of_int 9)  )  ) s  )
+with X_no_match ->
+try ((pack  _pageC_ (fun e-> Char (char_of_int 12)  )  ) s  )
+with X_no_match ->
+try ((pack  _spaceC_ (fun e-> Char (char_of_int 32)  )  ) s  )
+with X_no_match ->
+((pack  _charsC_ (fun e-> Char e )  ) s  );;
+
+
+
+(* _______________________NIL+PAIR____________________ *)
+
+let ignored_nt read_sexpr = (star (disj_list [pack comment_NT (fun _ -> Nil); pack (sexperComment_NT read_sexpr) (fun _ -> Nil); pack nt_whitespace (fun _ -> Nil)])) ;;
+
+
+let nil_nt read_sexpr = 
+fun s ->
+let (e, s) = ((char '(' )s) in
+let (e,s) = ( ignored_nt read_sexpr s) in
+let (e,s ) = ((char ')' ) s) in
+(Nil, s);;
+
+let dotted_nt read_sexpr = 
+fun s->
+let (e,s) = ((char '.' ) s) in
+let (e,s) = ( ignored_nt read_sexpr s) in
+let (e,s) = (read_sexpr s) in
+let (q, s) = ( ignored_nt read_sexpr s) in
+let (q,s) = ((char ')' ) s) in
+(e,s);;
+
+let rec make_pair read_sexpr = 
+fun s ->
+let (e,s) = ( ignored_nt read_sexpr s) in
+let (e1,s) = (read_sexpr s) in
+let (e,s) = ( ignored_nt read_sexpr s) in
+let (e2, s) = ( disj_list[(dotted_nt read_sexpr) ;( pack (char ')' )   (fun e-> Nil) );  (make_pair read_sexpr)]    s ) in
+( Pair(e1, e2), s );; 
+
+let rec pair_NT read_sexpr =
+fun s ->
+let (e, s) = ((char '(' )s) in
+let (e,s) = (make_pair read_sexpr s) in
+(e,s);;
+
+(*     _________________NUMBER_______________  *)
+let ascii_0 = 48;;
+  let nt_digit = pack (const (fun ch -> '0' <= ch && ch <= '9'))(fun ch -> (int_of_char ch) - ascii_0);; 
+  
+  let nt_natural_zero = 
+    let rec make_nt_natural () =
+      pack (caten nt_digit
+      (disj (delayed make_nt_natural)
+        nt_epsilon))
+        (function (a, s) -> a::s) in
+        pack (make_nt_natural())
+        (fun s->
+        (List.fold_left
+        (fun a b -> a ^ (string_of_int b))
+        "."
+        s));;
+
+  
+  let nt_natural = 
+    let rec make_nt_natural () =
+      pack (caten nt_digit
+      (disj (delayed make_nt_natural)
+        nt_epsilon))
+        (function (a, s) -> a::s) in
+         pack (make_nt_natural())
+         (fun s->
+         (List.fold_left
+         (fun a b -> a ^ (string_of_int b))
+        ""
+        s));;
+  let nt_plus = char '+';;
+  let nt_minus = char '-';;
+  let number_pred = disj
+     (pack (caten (maybe nt_plus) nt_natural)
+       (fun (a, s) -> s))
+    (pack (caten (maybe nt_minus) nt_natural)
+  (fun (a, s) -> "-" ^ s));;
+
+  let rec gcd a b = 
+    if b = 0 then a else gcd b (a mod b);;
+
+  let abs a = if a < 0 then a* -1 else a;;
+
+  let rec float_left_dot a = 
+    if a < 1. then a else float_left_dot(a/. 10.);;
+
+  
+
+  let nt_backslash = char '/';;
+  let nt_fractions = pack (caten (pack
+  (caten number_pred nt_backslash)
+    (fun (a, s) -> a)) nt_natural)
+      (fun (a, s) -> Fraction ((int_of_string a)/(abs (gcd (int_of_string a) (int_of_string s))), (int_of_string s)/(abs (gcd (int_of_string a) (int_of_string s)))));;
+
+  let nt_dot = char '.';;
+
+  let nt_float = pack (caten (pack
+  (caten number_pred nt_dot)
+    (fun (a, s) -> a)) nt_natural_zero)
+      (fun (a, s) -> Float(float_of_string (a ^ s)));;
+
+      let nt_float_ = pack
+   (not_followed_by (caten number_pred nt_dot) _symbol_)
+        (fun (a, s) -> Float((float_of_string a)));;
+
+  let nt_number_ = (pack
+  (not_followed_by number_pred _symbol_)
+  (fun (a) -> Fraction((int_of_string a), 1)));;
+
+
+(* scientific reading *)
+  let nt_float_string = pack (caten (pack 
+      (caten number_pred nt_dot)
+        (fun (a, s) -> a)) nt_natural_zero)
+          (fun (a, s) -> a ^ s);;
+  
+  let nt_e = disj (char 'e') (char 'E');;
+  let rec power_float x y = if y > 0.0 then (x *. power_float x (y -. 1.0)) else 1.0;;
+
+  let nt_scientific_number = pack (caten (pack 
+  (caten (disj nt_float_string number_pred) nt_e)
+    (fun (a, s) -> a)) number_pred)
+      (fun (a, s) -> if (float_of_string s) > 0. then 
+      Float((float_of_string a) *. (power_float 10.0 (float_of_string s)))
+      else
+      Float((float_of_string a) /. (power_float 10.0 ((float_of_string s) *. -1.)))
+      );;
+
+  
+let nt_number = pack (disj_list [nt_scientific_number; nt_float; nt_fractions; nt_float_; nt_number_;]) (fun e-> Number (e));;
+
+
+
+
+
+
+
+(* read a quated *)
+let nt_quoted_t = char '\'';;
+let nt_quoted_q = char '`';;
+let nt_quoted_u = char ',';;
+let nt_quoted_s = char '@';;
+let nt_quoted read_sexpr = pack (caten nt_quoted_t read_sexpr)
+(fun (a, s) -> Pair(Symbol("quote"), Pair(s, Nil)));;
+let nt_qquoted read_sexpr = pack (caten nt_quoted_q read_sexpr)
+(fun (a, s) -> Pair(Symbol("quasiquote"), Pair(s, Nil)));;
+let nt_unquoted read_sexpr = pack (caten nt_quoted_u read_sexpr)
+(fun (a, s) -> Pair(Symbol("unquote"), Pair(s, Nil)));;
+let nt_unquotedspliced read_sexpr = pack (caten (pack (caten nt_quoted_u nt_quoted_s) (fun (a, s) -> a)) read_sexpr)
+(fun (a, s) -> Pair(Symbol("unquote-splicing"), Pair(s, Nil)));;
+
+let nt_quotes read_sexpr = disj_list[nt_qquoted read_sexpr; nt_quoted read_sexpr; nt_unquoted read_sexpr; nt_unquotedspliced read_sexpr];;
+
+(* read a single sexper *)
+let rec read_sexpr = 
+  fun s->
+  let (e,s) = (ignored_nt read_sexpr s) in
+  let (e,s) = ((disj_list[ bool_NT; nil_nt read_sexpr; nt_number ;char_NT;string_NT; pair_NT read_sexpr; nt_quotes read_sexpr; symbol_NT]) s) in
+  (e, s);;
+
 module Reader: sig
   val read_sexprs : string -> sexpr list
 end
@@ -41,6 +295,18 @@ let normalize_scheme_symbol str =
   else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+
+
+
+
+let rec read_sexprs string =  
+  let (e, s) = (star read_sexpr) (string_to_list string) in
+  match e with
+  | [] -> raise X_no_match
+  | _ ->  e;;
+
+
+
+
   
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..c3aa474 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,3 @@
+almog arad 206026650
+iftah levy 209383306
+I (We) assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the Internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
new file mode 100644
index 0000000..3adb9b8
--- /dev/null
+++ b/semantic-analyser.ml
@@ -0,0 +1,440 @@
+#use "tag-parser.ml";;
+
+type var = 
+  | VarFree of string
+  | VarParam of string * int
+  | VarBound of string * int * int;;
+
+type expr' =
+  | Const' of constant
+  | Var' of var
+  | Box' of var
+  | BoxGet' of var
+  | BoxSet' of var * expr'
+  | If' of expr' * expr' * expr'
+  | Seq' of expr' list
+  | Set' of var * expr'
+  | Def' of var * expr'
+  | Or' of expr' list
+  | LambdaSimple' of string list * expr'
+  | LambdaOpt' of string list * string * expr'
+  | Applic' of expr' * (expr' list)
+  | ApplicTP' of expr' * (expr' list);;
+
+let rec expr'_eq e1 e2 =
+  match e1, e2 with
+  | Const' Void, Const' Void -> true
+  | Const'(Sexpr s1), Const'(Sexpr s2) -> sexpr_eq s1 s2
+  | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
+  | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+  | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+  | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
+                                            (expr'_eq th1 th2) &&
+                                              (expr'_eq el1 el2)
+  | (Seq'(l1), Seq'(l2)
+  | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
+  | (Set'(var1, val1), Set'(var2, val2)
+  | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq (Var'(var1)) (Var'(var2))) &&
+                                             (expr'_eq val1 val2)
+  | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) ->
+     (List.for_all2 String.equal vars1 vars2) &&
+       (expr'_eq body1 body2)
+  | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) ->
+     (String.equal var1 var2) &&
+       (List.for_all2 String.equal vars1 vars2) &&
+         (expr'_eq body1 body2)
+  | Applic'(e1, args1), Applic'(e2, args2)
+  | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
+	 (expr'_eq e1 e2) &&
+	   (List.for_all2 expr'_eq args1 args2)
+  | _ -> false;;
+  
+(********************* LEXICAL ADDRESS *************************)
+
+  let rec first_element_expr lst = 
+    match lst with 
+       | first_el::rest_of_list -> first_el
+;;
+
+ let rec first_element lst = 
+    match lst with 
+       | [] -> ""
+       | first_el::rest_of_list -> first_el
+       ;;
+
+let rec rest_element lst = 
+    match lst with 
+       | [] -> []
+       | first_el::rest_of_list -> rest_of_list  
+;;
+
+  let rec var_in_list var lst_vars minor = 
+    match lst_vars with
+    | e::s -> if ((compare e var) == 0) then minor else var_in_list var s (minor+1)
+    | [] -> -1
+    ;;
+
+    let rec exprlst_to_list f vars = 
+      match vars with
+      | e::s -> ((f e) :: exprlst_to_list f s)
+      | _ -> []
+      ;;
+
+      let rec string_list lst =
+        match lst with
+        | e::s -> (e^", "^(string_list s))
+        | e::[] -> e
+        | _ -> ""
+        ;;
+
+      let rec var_in_lists var vars_vars major = 
+        match vars_vars with
+        | [] -> VarFree(var)
+        | (first_list::rest_list) ->
+             if (major == -1)
+                then (
+                  if((var_in_list var first_list 0) != -1)
+                      then VarParam(var, (var_in_list var first_list 0))
+                  else 
+                    (var_in_lists var rest_list (major+1)))
+              else (
+                 if((var_in_list var first_list 0) != -1) 
+                    then VarBound(var, major, (var_in_list var first_list 0))
+                 else (
+                    var_in_lists var rest_list (major+1)))
+              ;;
+
+      
+let rec lambda_vars vars_vars body = 
+  match body with
+  | Const(c) -> Const'(c)
+  | Var(x) -> Var'(var_in_lists x vars_vars (-1))
+  | If(test, dit, dif) -> If'(lambda_vars vars_vars test, lambda_vars vars_vars dit, lambda_vars vars_vars dif)
+  | Seq(lst) -> Seq'(exprlst_to_list (lambda_vars vars_vars) lst)
+  | Set(Var(x), exp) -> Set'(var_in_lists x vars_vars (-1), lambda_vars vars_vars exp)
+  | Def(Var(x), exp) -> Def'(var_in_lists x vars_vars (-1), lambda_vars vars_vars exp)
+  | Or(lst) -> Or'(exprlst_to_list (lambda_vars vars_vars) lst)
+  | LambdaSimple(vars, body) -> LambdaSimple'(vars, lambda_vars ([vars]@vars_vars) body)
+  | LambdaOpt(vars, lst, body) -> LambdaOpt'(vars, lst, lambda_vars ([(List.append vars [lst])]@vars_vars) body)
+  | Applic(exp, lst) -> Applic'(lambda_vars vars_vars exp, exprlst_to_list (lambda_vars vars_vars) lst)
+  ;;
+
+let rec annotate_lexical_addresses e =
+ match e with
+  | Const(c) -> Const'(c)
+  | Var(x) -> Var'(VarFree(x))
+  | If(test, dit, dif) -> If'((annotate_lexical_addresses test), (annotate_lexical_addresses dit), (annotate_lexical_addresses dif))
+  | Seq(lst) -> Seq'(exprlst_to_list annotate_lexical_addresses lst)
+  | Set(Var(x), exp) -> Set'(VarFree(x), annotate_lexical_addresses exp)
+  | Def(Var(x), exp) -> Def'(VarFree(x), annotate_lexical_addresses exp)
+  | Or(lst) -> Or'(exprlst_to_list annotate_lexical_addresses lst)
+  | LambdaSimple(vars, body) -> LambdaSimple'(vars, lambda_vars (vars::[]) body)      
+  | LambdaOpt(vars, lst, body) -> LambdaOpt'(vars, lst, lambda_vars ([(List.append vars [lst])]) body)
+  | Applic(exp, lst) -> Applic'(annotate_lexical_addresses exp, exprlst_to_list annotate_lexical_addresses lst)
+;;
+
+(********************* TAIL CALL *************************)
+
+let rec annotate_list lst bol atc =
+  match lst with
+  | [] -> []
+  (*| e::_ -> (atc e bol)::[]  *)
+  | e::s -> (atc e bol)::(annotate_list s bol atc)
+;;
+
+let rec list_map_bool func lst bol =
+match lst with
+| e::[] -> [func e bol]
+| e::s -> (func e false)::(list_map_bool func s bol);;
+
+let rec annotate_tail_calls expr bol =
+  match expr with
+  | Var'(x) -> Var'(x)
+  | Const'(v) -> Const'(v)
+  | Applic'(proc, lst) -> (match bol with
+                    | true -> ApplicTP'(annotate_tail_calls proc false, (annotate_list lst false annotate_tail_calls))
+                    | false -> Applic'(annotate_tail_calls proc false, (annotate_list lst false annotate_tail_calls)))
+  | Or'(lst) -> Or'((annotate_tail_calls (first_element_expr lst) false)::(annotate_list (rest_element lst) bol annotate_tail_calls))
+  | If'(test, dit, dif) -> If'(annotate_tail_calls test false, annotate_tail_calls dit bol, annotate_tail_calls dif bol)
+  | Def'(var, exp) -> Def'(var, annotate_tail_calls exp false)
+  | LambdaSimple'(vars, body) -> LambdaSimple'(vars, annotate_tail_calls body true)
+  | LambdaOpt'(vars, lst, body) -> LambdaOpt'(vars, lst, annotate_tail_calls body true)
+  | Seq'(lst) -> Seq'(list_map_bool annotate_tail_calls lst bol)
+  | s -> s
+  ;;
+
+(********************* BOXING *************************)
+
+
+let rec eq_var_list x lst =
+  match lst with
+  | [] -> false
+  | e::s -> if((compare x e) == 0) then true else eq_var_list x s
+  ;;
+exception Wut2;;
+  let eq_var a b =
+    match b with
+    | VarParam(x, i) -> ((compare a x) == 0)
+    | VarBound(x, i , j) -> ((compare a x) == 0)
+    | _ -> false
+    ;;
+
+  let eq_var_deep a b =
+    let a_name = match a with
+    | VarParam(x, i) -> x
+    | VarBound(x, i , j) -> x
+    | _ -> ""    in
+    let b_name = match b with
+    | VarParam(x, i) -> x
+    | VarBound(x, i , j) -> x
+    | _ -> ""    in
+    if((compare a_name "" ) != 0 && (compare a_name b_name) == 0)
+      then true else false
+    ;;
+
+let rec eq_var_list_deep x lst =
+  match lst with
+  | [] -> false
+  | e::s -> if(eq_var e x) then true else eq_var_list_deep x s
+  ;;
+
+
+let rec find_nest var_name expr =
+(match expr with  
+  
+    | Const'(v) -> (false, [])
+    | Var'(v) -> (false, [])
+    | Box'(v) -> (false, [])
+    | BoxGet'(v) -> (false, [])
+    | Set'(var, exp) 
+    | Def'(var, exp) 
+    | BoxSet'(var, exp) -> (true, [exp])
+    | If'(test, dit, dif) -> (true, [test; dit; dif] )
+    | Or'(lst)
+    | Seq'(lst) -> (true, lst)
+ 
+
+    | LambdaSimple'(vars, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) vars ) then (false, []) else (true, [exp])
+    | LambdaOpt'(lst, v, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) lst ) then (false, []) else (true, [exp])
+    | Applic'(exp, lst) 
+    | ApplicTP'(exp, lst) -> (true, exp::lst)
+    | _ -> (false, [])) 
+    ;;
+
+
+
+
+let rec find_Write var_name body =
+match body with | e::rest ->
+    (match e with
+  
+    | Const'(c) -> find_Write  var_name rest
+    | Var'(v) -> find_Write  var_name rest
+    | Box'(v) -> find_Write var_name rest
+    | BoxGet'(v) -> find_Write var_name rest  
+    | BoxSet'(v, exp) -> find_Write var_name (exp::rest)
+    | If'(test, dit, dif) -> find_Write var_name [test] || find_Write var_name [dit] || find_Write var_name  (dif::rest)   
+    | Seq'(lst) -> find_Write var_name (List.append lst rest)
+    | Set'(var, exp) -> if(eq_var var_name var) then true else (find_Write var_name (exp::rest))
+    | Def'(var, exp) ->  find_Write var_name (exp::rest)
+    | Or'(lst) -> find_Write var_name (List.append lst rest)  
+    | LambdaSimple'(vars, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) vars ) then find_Write var_name rest else find_Write var_name (exp::rest) 
+    | LambdaOpt'(lst, v, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) lst ) then find_Write var_name rest else find_Write var_name (exp::rest )
+    | Applic'(exp, lst) ->  find_Write var_name (exp::(List.append lst rest)  )  
+    | ApplicTP'(exp, lst) -> find_Write var_name (exp::(List.append lst rest)  )
+    | _ -> false)
+    | [] ->    false
+    ;;
+
+
+let rec find_Read var_name body =
+match body with | e::rest ->
+    (match e with
+  
+    | Const'(c) -> find_Read  var_name rest
+    | Var'(v) -> if(eq_var var_name v) then true else (find_Read var_name rest)
+    | Box'(v) -> find_Read var_name rest
+    | BoxGet'(v) -> find_Read var_name rest  
+    | BoxSet'(v, exp) -> find_Read var_name (exp::rest)
+    | If'(test, dit, dif) -> find_Read var_name [test] || find_Read var_name [dit] || find_Read var_name  (dif::rest)   
+    | Seq'(lst) -> find_Read var_name (List.append lst rest)
+    | Set'(var, exp) ->  find_Read var_name (exp::rest)
+    | Def'(var, exp) ->  find_Read var_name (exp::rest)
+    | Or'(lst) -> find_Read var_name (List.append lst rest)  
+    | LambdaSimple'(vars, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) vars ) then find_Read var_name rest else find_Read var_name (exp::rest) 
+    | LambdaOpt'(lst, v, exp) -> if(List.exists (function y-> ((compare var_name y) == 0)) lst ) then find_Read var_name rest else find_Read var_name (exp::rest) 
+    | Applic'(exp, lst) ->  find_Read var_name (exp::(List.append lst rest)  )  
+    | ApplicTP'(exp, lst) -> find_Read var_name (exp::(List.append lst rest)  )
+    | _ -> false)
+    | [] ->    false
+    ;;
+
+
+let rec find_Nested_Read var_name expr = 
+    (let (found, bod) = (find_nest  var_name expr ) in
+    if(found) then 
+      find_Read var_name bod 
+    else
+     false)
+    ;;
+
+  let rec find_Nested_Read_list var_name body =
+  match body with |e::rest ->
+  if(find_Nested_Read var_name e ) then true else find_Nested_Read_list var_name rest
+  | [] -> false;;
+
+    let rec find_Nested_Write var_name expr = 
+
+    (let (found, bod) = (find_nest var_name expr) in
+    if(found) then 
+      find_Write var_name bod 
+    else
+     false )
+    ;;
+
+     let rec find_Nested_Write_list var_name body =
+  match body with |e::rest ->
+  if(find_Nested_Write var_name e ) then true else find_Nested_Write_list var_name rest
+  | [] -> false;;
+
+
+
+    let rec find_read_write var_name body =
+    match body with 
+
+    |e::rest ->
+    
+    if(find_Nested_Read var_name e && find_Write var_name rest)
+    then true
+    else
+        let (found, nest) = find_nest var_name e in
+        find_read_write var_name   nest  ||   find_read_write var_name   rest 
+    |[] -> false
+    ;;
+
+     let rec find_write_read var_name body = 
+    match body with 
+
+    |e::rest ->
+     if(find_Nested_Write var_name e && find_Nested_Read_list var_name rest)
+    then true
+    else 
+        let (found, nest) = find_nest var_name e in
+           find_write_read var_name   nest  ||   find_write_read var_name   rest 
+    |[] -> false
+    ;;
+
+
+let check_seq body = 
+  match body with
+  | e::s -> (match e with | Seq'(lst) -> false
+                          | _ -> true)
+  | _ -> true
+  ;;
+  let insert_to_seq expr body =
+  match body with  |e::rest -> match e with
+  |Seq'(lst) -> Seq'(expr::lst)  ;;
+
+
+let remove_TP body =  
+match body with |e::rest -> (match e with | ApplicTP'(x, y)-> Applic'(x,y)::rest   | _->body) | _ -> body;;
+
+
+
+  let rec check_for_read s x = 
+  
+    match s with | e::body ->
+    (match e with
+  
+    | Const'(c) -> check_for_read body x   
+    | Var'(v) -> if(eq_var x v) then (true) else (check_for_read body x)
+    | Box'(v) -> check_for_read body x  
+    | BoxGet'(v) -> check_for_read body x  
+    | BoxSet'(v, expr) -> check_for_read (expr::body) x  
+    | If'(test, dit, dif) -> check_for_read (test::[]) x || check_for_read (dit::[]) x || check_for_read (dif::body) x  
+    | Seq'(lst) -> check_for_read lst x  
+    | Set'(var, expr) -> check_for_read (expr::body) x  
+    | Def'(var, exp) -> check_for_read (exp::body) x  
+    | Or'(lst) -> check_for_read (List.append lst body) x  
+    | LambdaSimple'(vars, expr) -> if(List.exists (function y-> ((compare x y) == 0)) vars ) then check_for_read body x else check_for_read (expr::body) x  
+    | LambdaOpt'(lst, v, expr) -> if(List.exists (function y-> ((compare x y) == 0)) lst ) then check_for_read body x else check_for_read (expr::body) x    
+    | Applic'(exp, lst) ->  check_for_read (exp::(List.append lst body)  ) x    
+    | ApplicTP'(exp, lst) -> check_for_read (exp::(List.append lst body)  ) x 
+    | _ -> false)
+    | [] ->    false
+    ;;
+
+let rec change_box_x s x = match s with | (e::body) -> 
+    (match e with
+    | Var'(v) -> if(eq_var x v) then (BoxGet'(v)::change_box_x body x) else (Var'(v)::change_box_x body x)
+    | Const'(c) -> Const'(c)::change_box_x body x
+    | Box'(v) -> Box'(v)::change_box_x body x
+    | BoxGet'(v) -> BoxGet'(v)::change_box_x body x
+    | BoxSet'(v, expr) -> BoxSet'(v, first_element_expr (change_box_x [expr] x))::change_box_x body x
+    | If'(test, dit, dif) -> If'(first_element_expr (change_box_x (test::[]) x), first_element_expr (change_box_x (dit::[]) x), first_element_expr (change_box_x (dif::[]) x))::change_box_x body x
+    | Seq'(lst) -> Seq'(change_box_x lst x)::change_box_x body x
+    | Set'(v, expr) -> if(eq_var  x v) then (BoxSet'(v, first_element_expr (change_box_x (expr::[]) x))::change_box_x body x) else (Set'(v, first_element_expr (change_box_x (expr::[]) x))::(change_box_x body x))
+    | Def'(var, exp) -> Def'(var, first_element_expr (change_box_x (exp::[]) x))::change_box_x body x
+    | Or'(lst) -> Or'(change_box_x lst x)::change_box_x body x
+    | LambdaSimple'(vars, expr) -> LambdaSimple'(vars, if(eq_var_list x vars) then (expr) else (first_element_expr (change_box_x (expr::[]) x)))::change_box_x body x
+    | LambdaOpt'(lst, v, expr) -> LambdaOpt'(lst, v, if(eq_var_list  x lst) then (expr) else (first_element_expr (change_box_x (expr::[]) x)))::change_box_x body x
+    | Applic'(exp, lst) -> Applic'(first_element_expr (change_box_x (exp::[]) x), (change_box_x lst x))::change_box_x body x
+    | ApplicTP'(exp, lst) -> ApplicTP'(first_element_expr (change_box_x (exp::[]) x), (change_box_x lst x))::change_box_x body x
+    )
+    | [] -> []
+  ;;
+
+let rec check_vars vars body i =
+  match vars with  
+  | x::s -> if(find_read_write x body || find_write_read x body)
+                  then (
+                        if (check_seq body)  
+                            then (check_vars s [(Seq'(Set'(VarParam(x, i), Box'(VarParam(x, i)))::(change_box_x  body x)))] (i-1))  
+                       else (check_vars s [insert_to_seq (Set'(VarParam(x, i), Box'(VarParam(x, i)))) (change_box_x  body x)] (i-1)) )
+            else (check_vars s body (i-1))
+  | [] -> body      
+  ;;
+
+  let rec box_set expr =
+    match expr with
+    | Const'(c) -> Const'(c)
+    | Var'(v) -> Var'(v)
+    | Box'(v) -> Box'(v)
+    | BoxGet'(v) -> BoxGet'(v)
+    | BoxSet'(v, exp) -> BoxSet'(v, box_set exp)
+    | If'(test, dit, dif) -> If'(box_set test, box_set dit, box_set dif)
+    | Seq'(lst) -> Seq'(List.map box_set lst)
+    | Set'(v, exp) -> Set'(v, box_set exp)
+    | Def'(var, exp) ->Def'(var, box_set exp)
+    | Or'(lst) -> Or'(List.map box_set lst)
+    | LambdaSimple'(vars, body) -> LambdaSimple'(vars, (box_set (first_element_expr (check_vars (List.rev vars) (body::[]) ((List.length vars)-1) ))))
+    | LambdaOpt'(vars, v, body) -> LambdaOpt'(vars, v, (box_set (first_element_expr (check_vars (List.rev vars) (body::[]) ((List.length vars)-1)))))
+    | Applic'(exp, lst) -> Applic'(box_set exp, (List.map box_set lst))
+    | ApplicTP'(exp, lst) -> ApplicTP'(box_set exp, (List.map box_set lst))
+    ;;
+
+exception X_syntax_error;;
+
+module type SEMANTICS = sig
+  val run_semantics : expr -> expr'
+  val annotate_lexical_addresses : expr -> expr'
+  val annotate_tail_calls : expr' -> expr'
+  val box_set : expr' -> expr'
+end;;
+
+module Semantics : SEMANTICS = struct
+
+let annotate_lexical_addresses e = annotate_lexical_addresses e ;;
+
+let annotate_tail_calls e = annotate_tail_calls e false;;
+
+let box_set e = box_set e;;
+
+let run_semantics expr =
+  box_set
+    (annotate_tail_calls
+       (annotate_lexical_addresses expr));;
+  
+end;; (* struct Semantics *)
+
+
diff --git a/tag-parser.ml b/tag-parser.ml
new file mode 100644
index 0000000..1b70943
--- /dev/null
+++ b/tag-parser.ml
@@ -0,0 +1,411 @@
+#use "reader.ml";;
+#use "pc.ml";;
+
+
+type constant =
+  | Sexpr of sexpr
+  | Void
+
+type expr =
+ 
+  | Const of constant
+  | Var of string
+  | If of expr * expr * expr
+  | Seq of expr list
+  | Set of expr * expr
+  | Def of expr * expr
+  | Or of expr list
+  | LambdaSimple of string list * expr
+  | LambdaOpt of string list * string * expr
+  | Applic of expr * (expr list);;
+
+let rec expr_eq e1 e2 =
+  match e1, e2 with
+  | Const Void, Const Void -> true
+  | Const(Sexpr s1), Const(Sexpr s2) -> sexpr_eq s1 s2
+  | Var(v1), Var(v2) -> String.equal v1 v2
+  | If(t1, th1, el1), If(t2, th2, el2) -> (expr_eq t1 t2) &&
+                                            (expr_eq th1 th2) &&
+                                              (expr_eq el1 el2)
+  | (Seq(l1), Seq(l2)
+    | Or(l1), Or(l2)) -> List.for_all2 expr_eq l1 l2
+  | (Set(var1, val1), Set(var2, val2)
+    | Def(var1, val1), Def(var2, val2)) -> (expr_eq var1 var2) &&
+                                             (expr_eq val1 val2)
+  | LambdaSimple(vars1, body1), LambdaSimple(vars2, body2) ->
+     (List.for_all2 String.equal vars1 vars2) &&
+       (expr_eq body1 body2)
+  | LambdaOpt(vars1, var1, body1), LambdaOpt(vars2, var2, body2) ->
+     (String.equal var1 var2) &&
+       (List.for_all2 String.equal vars1 vars2) &&
+         (expr_eq body1 body2)
+  | Applic(e1, args1), Applic(e2, args2) ->
+     (expr_eq e1 e2) &&
+       (List.for_all2 expr_eq args1 args2)
+  | _ -> false;;
+	
+                       
+exception X_syntax_error;;
+
+exception Wut;;
+exception Wut2;;
+
+let reserved_word_list_2 =
+  ["and"; "begin"; "cond"; "define"; "else";
+   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+   "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
+   "unquote-splicing"];;
+
+   let sexpr_to_string = 
+    function
+    | Symbol(x) -> (""^x)
+    | _ -> raise X_no_match;;
+  
+  let rec sexpr_to_list sexpr = 
+    match sexpr with 
+    | Pair(x, Nil) -> (match x with Symbol(x) -> [""^x])
+    | Pair(x, y) -> (match x with Symbol(x) -> (x::(sexpr_to_list y)))
+        | s -> (Printf.sprintf "->[%s]", s); []
+    ;;
+
+let symbol_to_string = function
+| Symbol(x) -> x
+| _ -> raise X_no_match
+;;
+
+let rec nilfy tag_parse sexpr origin = 
+match sexpr with
+| Pair(Nil, Nil) -> Const(Void)
+| Pair(x, Nil) -> (tag_parse origin) 
+|Pair(x, y) -> ( match  (nilfy tag_parse y origin), (nilfy tag_parse x origin) with | Const(Void), Const(Void) -> Const(Void) | _-> (tag_parse origin) )
+| x -> (tag_parse origin)
+;;
+
+
+let rec add_to_end pre post =
+match pre with
+| Nil -> post
+|Pair(x,y) -> Pair(x, add_to_end y post);;
+
+let rec remove_seq sexpr =
+match sexpr with
+|Pair(Pair(Symbol("begin"), x), y) -> remove_seq ( add_to_end x y)
+|Pair(x, y) -> Pair(x, remove_seq y)
+| s-> s;;
+
+let rec get_last sexpr =
+match sexpr with
+|Pair(x, y) -> get_last  y
+|s -> s;;
+
+
+let rec chage_last_2Nil sexpr =
+match sexpr with  
+|Pair(x, y) -> Pair(x, chage_last_2Nil y)
+| s -> Nil
+;;
+
+let rec tag_parse tpe = function  (* tpe = tag parse exprisson*)
+
+|Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) ->
+If(tag_parse tpe test, tag_parse tpe dit, Const(Void))
+
+|Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) ->
+If(tag_parse tpe test, tag_parse tpe dit, (nilfy (tag_parse tpe) dif dif) )
+
+| Pair(Symbol("quote"), Nil) -> Const(Sexpr(Nil))
+| Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+| Bool(x) -> Const(Sexpr(Bool(x)))
+| Char(x) -> Const(Sexpr(Char(x)))
+| String(x) -> Const(Sexpr(String(x)))
+| Number(x) -> Const(Sexpr(Number(x)))
+
+| Pair(Symbol("set!"), Pair(Symbol(x), Pair(y, Nil))) ->
+Set(Var(x), tag_parse tpe y)
+| Pair(Symbol("define"), Pair(Symbol(x), Pair(y, Nil))) ->
+Def(Var(x), tag_parse tpe y)
+
+
+| Pair(Symbol("lambda"), Pair(x, Pair( y, Nil))) -> (
+ match (get_last x) with
+  | Nil -> LambdaSimple(sexpr_to_list x, tag_parse tpe ( y))
+  | s ->  LambdaOpt((sexpr_to_list (chage_last_2Nil x)), (sexpr_to_string s), (tag_parse tpe y ))
+)
+| Pair(Symbol("lambda"), Pair(x, Pair( y, z))) ->
+LambdaSimple(sexpr_to_list x, tag_parse tpe ( Pair( y, z)))
+
+|Pair(Symbol("begin"), Pair(x,Nil)) -> tag_parse tpe  (remove_seq x)
+|Pair(Symbol("begin"), x) -> Seq(tpe  (remove_seq x))
+|Pair(Symbol("or"), Nil ) -> Const(Sexpr(Bool(false)))
+|Pair(Symbol("or"), Pair(x, Nil) ) -> tag_parse tpe x
+|Pair(Symbol("or"), x) -> Or(tpe  x)
+|Pair(x, y) -> Applic( tag_parse tpe x, tpe  y)
+| Symbol(x) -> Var(x) 
+;;
+
+
+
+
+let unread_number = function
+| Fraction(n1,n2) -> Printf.sprintf "%d/%d" n1 n2
+| Float(f) -> Printf.sprintf "%f" f
+
+let unread_char c = 
+match c with
+| '\n' -> "#\newline"
+| '\t' -> "#\tab"
+| ' ' -> "#\space"
+(* Fuck it...Skipping the rest of the named chars *)
+| _ -> Printf.sprintf "#\\%c" c;;
+
+let rec unread sexpr = 
+match sexpr with
+| Nil -> "()"
+| Bool(true) -> "#t"
+| Bool(false) -> "#f"
+| Number(n) -> unread_number n
+| Char(c) -> unread_char c
+| String(s) -> Printf.sprintf "\"%s\"" s (* Fuck it...Skipping string meta chars *)
+| Symbol(s) -> s
+| Pair(s1, s2) -> unread_list sexpr
+
+and unread_list = function
+| Pair(a, b) -> Printf.sprintf " %s%s" (unread a) (unread_list b)
+| Nil -> ")"
+| sexpr -> Printf.sprintf "%s)" (unread sexpr);;
+
+let untag expr = 
+let rec untag_rec expr is_nested = 
+match expr with
+| Const(Sexpr(s)) -> unread s
+| Const(Void) when is_nested -> "#<void>"
+| Const(Void) -> ""
+| Var(name) -> unread (Symbol(name))
+| If(test, dit, dif) -> Printf.sprintf "(if %s %s %s)" (untag_nested test) (untag_nested dit) (untag_nested dif)
+| Seq(exprs) -> Printf.sprintf "(begin %s)" (untag_list exprs)
+| Or(exprs) ->  Printf.sprintf "(or %s)" (untag_list exprs)
+| Set(expr1, expr2) -> Printf.sprintf "(set! %s %s)" (untag_nested expr1) (untag_nested expr2)
+| Def(expr1, expr2) -> Printf.sprintf "(define %s %s)" (untag_nested expr1) (untag_nested expr2)
+| LambdaSimple(args, expr) -> Printf.sprintf "(lambda (%s) %s)" (String.concat " " args) (untag_nested expr)
+| LambdaOpt([], arg, expr) -> Printf.sprintf "(lambda %s %s)" arg (untag_nested expr)
+| LambdaOpt(args, arg, expr) -> Printf.sprintf "(lambda (%s . %s) %s)" (String.concat " " args) arg (untag_nested expr)
+| Applic(expr, args) -> Printf.sprintf "(%s %s)" (untag_nested expr) (untag_list args) 
+and untag_nested expr = untag_rec expr true 
+and untag_list exprs = String.concat " " (List.map untag_nested exprs) in
+untag_rec expr false
+
+let print_exprs exprs = 
+let exprs = List.map untag exprs in
+Printf.printf "%s\n" (String.concat "\n" exprs);;
+
+
+
+(**************************** MACRO********************************)
+let rec ex_and me exper = 
+  match exper with 
+  | Pair(x, Nil) -> (me x)
+  | Pair(x, y) -> Pair(Symbol("if"), Pair(me x, Pair( (ex_and me y), Pair(Bool(false), Nil)  ) ))
+  ;;
+
+let rec ex_let_var me sexpr =
+ match sexpr with
+ | Nil -> Nil
+ | Pair( Pair(var, aplic), rest) -> Pair(me var, ex_let_var me rest)
+ ;;
+
+let rec ex_let_aplic me sexpr =
+ match sexpr with
+ | Nil -> Nil
+ | Pair(Pair(var, Pair(aplic, Nil)), rest) -> Pair(me aplic, ex_let_aplic me rest)
+ ;;
+
+
+
+  let rec ex_let me sexpr = (* me = Macro Expansions  *) 
+    match sexpr with 
+    | Pair(x, y) -> Pair (Pair( Symbol("lambda"), Pair (ex_let_var me x, (y))) ,  ex_let_aplic me x)
+    ;;
+  
+
+let rec ex_let_Star_recursion me sexpr code = 
+match sexpr with
+| Nil -> me (Pair(Symbol("let"), Pair( Nil, code)  ))
+| Pair(first, Nil) ->  me (Pair(Symbol("let"), Pair( Pair(first, Nil), code)  ))
+| Pair(first, rest) -> me (Pair(Symbol("let"), Pair( Pair(first, Nil), ex_let_Star_recursion me rest code))) ;;
+
+let rec ex_let_star me sexpr =
+match sexpr with
+|Pair(Symbol("let*"), Pair(x, y)) -> ex_let_Star_recursion me x y ;;
+
+
+let rec ex_let_rec_set me sexpr post =
+match sexpr with
+ | Nil -> post
+ | Pair( Pair(var, aplic), rest) -> Pair(Pair(Symbol("set!"), Pair(var, me aplic)), ex_let_rec_set me rest post)
+ ;;
+
+let rec ex_let_rec_initial_vals  me sexpr =
+match sexpr with
+ | Nil -> Nil
+ | Pair(Pair(var, aplic), rest) -> Pair( Pair(var, Pair(Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)), Nil)),ex_let_rec_initial_vals me rest) 
+ ;;
+
+let rec ex_let_rec me sexpr =
+ match sexpr with 
+    | Pair(x, y) ->Pair(Symbol("let"), Pair (ex_let_rec_initial_vals me x  ,  ex_let_rec_set me x y  ) )
+    ;;
+
+
+
+
+
+
+let rec open_pair sexpr =
+match sexpr with
+| Pair(value, Nil) -> value
+| Pair(x, y) -> Pair(Symbol("begin"), (Pair( x, y )) )
+| x -> x ;;
+
+
+let ex_cond_gen_lambda ex_cond me sexpr = 
+match sexpr with
+| Nil -> Nil
+| rest ->Pair
+         (Pair (Symbol "rest",
+           Pair
+            (Pair (Symbol "lambda",
+              Pair (Nil,  ex_cond me rest )),
+            Nil)),
+         Nil)
+;;
+
+let ex_cond_apply_rest sexpr =
+match sexpr with
+| Nil -> Nil
+| rest -> Pair (Pair (Symbol "rest", Nil), Nil) 
+;;
+
+  let rec ex_cond me sexpr =
+  match sexpr with
+  | Nil -> Nil
+  | Pair (Pair(test,Pair(Symbol("=>"), Pair(result, Nil) )), rest) -> 
+(me ( Pair (Symbol "let",
+    Pair
+     (Pair (Pair (Symbol "value", Pair (test, Nil)),
+       Pair
+        (Pair (Symbol "f",
+          Pair
+           (Pair (Symbol "lambda", Pair (Nil, Pair(result , Nil))),
+           Nil)),
+        ex_cond_gen_lambda ex_cond me rest)),
+     Pair
+      (Pair (Symbol "if",
+        Pair (Symbol "value",
+         Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
+           ex_cond_apply_rest rest))),
+      Nil)))  ) )
+
+  | Pair(Pair(Symbol("else"), result), rest) -> me (open_pair result)
+  | Pair(Pair(test, result), Nil) -> Pair(Symbol("if"), Pair(me test, Pair(me (open_pair result), Nil))) 
+  | Pair(Pair(test, result), rest) -> Pair(Symbol("if"), Pair(me test, Pair(me (open_pair result), Pair (ex_cond me rest, Nil))) )
+
+
+  | _ -> raise Wut
+;;
+
+
+  let ex_define me sexpr = (* me = Macro Expansions  *) 
+    match sexpr with 
+    | Pair(Pair(x, y), z) -> Pair(Symbol("define"), Pair(x, Pair( Pair(Symbol("lambda"), Pair(y, Pair(Symbol("begin"), me z))), Nil) ))  
+    | s -> s
+    ;;
+
+    let rec ex_pset sexpr = 
+    match sexpr with 
+    | Pair( Pair(x, Pair(y, Nil)), Nil) -> Pair(Symbol("set!"), Pair(Pair(x, Pair(y, Nil)), Nil))
+    | Pair( Pair(x, Pair(y, Nil)), z) -> Pair(Symbol("set!"), Pair(Pair(x, Pair(y, Nil)), ex_pset z))
+    ;;
+    (*Pair(pset, Pair( Pair(x, Pair(y, Nil)), Pair(Pair(y, Pair(x, Nil)),   )  ))*)
+
+    let rec ex_quasiquote sexpr =
+      match sexpr with  
+      |Pair(Symbol(x), Nil) (*(a)*) -> Pair(Symbol("cons"),  Pair(Pair(Symbol("quote"), Pair(Symbol(x), Nil)),Pair(Pair(Symbol("quote"), Nil) ,Nil))) (*Const x*)
+      |Pair(Pair(Symbol("unquote"), Pair(Symbol(x), Nil)), Nil) -> Pair(Symbol("cons"), Pair(Symbol(x), Pair(Pair(Symbol("quote"), Nil) ,Nil)))
+      |Pair(Pair (Pair (Symbol "unquote", Pair (Symbol(x), Nil)),Pair (Symbol   "unquote-splicing", Pair (Symbol(y), Nil))),Nil) -> Pair(Symbol("cons"), Pair(Symbol(x), Symbol(y)))
+      |Pair(Pair(Symbol("unquote"), Pair(Symbol(x), Nil)), y) -> Pair(Symbol("cons"), Pair(Symbol(x), Pair( ex_quasiquote y, Nil)))
+
+      |Pair (Symbol "unquote", Pair (Symbol(y), Nil)) -> Symbol(y)
+      |Pair(Symbol("unquote-splicing"), Pair(Symbol(x), Nil)) -> Symbol(x)
+      |Pair(Pair(Symbol("unquote-splicing"), Pair(Symbol(x), Nil)), Nil) -> Pair(Symbol("append"), Pair(Symbol(x), Pair(Pair(Symbol("quote"), Nil) ,Nil)))
+      |Pair(Pair(Symbol("unquote-splicing"), Pair(Symbol(x), Nil)), y) -> Pair(Symbol("append"), Pair(Symbol(x),Pair( ex_quasiquote y, Nil)))
+    
+     (* |Pair(x, y) -> Pair(Symbol("cons"), Pair(Pair(Symbol("qoute"), Pair(x, Nil)), ex_quasiquote y))  *)
+      
+      |Pair(Symbol(x), y) -> Pair(Symbol("cons"), Pair(Pair(Symbol("quote"), Pair(Symbol(x), Nil)), Pair(ex_quasiquote y, Nil)))
+      |Pair(x, Nil) -> Pair(Symbol("cons"), Pair(ex_quasiquote x, Pair(Pair(Symbol("quote"), Nil) ,Nil)))
+      |Pair(x, y) -> Pair( Symbol("cons"),  Pair( ex_quasiquote x, Pair(ex_quasiquote( y), Nil)) )
+       |Symbol(x) -> Symbol(x)
+      ;;
+
+
+
+
+
+  let rec macro_expansions sexpr = 
+    match sexpr with
+    |Pair(Symbol("and"), Nil ) -> Bool(true)
+    |Pair(Symbol("and"), Pair(x, Nil)) -> Pair(Symbol("or"), Pair((macro_expansions x), Nil))
+    |Pair(Symbol("and"), x) ->  ex_and macro_expansions (macro_expansions x)  
+    |Pair(Symbol("cond"), Pair(Pair(x, Nil), Nil))  -> Pair(Symbol("if"), (macro_expansions x))
+    |Pair(Symbol("cond"), rest) -> (ex_cond macro_expansions rest)
+    |Pair(Symbol("let"), rest) -> ex_let macro_expansions rest
+    |Pair(Symbol("let*"), rest) -> macro_expansions (ex_let_star macro_expansions sexpr)
+    |Pair(Symbol("letrec"), rest) -> macro_expansions( ex_let_rec macro_expansions rest)
+    |Pair(Symbol("define"), Pair(Pair(x, y), z)) -> ex_define macro_expansions (Pair(Pair(x, y), z)) 
+    |Pair(Symbol("pset!"), rest) -> Pair(Symbol("begin"), ex_pset rest)
+    |Pair(Symbol("quasiquote"), Pair(rest, Nil)) -> ex_quasiquote rest 
+    |Pair(x,y) -> Pair(macro_expansions x, macro_expansions y)
+    | s -> s
+    ;;
+
+
+(*quasi 
+
+let*
+let-rec
+MIT-dfine
+P-set*)
+
+(* model *)
+let rec pair_to_list sexpr = match sexpr with
+  |Nil -> []
+  |Pair(x, y) -> x:: (pair_to_list y)
+  |s -> [s]
+;;
+
+let tpe_convertor tpe x = tpe (pair_to_list x);;
+
+
+module type TAG_PARSER = sig
+  val tag_parse_expressions : sexpr list -> expr list
+end;; (* signature TAG_PARSER *)
+
+module Tag_Parser : TAG_PARSER = struct
+
+let reserved_word_list =
+  ["and"; "begin"; "cond"; "define"; "else";
+   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+   "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
+   "unquote-splicing"];;  
+
+(* work on the tag parser starts here *)
+
+
+let rec tag_parse_expressions sexpr = 
+  match sexpr with
+  | [] -> []
+  | (e::s) -> ((tag_parse (tpe_convertor tag_parse_expressions)) (macro_expansions e)):: (tag_parse_expressions s);
+
+  
+end;; (* struct Tag_Parser *)
+
