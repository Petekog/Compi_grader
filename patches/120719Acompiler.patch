diff --git a/pc.ml b/pc.ml
index 6a25660..23db78b 100644
--- a/pc.ml
+++ b/pc.ml
@@ -6,6 +6,17 @@
 
 (* general list-processing procedures *)
 
+
+(*
+e = expression
+es = expressions
+s = string
+f = function
+nt = non terminal
+ch = char
+ci = case insensitive
+*)
+
 let rec ormap f s =
   match s with
   | [] -> false
@@ -48,15 +59,34 @@ let const pred =
      if (pred e) then (e, s)
      else raise X_no_match;;
 
+     (*The caten combinator essentially takes two functions (since parsers created using
+PC are functions), and constructs a new function (i.e. parser). The caten function
+adds the control flow that sends the input into the first parser, and then sends the
+remaining list of that first parser to the second parser.
+The caten operator produces tuples, the type of the tuple elements depends 
+on the packing of the underlying parsers.*)
+
 let caten nt1 nt2 s =
   let (e1, s) = (nt1 s) in
   let (e2, s) = (nt2 s) in
   ((e1, e2), s);;
 
+  (*we use the pack combinator to transform the accepted tokens (characters) 
+  into an internal representation used in our parse tree.
+   we give the combinator pack two arguments : the first
+one is a parser , and the second is function to process the result of parsing ( Lets call it func_proc ). 
+The output of our parses is the following
+(parsing_result, list_of_remaining_chars). So what actually pack do is
+(func_proc(parsing_result), list_of_remaining_chars) , applies func_proc
+to parsing_result .*)
+
 let pack nt f s =
   let (e, s) = (nt s) in
   ((f e), s);;
 
+  (*parser that reads nothing.
+  we use it in cases where we use abstract combinator that expect 2 parser, but we parse nothing on the left,
+  so we use it as a dummy place holder *)
 let nt_epsilon s = ([], s);;
 
 let caten_list nts =
@@ -67,6 +97,11 @@ let caten_list nts =
     nts
     nt_epsilon;;
 
+    (*The disj combinator (which implements disjunction) takes two
+functions, and constructs a sort of ”or” statement between them, where if the first
+parser rejects the input (i.e. raises X_no_match) the input is then sent to the second
+parser instead.*)
+
 let disj nt1 nt2 =
   fun s ->
   try (nt1 s)
@@ -83,6 +118,7 @@ let nt_end_of_input = function
   | []  -> ([], [])
   | _ -> raise X_no_match;;
 
+  (*takes a parser and a string, and parses the strin zero or more time as long as it can parse*)
 let rec star nt s =
   try let (e, s) = (nt s) in
       let (es, s) = (star nt s) in
@@ -93,6 +129,13 @@ let plus nt =
   pack (caten nt (star nt))
        (fun (e, es) -> (e :: es));;
 
+(* takes nt and pred (predicate) and returns a parser.
+The parser parse the string only if pred(s) = true.
+we first define result to be (e ,s) as if nt did parse s.
+onlt then, wh check if we get true from pred (e), and if we do we return the (e, s) = result we parsed before.
+else, if pred (e) = false, we return x_no_match.
+ *)
+
 let guard nt pred s =
   let ((e, _) as result) = (nt s) in
   if (pred e) then result
@@ -113,50 +156,88 @@ let not_followed_by nt1 nt2 s =
 	 with X_no_match -> (Some(result))) with
   | None -> raise X_no_match
   | Some(result) -> result;;
-	  
+    
+  
+(*takes a nt and returns a parser "fun s" = "lambda s".
+the function is taking the string s and try to parse it with nt. 
+If succeed, returns (Some (e), s) = the e that was parsed and the remained string s.
+else, returns (None, s)  = the string remains as it was.
+So we are promised to get back something like (Some e, s) or (None, s) - which is better than "X_no_macth".
+
+*) 
 let maybe nt s =
   try let (e, s) = (nt s) in
       (Some(e), s)
   with X_no_match -> (None, s);;
 
-(* useful general parsers for working with text *)
+(* useful general parsers for working with text 
+
+The char parser-constructor takes a single character, C, and returns a parser (i.e.
+function) which takes a list of character and returns a pair. That pair is composed
+of the first character of the list, if it’s C, and the rest of the list. So for example:
+    # let _a_ = (char 'a');;
+    # _a_ (string_to_list "abc");;
+    - : char * char list = ('a', ['b'; 'c'])
+If the first char on the list is not C, the parser will raise an X_no_match exception.*)
 
+
+(* takes equal=predicate, and ch1 (some char),
+and returns parser that checks if ch1 and ch2 are "equals"
+ (the predicate equal returns true when given ch1 an ch2).
+*)
 let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
 
+(*the difference between char and char_ci is a different predicate given to make_char (case sensitive or insensitive*)
 let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
 
+(*takes 2 chars, make them lower case, and only then compare them using "="*)
 let char_ci =
   make_char (fun ch1 ch2 ->
 	     (lowercase_ascii ch1) =
-	       (lowercase_ascii ch2));;
-
+         (lowercase_ascii ch2));;
+         
+(*builds a parser that "recognize" the given word "str"*)
 let make_word char str = 
   List.fold_right
     (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
-    (List.map char (string_to_list str))
+    (List.map char (string_to_list str))   (*takes the str, make it a list of chars (["s";"t";"r"]), and than performs "char"
+                                           (builds a parser that parses the specific char) on every char of the list(that's the "map" part),
+                                           so we get a list of parsers *)
     nt_epsilon;;
 
+(*word - pareses a given word with case sensitive,
+  word_ci = parses a given wors with case INsensitive.
+ we make this different by giving make word different parsers (char or char_ci)*)
 let word = make_word char;;
 
 let word_ci = make_word char_ci;;
 
+
+(*builds a parser than parse a group of chars.
+for example:
+  one_of "abc"
+will return a parser that parses the letters "a", "b" or "c" *)
 let make_one_of char str =
   List.fold_right
     disj
     (List.map char (string_to_list str))
     nt_none;;
-
+(*builds a case sensitive parser using make_one_of*)
 let one_of = make_one_of char;;
-
+(*builds a case INsensitive parser using make_one_of*)
 let one_of_ci = make_one_of char_ci;;
 
 let nt_whitespace = const (fun ch -> ch <= ' ');;
 
+(*builds a parser than parse a group of chars in a given range.
+for example:
+  range 'a' 'k'
+will return a parser that parses the letters 'a','b','c'...'k' *)
 let make_range leq ch1 ch2 (s : char list) =
-  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
-
+  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;; (*leq = less or equal. basically it says (ch1 <= ch) && (ch <= ch2)*)
+(*builds a case sensitive parser using make_range*)
 let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
-
+(*builds a case INsensitive parser using make_range*)
 let range_ci =
   make_range (fun ch1 ch2 ->
 	      (lowercase_ascii ch1) <=
@@ -164,6 +245,15 @@ let range_ci =
 
 let nt_any (s : char list) = const (fun ch -> true) s;;
 
+(*This function helps to debug our parser. it allows as to get informative errors, rather then "x_no_match".
+it takes documentation string and a parser (and optionally a word we check), and returns a tracing parser.
+for example:
+  test_string (trace_pc "the word \"hi\"" (word "hi")) "high"
+returns 
+;;; The word "hi" matched the head of "high",
+    and the remaining string is "gh"
+- : char 1list * string = (['h': 'i'], "=>[gh]")
+ *)
 let trace_pc desc nt s =
   try let ((e, s') as args) = (nt s)
       in
diff --git a/reader.ml b/reader.ml
index 32445c2..c1929a1 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,6 @@
 
 #use "pc.ml";;
+open PC ;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -29,18 +30,262 @@ let rec sexpr_eq s1 s2 =
   | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
   | _ -> false;;
 
-module Reader: sig
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
 
+(* <Single Basics> *)
+  let p_dot = char '.';;
+  let p_lparen = char '(';;
+  let p_rparen = char ')';;
+  let p_slesh = char '/';;
+  let p_Dquate = char '"';;
+  let p_Quate = char '\'';;
+  let p_QQquate = char '`';;
+  let p_Unquate = char ',';;
+  let p_UnquateSliced = word ",@";;
+  let p_semicolon = char ';';;  
+  let p_enter = char '\n';;  
+  let p_sexp_comment = word "#;";;
+  let p_e = word_ci "e";; 
+  let digit = range '0' '9';;
+  let nt_whitespaces = star nt_whitespace;;
+  let make_paired nt_left nt_right nt = 
+    let nt = caten nt_left nt in 
+    let nt = pack nt(function(_, e) -> e) in 
+    let nt = caten nt nt_right in
+    let nt = pack nt(function(e, _) -> e) in
+      nt;;
+  let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
 
-let read_sexprs string = raise X_not_yet_implemented;;
+(* <Char> *)
+  let tok_char_prefix = word "#\\";; 
+  let p_char = const (fun (char) -> char > ' ');;
+  let tok_vis_simple_char = pack p_char (fun (c) -> Char(c));;
+  let tok_named_char = disj_list [pack (word_ci "newline") (fun (n_ch) -> Char('\010')); 
+                                  pack (word_ci "nul") (fun (n_ch) -> Char('\000'));
+                                  pack (word_ci "page") (fun (n_ch) -> Char('\012'));
+                                  pack (word_ci "return") (fun (n_ch) -> Char('\013'));
+                                  pack (word_ci "space") (fun (n_ch) -> Char('\032'));
+                                  pack (word_ci "tab") (fun (n_ch) -> Char('\009'));];;
+  let tok_char = pack (caten tok_char_prefix 
+                          (disj tok_named_char tok_vis_simple_char)) 
+                  (fun (pre, ch) -> ch);;
+
+(* <Symbol> *)
+  let p_letters = range 'a' 'z';;
+  let p_Capletters = pack (range 'A' 'Z') (fun (ch) -> lowercase_ascii ch);;
+  let p_signs = one_of ("!$^*-_=+<>?/:");;
+
+  let tok_sym_no_dot = disj_list [digit; p_letters; p_Capletters; p_signs];;
+
+  let tok_sym_char = disj tok_sym_no_dot p_dot;;
+
+  let tok_symbol = 
+        let sym = pack tok_sym_char (fun (ch)->[ch])
+        and syms = plus tok_sym_char in
+        let _p = caten sym syms in
+        let lensym = pack _p (fun (sym, syms) -> List.append sym syms) 
+        and nodotsym = pack tok_sym_no_dot (fun (ch) -> [ch]) in
+        let symbol = disj lensym nodotsym in
+        pack symbol (fun (sym) -> Symbol(list_to_string sym));;
+
+(* <Boolean> *)
+  let tok_bool = 
+      let tok_true = pack (word_ci "#t") (fun (bool) -> Bool(true))
+      and tok_false = pack (word_ci "#f") (fun (bool) -> Bool(false)) in
+      not_followed_by (disj tok_true tok_false) tok_symbol;;
+
+      
+(* <Number> *)
+  let rec gcd a b = 
+    match a with 
+    | 0 -> b 
+    | _ -> gcd (b mod a) a;;
+  let nt_sign = maybe (one_of "+-");;
+  let tok_natural = plus digit;;
+
+  let tok_integer = 
+    let p = caten nt_sign tok_natural in 
+    pack p (fun (op, num) -> 
+              match op with 
+                | Some '-' -> Number(Fraction(int_of_string("-"^(list_to_string num)), 1))
+                | Some '+' | None -> Number(Fraction(int_of_string(list_to_string num), 1))
+                | Some a  -> raise X_no_match);;
+
+  let tok_float = 
+      let _p = caten nt_sign (caten tok_natural (caten p_dot tok_natural)) in 
+      pack _p (fun (op, (left, (dot, right))) ->
+        let str_num = (list_to_string left)^"."^(list_to_string right) in               
+        match op with 
+          | Some '-' -> Number(Float(float_of_string("-"^str_num)))
+          | Some '+' | None -> Number(Float(float_of_string(str_num)))
+          | Some a  -> raise X_no_match);;
+
+  let tok_int_e = 
+      let _p = caten nt_sign (caten tok_natural (caten p_e (caten nt_sign tok_natural))) in 
+      pack _p (fun (l_op, (l_num, (e, (r_op, r_int)))) ->
+        let str_int_one = (list_to_string l_num) in               
+        let num_one = match l_op with 
+          | Some '-' -> float_of_string("-"^str_int_one)
+          | Some '+' | None -> float_of_string(str_int_one)
+          | Some a -> raise X_no_match in
+        let str_int_two = (list_to_string r_int) in               
+        let num_two = match r_op with 
+          | Some '-' -> float_of_string("-"^str_int_two)
+          | Some '+' | None -> float_of_string(str_int_two)
+          | Some a -> raise X_no_match in
+        let ans = (num_one *. (10.0 ** num_two)) in
+        Number(Float(ans)));;
+
+  let tok_float_e = 
+      let _p = caten nt_sign (caten tok_natural (caten p_dot (caten tok_natural (caten p_e (caten nt_sign tok_natural))))) in 
+      pack _p (fun (l_op, (l_float, (dot, (r_float, (e, (r_op, r_int)))))) ->
+        let str_float = (list_to_string l_float)^"."^(list_to_string r_float) in               
+        let float = match l_op with 
+          | Some '-' -> float_of_string("-"^str_float)
+          | Some '+' | None -> float_of_string(str_float) 
+          | Some a -> raise X_no_match in
+
+        let str_int = (list_to_string r_int) in               
+        let num = match r_op with 
+          | Some '-' -> float_of_string("-"^str_int)
+          | Some '+' | None -> float_of_string(str_int) 
+          | Some a -> raise X_no_match in
+ 
+        let ans = (float *. (10.0 ** num)) in
+        Number(Float(ans)));;
+
+  let tok_scei_not = disj tok_int_e tok_float_e;;
+            
+  let tok_fraction = 
+      let _p = caten nt_sign (caten tok_natural (caten p_slesh tok_natural)) in 
+      pack _p (fun (op, (up, (slesh, down))) ->
+        let str_up = list_to_string up
+        and str_down = list_to_string down in  
+        let num_up = int_of_string(str_up)
+        and num_down = int_of_string(str_down) in
+        let my_gcd = gcd num_up num_down in
+        match op with 
+          | Some '-' -> Number(Fraction((-1) * (num_up / my_gcd), (num_down / my_gcd)))
+          | Some '+' | None -> Number(Fraction((num_up / my_gcd), (num_down / my_gcd)))
+          | Some a -> raise X_no_match);;
+
+  let tok_number = not_followed_by (disj_list [tok_scei_not; tok_float; tok_fraction; tok_integer]) tok_symbol;; 
+
+(* <String> *)
+  let tok_str_meta_char = 
+    let p1 = pack (word_ci "\\\\") (fun (word) -> char_of_int 92)
+    and p2 = pack (word_ci "\\\"") (fun (word) -> char_of_int 34)
+    and p3 = pack (word_ci "\\t") (fun (word) -> char_of_int 9)
+    and p4 = pack (word_ci "\\f") (fun (word) -> char_of_int 12)
+    and p5 = pack (word_ci "\\n") (fun (word) -> char_of_int 10)
+    and p6 = pack (word_ci "\\r") (fun (word) -> char_of_int 13) in
+    disj_list[p1; p2; p3; p4; p5; p6];;
+
+  let tok_str_lit_char = pack (const (fun (char) -> char != '\092' && char != '\034')) (fun (ch) -> ch);; 
+  let tok_string_char = disj tok_str_lit_char tok_str_meta_char;;
+
+  let tok_string = 
+    let _p = make_paired p_Dquate p_Dquate (star tok_string_char) in
+    pack _p (fun (lst) -> String(list_to_string lst));; 
+
+    
+(* <Sexp> *)
+  let rec make_nested_pair lst =
+    match lst with
+    | [] -> Nil
+    | car :: cdr -> Pair(car, (make_nested_pair cdr));;
+
+  let rec make_nested_pair_dotted lst =
+    match lst with
+    | car :: [] -> car
+    | car :: cdr -> Pair(car, (make_nested_pair_dotted cdr))
+    | _ -> raise X_no_match;;
+  
+  let rec tok_sexp list = 
+    let p_rec = disj_list [tok_bool; tok_char; tok_number; 
+                              tok_string; tok_symbol; 
+                              tok_list; tok_dotted_list; 
+                              tok_Quoted; tok_QQuoted; tok_UnQuoted; 
+                              tok_UnQuotedSpliced] in
+    
+    let p_no_comments = make_skip p_rec in
+    (p_no_comments list)
+    
+    and tok_list list = 
+      let skip_l = make_skip (pack p_lparen (fun (nt) -> Char(' '))) 
+      and skip_r = make_skip (pack p_rparen (fun (nt) -> Char(' ')))  in
+      let _p = caten skip_l (caten (star tok_sexp) skip_r) in
+      (* let _p = caten p_lparen (caten (star tok_sexp) p_rparen) in *)
+      let _p = (pack _p (fun (lp, (sexp_lst, rp)) -> (make_nested_pair sexp_lst))) in
+      (_p list)
+
+    and tok_dotted_list list = 
+      let _p = caten p_lparen (caten (plus tok_sexp) (caten p_dot (caten tok_sexp p_rparen))) in
+      let _p = (pack _p (fun (lp, (sexp_lst, (dot, (sexp, rp)))) -> 
+                  make_nested_pair_dotted (List.append sexp_lst [sexp]))) in
+      (_p list)
+
+    and tok_Quoted list = 
+      let _p = caten p_Quate tok_sexp in
+      let _p = (pack _p (fun (q, sexp) -> Pair(Symbol("quote"), Pair(sexp, Nil)))) in
+      (_p list)
+
+    and tok_QQuoted list = 
+      let _p = caten p_QQquate tok_sexp in
+      let _p = (pack _p (fun (qs, sexp) -> Pair(Symbol("quasiquote"), Pair(sexp, Nil)))) in
+      (_p list)
+
+    and tok_UnQuoted list = 
+      let _p = caten p_Unquate tok_sexp in
+      let _p = (pack _p (fun (unq, sexp) -> Pair(Symbol("unquote"), Pair(sexp, Nil)))) in
+      (_p list)
+
+    and tok_UnQuotedSpliced list = 
+      let _p = caten p_UnquateSliced tok_sexp in
+      let _p = (pack _p (fun (unqs, sexp) -> Pair(Symbol("unquote-splicing"), Pair(sexp, Nil)))) in
+      (_p list)
+
+    and tok_sexp_comment list = 
+      let _p = (caten p_sexp_comment tok_sexp) in
+      let _p = pack _p (fun (ch) -> 'c') in
+      (_p list)
+
+    and tok_line_comment list = 
+      let p_enterOrEOI = disj (pack (const (fun (char) -> char == '\n')) (fun (e) -> [e])) nt_end_of_input in
+      let _p = caten p_semicolon (caten (star (diff nt_any p_enterOrEOI)) p_enterOrEOI) in
+      let _p = pack _p (fun (sc, (lstcom, enter)) -> sc) in
+      (_p list)
+    
+    and p_skip list =
+    let _p = star (disj_list [tok_line_comment; nt_whitespace; tok_sexp_comment;])  in
+    (_p list)
+
+    and make_skip nt = make_paired p_skip p_skip nt
+
+    and make_comment nt = make_paired tok_sexp_comment tok_sexp_comment nt;;
+
+
+
+(* <Big recursion> *)
+  module Reader: sig
+    val read_sexprs : string -> sexpr list
+  end
+  = struct
+  let normalize_scheme_symbol str =
+    let s = string_to_list str in
+    if (andmap
+    (fun ch -> (ch = (lowercase_ascii ch)))
+    s) then str
+    else Printf.sprintf "|%s|" str;;
+
+
+  let rec read_sexprs string = 
+    let curr_parsed = tok_sexp (string_to_list string) in 
+      let hd = fst curr_parsed 
+      and tail = snd curr_parsed in
+        match tail with
+          | [] -> [hd]
+          | _ -> List.append [hd] (read_sexprs (list_to_string tail));;
+  
+  
   
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..cb4e0b0 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,5 @@
+Hadas Zeira 204778419
+Roee Benhouse 308107085
+
+
+I (We) assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the Internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 914a630..dcea959 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,4 +1,6 @@
 #use "tag-parser.ml";;
+open Reader;;
+open Tag_Parser;;
 
 type var = 
   | VarFree of string
@@ -61,17 +63,427 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+(* lexical_addresses *)
+let rec findLocInParams var params loc = 
+  if (List.length params == 0)
+  then -1
+  else (
+    if (compare (List.hd params) var == 0)
+    then loc
+    else findLocInParams var (List.tl params) (loc+1));;
 
-let box_set e = raise X_not_yet_implemented;;
+let rec findMajMin var env maj = 
+    if((compare (List.hd env) [] == 0) && ((List.length env) == 1) )
+      then (-1, -1)
+      else (
+    let head = List.hd env 
+    and tail = List.tl env in
+    let min = findLocInParams var head 0 in
+    if (min == -1)
+      then (findMajMin var tail (maj+1))
+      else (maj, min));;
+
+let var_lexi_add var env params = 
+    let loc = findLocInParams var params 0 in
+    if (loc != -1)
+      then VarParam (var, loc)
+      else  
+    (let maj, min = 
+      match env with 
+        | hd :: tl -> (findMajMin var env 0)
+        | _ -> (-1,-1) in
+      if(min != -1)
+        then VarBound(var, maj, min)
+        else VarFree(var));;
+
+
+let rec annotate_lex_helper env params e =
+  match e with
+  | Const(c) -> Const'(c)
+
+  | If(test, thenExp, elseExp) -> 
+        If'(annotate_lex_helper env params test, 
+            annotate_lex_helper env params thenExp, 
+            annotate_lex_helper env params elseExp)
+
+  | Seq(list) ->     
+        Seq' (List.map (annotate_lex_helper env params) list)
+
+  | Set(Var(var), value) -> 
+        Set'(var_lexi_add var env params, 
+              annotate_lex_helper env params value)
+
+  | Def(Var(var), value) -> 
+        Def'(VarFree(var), 
+              annotate_lex_helper env params value)
+
+  | Or(list) ->
+        Or' (List.map (annotate_lex_helper env params) list)
+
+  | LambdaSimple(listStr, body) -> 
+        LambdaSimple' (listStr, 
+                        annotate_lex_helper (params :: env) listStr body)
+
+  | LambdaOpt(listStr, variadic, body) -> 
+        LambdaOpt' (listStr, 
+                      variadic, 
+                        annotate_lex_helper (params :: env) (List.append listStr [variadic]) body)
+
+  | Applic(exp, expList) -> 
+        Applic' (annotate_lex_helper env params exp, 
+                  List.map (annotate_lex_helper env params) expList)
+
+  | Var(var) -> Var'(var_lexi_add var env params)
+
+  | _ -> raise X_syntax_error;;
+
+let annotate_lexical_addresses e = 
+    annotate_lex_helper [] [] e;; 
+
+(* tail calls *)
+let rec annotate_tail_helper e tp = 
+
+    let rec handle_tail_list exprs tp = 
+      match exprs with 
+        | [] -> []
+        | first :: [] -> [annotate_tail_helper first tp]
+        | first :: rest -> List.append [annotate_tail_helper first false] (handle_tail_list rest tp) in
+
+    let handle_tail_applic proc exprs tp = 
+      if(tp) 
+        then ApplicTP'(annotate_tail_helper proc false, handle_tail_list exprs false)
+        else Applic'(annotate_tail_helper proc false, handle_tail_list exprs false) in
+
+    match e with 
+      | Const'(c) -> Const'(c)
+      | Var'(v) -> Var'(v)
+      | If'(test, dit, dif) -> If'(annotate_tail_helper test false, annotate_tail_helper dit tp, annotate_tail_helper dif tp)
+      | Seq'(exprs) -> Seq'(handle_tail_list exprs tp)
+      | Set'(var, expr) -> Set'(var, annotate_tail_helper expr false)
+      | Or'(exprs) -> Or'(handle_tail_list exprs tp)
+      | Def'(var, expr) -> Def'(var, annotate_tail_helper expr false)
+      | LambdaSimple'(params, body) -> LambdaSimple'(params, annotate_tail_helper body true)
+      | LambdaOpt'(params, variadic, body) -> LambdaOpt'(params, variadic, annotate_tail_helper body true)
+      | Applic'(proc, exprs) -> (handle_tail_applic proc exprs tp) 
+      | _ -> raise X_syntax_error;;
+
+let annotate_tail_calls e = 
+  let tp = false in
+  annotate_tail_helper e tp;;
+
+(* boxing *)
+
+let rec box_helper exp = 
+
+  let box_get_var var minor major v = 
+    match v with 
+      | VarParam(v_str, min) -> 
+                                if(String.equal var v_str)
+                                then BoxGet'(VarParam(var, min))
+                                else Var'(VarParam(v_str, min))
+      | VarBound(v_str, maj, min) ->
+                                if(String.equal var v_str)
+                                then BoxGet'(VarBound(var, maj, min))
+                                else Var'(VarBound(v_str, maj, min))
+      | VarFree(v_str) -> Var'(VarFree(v_str)) in
+
+ 
+  let rec do_boxing_to var minor major body =
+    let box_set_var var minor major v expr = 
+        match v with 
+          | VarParam(v_str, min) -> 
+                                    if(String.equal var v_str)
+                                    then BoxSet'(v, do_boxing_to var minor major expr)
+                                    else Set'(v, do_boxing_to var min major expr) 
+          | VarBound(v_str, maj, min) ->
+                                    if(String.equal var v_str)
+                                    then BoxSet'(v, do_boxing_to var minor major expr)
+                                    else Set'(v, do_boxing_to var min maj expr)
+          | VarFree(v_str) -> Set'(v, do_boxing_to var minor major expr) in
+
+      
+    match body with 
+      | Const'(c) -> Const'(c)
+      | Var'(v) -> box_get_var var minor major v
+      | BoxGet'(v) -> BoxGet'(v)
+      | If'(test, dit, dif) -> If'(do_boxing_to var minor major test, 
+                                    do_boxing_to var minor major dit, 
+                                      do_boxing_to var minor major dif)
+      | Seq'(exprs) -> Seq'(List.map (do_boxing_to var minor major) exprs)
+      | Set'(v, expr) -> box_set_var var minor major v expr
+      | BoxSet'(v, expr) -> BoxSet'(v, do_boxing_to var minor major expr)
+      | Or'(exprs) -> Or'(List.map (do_boxing_to var minor major) exprs)
+      | Def'(v, expr) -> Def'(v, do_boxing_to var minor major expr)
+      | Applic'(proc, exprs) -> Applic'(do_boxing_to var minor major proc, List.map (do_boxing_to var minor major) exprs)
+      | ApplicTP'(proc, exprs) -> ApplicTP'(do_boxing_to var minor major proc, List.map (do_boxing_to var minor major) exprs)  
+      | LambdaSimple'(params, lam_body) -> 
+            if(List.mem var params)
+            then LambdaSimple'(params, lam_body)
+            else LambdaSimple'(params, do_boxing_to var minor (major+1) lam_body)
+      | LambdaOpt'(params, variadic, lam_body) -> 
+            if(List.mem var params)
+            then LambdaOpt'(params, variadic, lam_body)
+            else LambdaOpt'(params, variadic, do_boxing_to var minor (major+1) lam_body)
+      | _ -> body in
+
+  
+  let rec need_boxing var body = 
+
+      let rec need_boxing_or var exprs = 
+        match exprs with 
+          | [] -> false
+          | exp :: rest -> 
+            let tmp = need_boxing var exp in
+            if(tmp) then tmp else need_boxing_or var rest in 
+
+      let rec or_to_list var exprs func = 
+        match exprs with 
+          | [] -> (false, -2)
+          | exp :: rest -> 
+            let tmp = func var exp in
+            match tmp with
+              | (bool, maj) ->
+                  if(bool) then (bool, maj) else or_to_list var rest func in
+
+      let rec findRead var exp = 
+        match exp with 
+          | Const'(c) -> (false, -2)
+          | Var'(VarBound(v, maj, min)) | BoxGet'(VarBound(v, maj, min)) -> if(String.equal var v) then (true, maj) else (false, -2)
+          | Var'(VarParam(v, min)) | BoxGet'(VarParam(v, min))-> if(String.equal var v) then (true, -1) else (false, -2)
+          | Var'(VarFree(v)) -> (false, -2)
+          | If'(test, dit, dif) -> 
+                let (check_test, maj_test) = findRead var test 
+                and (check_dit, maj_dit) = findRead var dit
+                and (check_dif, maj_dif) = findRead var dif in
+                  if(check_test) then (check_test, maj_test) else
+                   if(check_dit) then (check_dit, maj_dit) else
+                    if(check_dif) then (check_dif, maj_dif) else (false, -2) 
+          | Set'(v, expr) | BoxSet'(v, expr) -> findRead var expr
+          | Or'(exprs) -> or_to_list var exprs findRead
+          | Def'(v, expr) -> findRead var expr
+          | LambdaSimple'(params, body) -> 
+                if(List.mem var params) then (false, -2) else findRead var body
+          | LambdaOpt'(params, variadic, body) -> 
+                if(List.mem var params) then (false, -2) else findRead var body
+          | Seq'(exprs) -> or_to_list var exprs findRead
+          | Applic'(proc, exprs) -> 
+                let (bool, maj) = findRead var proc in
+                if(bool) then (bool, maj) 
+                          else or_to_list var exprs findRead
+          | ApplicTP'(proc, exprs) -> 
+                let (bool, maj) = findRead var proc in
+                if(bool) then (bool, maj) 
+                          else or_to_list var exprs findRead
+          | _ -> (false, -2) in
+
+      
+      let rec findWrite var exp = 
+        match exp with 
+          | Const'(c) -> (false, -2)
+          | Var'(v) | BoxGet'(v) -> (false, -2)
+          | If'(test, dit, dif) -> 
+                let (check_test, maj_test) = findWrite var test 
+                and (check_dit, maj_dit) = findWrite var dit
+                and (check_dif, maj_dif) = findWrite var dif in
+                  if(check_test) then (check_test, maj_test) else
+                   if(check_dit) then (check_dit, maj_dit) else
+                    if(check_dif) then (check_dif, maj_dif) else (false, -2) 
+          | Set'(VarBound(v, maj, min), expr) | BoxSet'(VarBound(v, maj, min), expr) -> if(String.equal var v) then (true, maj) else findWrite var expr
+          | Set'(VarParam(v, min), expr) | BoxSet'(VarParam(v, min), expr) -> if(String.equal var v) then (true, -1) else findWrite var expr
+          | Set'(VarFree(v), expr) -> findWrite var expr
+          | Or'(exprs) -> or_to_list var exprs findWrite
+          | Def'(v, expr) -> findWrite var expr
+          | LambdaSimple'(params, body) -> 
+                if(List.mem var params) then (false, -2) else findWrite var body
+          | LambdaOpt'(params, variadic, body) -> 
+                if(List.mem var params) then (false, -2) else findWrite var body
+          | Seq'(exprs) -> or_to_list var exprs findWrite
+          | Applic'(proc, exprs) -> 
+              let (bool, maj) = findWrite var proc in
+              if(bool) then (bool, maj) 
+                        else or_to_list var exprs findWrite
+          | ApplicTP'(proc, exprs) -> 
+              let (bool, maj) = findWrite var proc in
+              if(bool) then (bool, maj) 
+                        else or_to_list var exprs findWrite
+          | _ -> (false, -2) in    
+
+      let rec findRWLst var exprs =
+          match exprs with
+            (* | [] -> [((false, -2), (false, -2))]   *)
+            | [] -> []
+            (* | Var'(VarBound(v, maj, min)) :: rest | BoxGet'(VarBound(v, maj, min)) :: rest -> List.append (if(String.equal var v) then (true, -3) else (false, -2)) (findRWLst var rest) *)
+            | Var'(VarParam(v, min)) :: rest | BoxGet'(VarParam(v, min)) :: rest -> 
+                      List.append (if(String.equal var v) then [(true, -3), (false, -2)] else [(false, -2), (false, -2)]) (findRWLst var rest)
+            | Set'(VarBound(v, maj, min), exp) :: rest | BoxSet'(VarBound(v, maj, min), exp) :: rest -> 
+                      List.append (if(String.equal var v) then [findRead var exp, (true, -3)] else [findRead var exp, (false, -2)]) (findRWLst var rest)
+            | Set'(VarParam(v, min), exp) :: rest | BoxSet'(VarParam(v, min), exp) :: rest ->
+                      List.append (if(String.equal var v) then [findRead var exp, (true, -3)] else [findRead var exp, (false, -2)]) (findRWLst var rest)
+            | exp :: rest -> List.append [(findRead var exp, findWrite var exp)] (findRWLst var rest) in
+
+      let rec check_seq_combinations lst i j = 
+        if(i < (List.length lst))
+          then if (j < (List.length lst))
+                  then let ((read_i, majRi), (write_i, majWi)) = List.nth lst i 
+                        and ((read_j, majRj), (write_j, majWj)) = List.nth lst j in
+                          if((i < j) && 
+                              ((read_i && write_j && majRi == -3 && majWj >= -1) || (write_i && read_j && majWi == -3 && majRj >= -1)))
+                              then false
+                              else
+                                  if ((i!=j) && 
+                                        (((read_i && write_j) && ((majRi >= -1 && majWj >= 0) || (majRi >= 0 && majWj >= -1))) ||
+                                          ((read_j && write_i) && ( (majRj >= -1 && majWi >= 0) || (majRj >= 0 && majWi >= -1)))))
+                            then true
+                            else check_seq_combinations lst (i) (j+1) || check_seq_combinations lst (i+1) (j) 
+                  else false
+          else false in
+
+      let rec check_applic_combinations lst i j = 
+        if(i < (List.length lst))
+          then if (j < (List.length lst))
+                  then let ((read_i, majRi), (write_i, majWi)) = List.nth lst i 
+                        and ((read_j, majRj), (write_j, majWj)) = List.nth lst j in
+                                  if ((i!=j) && 
+                                        (((read_i && write_j) && (((majRi >= -1 || majRi == -3) && majWj >= 0) || (majRi >= 0 && (majWj >= -1 || majWj == -3)))) ||
+                                          ((read_j && write_i) && ( ((majRj >= -1 || majRj == -3) && majWi >= 0) || (majRj >= 0 && (majWi >= -1 || majWi == -3))))))
+                                    then true
+                                    else check_applic_combinations lst (i) (j+1) || check_applic_combinations lst (i+1) (j) 
+                  else false
+          else false in
+
+      let rec need_box_seq_applic var exprs seq applic = 
+        (* [(R, W), (R, W)...] *)
+        let readWriteList = findRWLst var exprs in 
+        if(seq)
+          then (check_seq_combinations readWriteList 0 0) 
+          else if (applic)
+            then (check_applic_combinations readWriteList 0 0) 
+              else false in
+
+
+      let check_set_box_read var setBody = 
+          let (hasReadOccur, maj) = findRead var setBody in
+          if(hasReadOccur && (maj >= 0)) then true else false in
+
+      let check_set_box setVar setBody var = 
+          match setVar with 
+            | VarParam(v_str, min) -> 
+                                      if(String.equal var v_str)
+                                      then check_set_box_read var setBody
+                                      else need_boxing var setBody 
+            | VarBound(v_str, maj, min) ->
+                                      if(String.equal var v_str)
+                                      then check_set_box_read var setBody
+                                      else need_boxing var setBody
+            | VarFree(v_str) -> need_boxing var setBody in
+
+      let rec check_other_boxes var exprs = 
+          match exprs with
+            | Set'(x1, Box' (x2)) :: rest -> check_other_boxes var rest
+            | Seq'(new_exprs) :: [] ->  need_box_seq_applic var new_exprs true false
+            | Applic'(proc, new_exprs) :: [] -> need_box_seq_applic var new_exprs false true
+            | ApplicTP'(proc, new_exprs) :: [] -> need_box_seq_applic var new_exprs false true
+            | _ -> false in 
+
+      (*  Need Boxing body: *)
+      match body with
+      | Const'(c) -> false
+      | Var'(v) -> false
+      | BoxGet'(v) -> false
+      | If'(test, dit, dif) -> need_box_seq_applic var [test; dif] false true || 
+                                need_box_seq_applic var [test; dit] false true || 
+                                (need_boxing var test || need_boxing var dit || need_boxing var dif)
+      | Set'(v, expr) -> check_set_box v expr var 
+      | BoxSet'(v, expr) -> check_set_box v expr var
+      | Or'(exprs) -> (need_box_seq_applic var exprs true false) || (need_boxing_or var exprs)
+      | Def'(v, expr) -> need_boxing var expr
+      | LambdaSimple'(params, body) -> 
+            if(List.mem var params) then false else need_boxing var body
+      | LambdaOpt'(params, variadic, body) -> 
+            if(List.mem var params) then false else need_boxing var body
+      | Seq'(exprs) ->  need_box_seq_applic var exprs true false || check_other_boxes var exprs
+      | Applic'(proc, exprs) -> need_box_seq_applic var exprs false true
+      | ApplicTP'(proc, exprs) -> need_box_seq_applic var exprs false true
+      | _ -> false in
+  
+  let checkNestedSeq exp = 
+        match exp with 
+        | Seq'(x) -> x
+        | _ -> [exp] in
+
+  let rec insert_box_set box_exp boxed_body new_body =
+    match boxed_body with 
+      | Set'(VarParam(var1, minor1), Box'(VarParam(var2,minor2))) :: rest -> insert_box_set box_exp rest (List.append new_body [(Set'(VarParam(var1, minor1), Box'(VarParam(var2,minor2))))])
+      | rest -> (List.append (List.append new_body [box_exp]) rest) in
+
+  (* check if var need boxing *)
+  let box_var_if_need_boxing body var minor = 
+    let needBox = need_boxing var body in
+    if(needBox)  
+      then 
+          let boxed_body = do_boxing_to var minor (-1) body in
+          let box_exp = Set'(VarParam(var, minor), Box'(VarParam(var,minor))) in
+          let finished_body = Seq'(insert_box_set box_exp (checkNestedSeq boxed_body) []) in
+          (finished_body)
+      else 
+          body in
+
+
+  (* box_body_check : send each arg to check if he need boxing *)
+  let rec box_body_check vars minor body = 
+    match vars with
+      | [] -> body
+      | curr_var :: restVars -> 
+            let body_after_boxing = (box_var_if_need_boxing body curr_var minor) in
+            (box_body_check restVars (minor + 1) body_after_boxing) in
+
+  (* box set : if its lambda try boxing *)
+    match exp with 
+        | Const'(c) -> Const'(c)
+        | Var'(v) -> Var'(v)
+        | If'(test, dit, dif) -> If'(box_helper test, box_helper dit, box_helper dif)
+        | Seq'(exprs) -> Seq'(List.map box_helper exprs)
+        | Set'(var, expr) -> Set'(var, box_helper expr)
+        | Or'(exprs) -> Or'(List.map box_helper exprs)
+        | Def'(var, expr) -> Def'(var, box_helper expr)
+        | Applic'(proc, exprs) -> Applic'(box_helper proc, List.map box_helper exprs)
+        | ApplicTP'(proc, exprs) -> ApplicTP'(box_helper proc, List.map box_helper exprs)  
+        | LambdaSimple'(params, body) ->
+              LambdaSimple'(params, box_body_check params 0 (box_helper body))
+        | LambdaOpt'(params, variadic, body) -> 
+              LambdaOpt'(params, variadic, box_body_check (List.append params [variadic]) 0 (box_helper body))
+        | _ -> raise X_syntax_error;;
+
+let box_set e = 
+    box_helper e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
+
+
   
 end;; (* struct Semantics *)
 
+let test strExp = 
+  let sexpr = Reader.read_sexprs strExp in
+  let expr = Tag_Parser.tag_parse_expressions sexpr in 
+  Semantics.run_semantics (List.hd expr);;
+
+let rec findLocInParams var params loc = 
+  if (List.length params == 0)
+  then -1
+  else (
+    if (compare (List.hd params) var == 0)
+    then loc
+    else findLocInParams var (List.tl params) (loc+1));;
 
+let rec findMajMin var env maj = 
+    let hd = List.hd env 
+    and tl = List.tl env in
+    let min = findLocInParams var hd 0 in
+    if (min == -1)
+      then findMajMin var tl (maj+1)
+      else VarBound (var, maj, min);;
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..211e021 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -40,8 +40,8 @@ let rec expr_eq e1 e2 =
      (expr_eq e1 e2) &&
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
-                       
+
+
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -58,8 +58,325 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+
+let rec tag_parse sexpr = 
+
+    let rec parse_nested_pairs p = 
+      match p with
+      | Pair(left, Nil) -> [tag_parse left]
+      | Pair(left, right) -> List.append [tag_parse left] (parse_nested_pairs right)
+      | _ -> raise X_syntax_error in
+    
+    let checkNestedSeq exp = 
+        match exp with 
+        | Seq(x) -> x
+        | _ -> [exp] in
+    
+    let rec parse_nested_flatten p = 
+      match p with
+      | Pair(left, Nil) -> (checkNestedSeq (tag_parse left))
+      | Pair(left, right) -> List.append (checkNestedSeq (tag_parse left)) (parse_nested_flatten right)
+      | _ -> raise X_syntax_error in
+    
+    let parse_var x = 
+      if (List.mem x reserved_word_list)
+      then raise X_syntax_error
+      else Var(x) in
+    
+    let parse_var_string x = 
+      if (List.mem x reserved_word_list)
+      then raise X_syntax_error
+      else ""^x in 
+
+    let rec parse_args p = 
+      match p with
+      | Nil -> []
+      | Pair(Symbol(x), Nil) -> [parse_var_string x]
+      | Pair(Symbol(x), right) -> List.append [parse_var_string x] (parse_args right) 
+      | _ -> raise X_syntax_error in
+    
+    let rec get_varid p = 
+      match p with
+      | Pair(Symbol(x), Symbol(y)) -> parse_var_string y
+      | Pair(Symbol(x), right) -> get_varid right
+      | _ -> raise X_syntax_error in
+    
+    let rec parse_args_varid p = 
+      match p with
+      | Pair(Symbol(x), Symbol(y)) -> [parse_var_string x]
+      | Pair(Symbol(x), right) -> List.append [parse_var_string x] (parse_args_varid right)
+      | _ -> raise X_syntax_error in
+
+    let rec nestedNil p =
+      match p with
+      | Nil -> true
+      | Pair(x, Nil) -> true
+      | Pair(x, Symbol(y)) -> false
+      | Pair(x, y) -> nestedNil y 
+      | _ -> raise X_syntax_error in
+    
+
+    let checkBodySize body = 
+      match body with 
+        | Pair(exp, Nil) -> (tag_parse exp)
+        | _ -> Seq(parse_nested_pairs body) in
+
+    let parseLambdas args body = 
+      if (nestedNil args)
+        then LambdaSimple((parse_args args), (checkBodySize body))
+        else LambdaOpt((parse_args_varid args), (get_varid args), (checkBodySize body)) in
+
+    let get_var rib = 
+      match rib with 
+        | Pair(Symbol x, arg) -> Symbol x
+        | _ -> raise X_syntax_error in
+
+    let rec getVars ribs =
+      match ribs with 
+        | Nil ->  Nil 
+        | Pair (rib, Nil) -> Pair(get_var rib, Nil)
+        | Pair(rib, rest_ribs) -> Pair(get_var rib, getVars rest_ribs) 
+        | _ -> raise X_syntax_error in
+
+    let get_arg rib = 
+      match rib with 
+        | Pair(Symbol x, Pair(arg, Nil)) -> arg
+        | _ -> raise X_syntax_error in
+
+    let rec getArgs ribs =
+      match ribs with 
+        | Nil -> Nil
+        | Pair (rib, Nil) -> Pair(get_arg rib, Nil)
+        | Pair(rib, rest_ribs) -> Pair(get_arg rib, getArgs rest_ribs) 
+        | _ -> raise X_syntax_error in
+
+    let expandLet ribs body = 
+      let vars = getVars ribs 
+      and args = getArgs ribs in
+      (tag_parse (Pair(Pair(Symbol "lambda", Pair(vars, body)), args))) in 
+
+  
+    let expandLetStarOneVar var arg body = 
+      (tag_parse (Pair(Symbol "let", Pair(Pair(Pair(var, Pair(arg, Nil)), Nil), Pair(body, Nil))))) in
+      (* (tag_parse (Pair(Symbol "let", Pair(Pair(Pair(var, Pair(arg, Nil)), Nil),  *)
+                          (* Pair(Pair(Symbol "let*", Pair(ribs, Pair(body, Nil))), Nil))))) in *)
+
+    let expandLetStar rib ribs body = 
+      let var = get_var rib 
+      and arg = get_arg rib in
+      (tag_parse (Pair(Symbol "let", Pair(Pair(Pair(var, Pair(arg, Nil)), Nil), 
+                          Pair(Pair(Symbol "let*", Pair(ribs, Pair(body, Nil))), Nil))))) in
+
+    let rec getVarsRec ribs =
+      match ribs with 
+        | Nil ->  Nil 
+        | Pair (rib, Nil) -> Pair(Pair(get_var rib, Pair(Pair(Symbol "quote", Pair(Symbol "whatever", Nil)), Nil)), Nil)
+        | Pair(rib, rest_ribs) -> Pair(Pair(get_var rib, Pair(Pair(Symbol "quote", Pair(Symbol "whatever", Nil)), Nil)), getVarsRec rest_ribs) 
+        | _ -> raise X_syntax_error in
+
+    let rec getArgsRec ribs body =
+      match ribs with 
+        | Nil -> Nil
+        | Pair (rib, Nil) -> Pair(Pair(Symbol "set!", Pair(get_var rib, Pair(get_arg rib, Nil))), Pair(Pair(Symbol "let", Pair(Nil, body)), Nil))
+        | Pair(rib, rest_ribs) -> Pair(Pair(Symbol "set!", Pair(get_var rib, Pair(get_arg rib, Nil))), (getArgsRec rest_ribs body)) 
+        | _ -> raise X_syntax_error  in
+
+    let expandLetRec ribs body = 
+      let ribs_new = getVarsRec ribs 
+      and body_new = getArgsRec ribs body in
+      (tag_parse (Pair(Symbol "let", Pair(ribs_new, body_new)))) in
+
+    let expandCondType1 test exps ribs = 
+        (tag_parse (Pair(Symbol "if", Pair(test, Pair(Pair(Symbol "begin", exps), Pair(Pair(Symbol "cond", ribs), Nil)))))) in
+    
+    let expandCondType1Nil test exps= 
+        (tag_parse (Pair(Symbol "if", Pair(test, Pair(Pair(Symbol "begin", exps), Nil))))) in
+
+    let expandCondType2 test_exp exp_f ribs = 
+        (tag_parse (Pair(Symbol "let", 
+                            Pair(Pair(Pair(Symbol "value", Pair(test_exp, Nil)), 
+                            Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, exp_f)), Nil)), 
+                            Pair(Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(Pair(Symbol "cond", ribs), Nil))), Nil)), Nil))), 
+                            Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Pair(Pair(Symbol "rest", Nil), Nil)))), Nil))))) in
+    
+
+    let expandCondType3 exps ribs = 
+      (tag_parse (Pair(Symbol "begin", exps))) in
+
+    let expandCond rib1 ribs =   
+      match rib1 with 
+        | Pair(test_exp, Pair(Symbol "=>", exp_f)) -> (expandCondType2 test_exp exp_f ribs)
+        | Pair(Symbol "else", exps) -> (expandCondType3 exps ribs)
+        | Pair(test, exps) -> (expandCondType1 test exps ribs)
+        | _ -> raise X_syntax_error in
+   
+    let expandCondType2Nil test_exp exp_f = 
+        
+     (tag_parse (  Pair(Symbol "let", 
+       Pair(Pair(Pair(Symbol "value", Pair(test_exp, Nil)), 
+       Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, exp_f)), Nil)), Nil)), 
+       Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Nil))), Nil))))) in
+
+    let expandCondNil rib1 =   
+      match rib1 with 
+        | Pair(test_exp, Pair(Symbol "=>", exp_f)) -> (expandCondType2Nil test_exp exp_f)
+        | Pair(Symbol "else", exps) -> (expandCondType3 exps Nil)
+        | Pair(test, exps) -> (expandCondType1Nil test exps)
+        | _ -> raise X_syntax_error in
+
+    let expandMITDef var arglist body = 
+        let lam = Pair(Symbol "lambda", Pair (arglist, body)) in
+        (tag_parse (Pair(Symbol "define", Pair (var, Pair (lam, Nil))))) in
+
+    let rec createRibs vals i = 
+        let tmp_i = (string_of_int i) in
+        match vals with 
+          | Pair(exp, Nil) -> Pair(Pair(Symbol tmp_i, Pair(exp, Nil)), Nil)
+          | Pair(exp, rest) -> Pair(Pair(Symbol tmp_i, Pair(exp, Nil)), (createRibs rest (i+1))) 
+          | _ -> raise X_syntax_error in
+
+    let rec createBody vars tmplst =
+        match vars with
+          | Pair (Symbol v_i, Nil) -> Pair(Pair(Symbol "set!", Pair(Symbol v_i, Pair((List.hd tmplst), Nil))), Nil)
+          | Pair (Symbol v_i, rest) -> Pair(Pair(Symbol "set!", Pair(Symbol v_i, Pair((List.hd tmplst), Nil))), (createBody rest (List.tl tmplst))) 
+          | _ -> raise X_syntax_error in
+
+    let rec getTmpVars newRibs = 
+        match newRibs with 
+          | Pair(Pair(Symbol i, _), Nil) -> [Symbol(i)]
+          | Pair(Pair(Symbol i, _), ribs) -> List.append [Symbol(i)] (getTmpVars ribs) 
+          | _ -> raise X_syntax_error in
+
+    let expandPset ribs = 
+        let vars = getVars ribs in
+        let vals = getArgs ribs in
+        let newRibs = (createRibs vals 1) in
+        let tmp_vars = (getTmpVars newRibs) in
+        let body = (createBody vars tmp_vars) in
+        (tag_parse (Pair(Symbol "let", Pair(newRibs, Pair(body, Nil))))) in
+
+    let rec expandQuasiquote exp = 
+        match exp with 
+          | Pair(Symbol "unquote", Pair(sexpr, Nil)) -> sexpr
+
+          | Nil -> Pair(Symbol("quote"), Nil)
+          | Symbol x -> Pair(Symbol("quote"), Pair(Symbol x, Nil))
+
+          | Pair(Pair(Symbol "unquote-splicing", Pair(sexpr, Nil)), expB) -> (Pair(Symbol "append", Pair(sexpr, Pair((expandQuasiquote expB), Nil))))
+          | Pair(expA,  Pair(Symbol "unquote-splicing", Pair(sexpr, Nil))) -> Pair(Symbol "cons", Pair((expandQuasiquote expA), Pair(sexpr, Nil)))
+
+          | Pair(expA, expB) -> Pair(Symbol "cons", Pair((expandQuasiquote expA), Pair((expandQuasiquote expB), Nil))) 
+          
+          | _ -> Symbol "error" in
+
+
+
+    let parseOr body = 
+          match body with 
+            | Nil -> Const(Sexpr(Bool(false)))
+            | Pair(x, Nil) -> tag_parse x
+            | _ -> Or(parse_nested_pairs body) in
+    (* ---------------------   *)
+
+    match sexpr with 
+      (* Const(Sexpr(Symbol "DEBUG")) *)
+      (* Quasiquote - Macro *)
+        | Pair(Symbol "quasiquote", Pair(Pair(Symbol "unquote-splicing", Pair(sexpr, Nil)), Nil)) -> raise X_syntax_error
+        | Pair(Symbol "quasiquote", Pair(exps, Nil)) -> 
+            let expanded = expandQuasiquote exps in
+            (tag_parse expanded)
+
+      (* Cond - Macro *)
+        | Pair(Symbol "cond", Pair(rib1, Nil)) -> (expandCondNil rib1)
+        | Pair(Symbol "cond", Pair(rib1, ribs)) -> (expandCond rib1 ribs)
+
+
+
+      (* Let - Macro *)
+        | Pair(Symbol "let", Pair(ribs, body)) -> (expandLet ribs body)
+
+      (* Let* - Macro *)
+        | Pair(Symbol "let*", Pair(Nil, Pair(body, Nil))) -> (tag_parse (Pair(Symbol "let", Pair(Nil, Pair(body, Nil)))))
+        | Pair(Symbol "let*", Pair(Pair(Pair(var, Pair(arg, Nil)), Nil), Pair(body, Nil))) -> (expandLetStarOneVar var arg body)
+        | Pair(Symbol "let*", Pair(Pair(rib, ribs), Pair(body, Nil))) -> (expandLetStar rib ribs body)
+
+      (* Letrec - Macro *)
+        | Pair(Symbol "letrec", Pair(ribs, body)) -> (expandLetRec ribs body)
+
+      (* And - Macro *)
+        | Pair(Symbol("and"), Pair(exp1, Nil)) -> (tag_parse exp1)
+        | Pair(Symbol("and"), Pair(exp1, restExps)) -> (tag_parse (Pair(Symbol("if"), Pair(exp1, Pair((Pair(Symbol("and"), restExps)), Pair(Bool(false), Nil))))))
+          
+      (* MIT-style define - Macro *)
+          | Pair(Symbol "define", Pair(Pair(var, arglist), body)) -> (expandMITDef var arglist body)
+      (* pset! - Macro *)
+          | Pair(Symbol "pset!", ribs) -> (expandPset ribs)
+
+
+
+      (* -----Core Forms -------   *)
+      (* Const *)
+        | Number(x) -> Const(Sexpr(Number(x)))
+        | Bool(x) -> Const(Sexpr(Bool(x)))
+        | Char(x) -> Const(Sexpr(Char(x)))
+        | String(x) -> Const(Sexpr(String(x)))
+        | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+        | Pair(Symbol("quote"), Nil) -> Const(Sexpr(Nil))
+
+
+      (* Variable *)
+        | Symbol(x) -> parse_var x
+
+      (* If *)
+        | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil))))-> If(tag_parse test, tag_parse dit, tag_parse dif)
+        | Pair(Symbol("if"), Pair(test, Pair(dit, Nil)))-> If(tag_parse test, tag_parse dit, Const(Void))
+
+      (* Lambadas *)
+        | Pair (Symbol "lambda", Pair (Symbol(var), body)) -> LambdaOpt([], (parse_var_string var), (checkBodySize body))
+        | Pair (Symbol "lambda", Pair (args, body)) -> (parseLambdas args body)
+
+      (* Disjunction *)
+        | Pair (Symbol "or", body) -> parseOr(body)
+
+      (* Define *)
+        | Pair (Symbol "define", Pair (Symbol x, Pair (body, Nil))) -> Def(parse_var x, tag_parse body)
+
+      (* Set! *)
+        | Pair (Symbol "set!", Pair (x, Pair (body, Nil))) -> Set(tag_parse x, tag_parse body)
+
+      (* Sequences *)
+        | Pair (Symbol "begin", Nil) -> Const(Void)
+        | Pair (Symbol "begin", Pair (element, Nil)) -> (tag_parse element)
+        | Pair (Symbol "begin", body) -> Seq(parse_nested_flatten body)
+
+      (* Applications *)
+        | Pair(rator, Nil) -> Applic(tag_parse rator, [])
+        | Pair(rator, rands) -> Applic(tag_parse rator, parse_nested_pairs rands)
+        | _ -> raise X_syntax_error;;
+
+
+let rec tag_parse_expressions sexpr = 
+    match sexpr with
+      | [] -> []
+      | car :: cdr -> List.append [tag_parse car] (tag_parse_expressions cdr);;
 
   
 end;; (* struct Tag_Parser *)
 
+(* (pset! (v1 Expr1) (v2 Expr2) (vn Exprn))
+
+-->
+
+(let ((tmp1 Expr1)
+      (tmp2 Expr2)
+      (tmpn Exprn))
+        (set! v1 tmp1)
+        (set! v2 tmp2)
+        (set! vn tmpn))
+
+-->
+
+((lambda (tmp1 tmp2 tmpn) 
+        (set v1 tmp1)
+        (set v2 tmp2)
+        (set vn tmp n)) Expr1 Expr2 Exprn) *)
