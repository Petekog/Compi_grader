diff --git a/reader.ml b/reader.ml
index 32445c2..683bd4f 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,6 @@
 
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -41,6 +42,255 @@ let normalize_scheme_symbol str =
   else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+(* Helper Functions *)
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+let nt_whitespaces = star nt_whitespace;;
+
+let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
+
+let nt_end_of_comment = 
+  let nt_end_of_line = pack (char_ci '\n') (fun x -> [x]) in
+  let nt = disj nt_end_of_line nt_end_of_input in
+  nt;;
+
+let nt_line_comment =
+  let nt = char ';' in
+  let nt_all = const (fun ch -> ch != '\n') in
+  let nt_all = star nt_all in
+  let nt = caten nt nt_all in
+  let nt = caten nt nt_end_of_comment in
+  let nt = make_spaced nt in
+  let nt = pack nt (fun _ -> []) in
+  nt;;
+
+let nt_line_comments = star nt_line_comment;;
+
+let rec gcd a b = if b = 0 then a else gcd b (a mod b);;
+
+let eval_natural lst = List.fold_left (fun a b -> 10 * a + b) 0 lst;;
+
+let eval_mantissa lst = List.fold_right (fun a b -> (a +. b) /. 10.) lst 0.;;
+
+(* Tokens PC *)
+let tok_true = make_spaced (word_ci "#t");;
+let tok_false = make_spaced (word_ci "#f");;
+let tok_dot = char '.';;
+let tok_digit = range '0' '9';;
+let digit_seq = plus tok_digit;;
+let tok_letter = disj (range 'a' 'z') (pack (range 'A' 'Z') (fun ch -> lowercase_ascii ch));;
+let tok_lparen = make_spaced (char '(');;
+let tok_rparen = make_spaced (char ')');;
+let tok_quote = make_spaced (char '\'');;
+let tok__quasi_quote = make_spaced (char '`');;
+let tok_unquote = make_spaced (char ',');;
+let tok_unquote_and_splice = caten (make_spaced (char ',')) (make_spaced (char '@'));;
+
+(* Symbol PC *)
+let nt_symbol =
+  let symbol_char_no_dot =
+    disj_list [tok_digit; tok_letter; char '!'; 
+    char '^'; char '*'; char '-'; char '_'; char '='; char '<';
+    char '>'; char '?'; char '/'; char '+'; char '$'; char ':'] in
+  let symbol_char = disj symbol_char_no_dot tok_dot in
+  let nt = caten symbol_char (plus symbol_char) in
+  let nt = pack nt (fun (e, s) -> e :: s) in
+  let nt = disj nt (pack symbol_char_no_dot (fun x -> [x])) in
+  let nt = pack nt (fun x -> Symbol (list_to_string x)) in
+  nt;;
+
+(* Boolean PC *)
+let nt_boolean =
+  let nt_t = pack tok_true (fun _ -> Bool true) in
+  let nt_f = pack tok_false (fun _ -> Bool false) in
+  let nt = disj nt_t nt_f in
+  nt;;
+
+(* Char PC *)
+let nt_char =
+  let visible_simple_char = const (fun ch -> ' ' < ch) in
+  let named_char =
+    let newline = pack (word_ci "newline") (fun _ -> char_of_int 10) in
+    let nul = pack (word_ci "nul") (fun _ -> char_of_int 0) in 
+    let page = pack (word_ci "page") (fun _ -> char_of_int 12) in
+    let return = pack (word_ci "return") (fun _ -> char_of_int 13) in
+    let space = pack (word_ci "space") (fun _ -> char_of_int 32) in
+    let tab = pack (word_ci "tab") (fun _ -> char_of_int 9) in
+    disj_list [newline; nul; page; return; space; tab] in
+  let char_prefix = word "#\\" in
+  let nt = disj (caten char_prefix named_char) (caten char_prefix visible_simple_char) in
+  let nt = pack nt (fun (prefix, ch) -> Char ch) in
+  nt;;
+
+(* String PC *)
+let nt_string =
+  let nt_string_literal_char = const (fun ch -> ch != '\\' && ch != '"') in
+  let nt_r = pack (word_ci "\\r") (fun _ -> char_of_int 13) in
+  let nt_n = pack (word_ci "\\n") (fun _ -> char_of_int 10) in
+  let nt_t = pack (word_ci "\\t") (fun _ -> char_of_int 9) in
+  let nt_f = pack (word_ci "\\f") (fun _ -> char_of_int 12) in
+  let nt_bs = pack (word_ci "\\\\") (fun _ -> char_of_int 92) in
+  let nt_dq = pack (word_ci "\\\"") (fun _ -> char_of_int 34) in
+  let nt_string_meta_char = disj_list [nt_r; nt_n; nt_t; nt_f; nt_bs; nt_dq;] in
+  let nt_string_char = disj nt_string_literal_char nt_string_meta_char in
+  let nt = caten (char '"') (star nt_string_char) in
+  let nt = pack nt (fun (_, l) -> l) in
+  let nt = caten nt (char '"') in
+  let nt = pack nt (fun (l, _) -> String (list_to_string l)) in
+  nt;;
+
+(* Number PC *)
+let sign = pack (maybe (disj (char '+') (char '-'))) 
+                (fun sign -> match sign with
+                              | Some('-') -> -1
+                              | _ -> 1);;
+
+let nt_natural = pack (digit_seq) (fun nat -> eval_natural (List.map (fun ch -> (int_of_char ch) - 48) nat));;
+
+let nt_mantissa = pack (digit_seq) (fun man -> eval_mantissa (List.map (fun ch -> float_of_int ((int_of_char ch) - 48)) man));;
+
+let nt_integer = pack (caten sign nt_natural) (fun (sign, nat) -> Fraction(sign * nat, 1));;
+
+
+let nt_fraction =
+  let tok_slash = make_spaced (char '/') in
+  let nt = caten nt_integer tok_slash in
+  let nt = pack nt (fun (i, slash) -> i) in
+  let nt = caten nt nt_natural in
+  pack nt (fun (i, nat) ->
+            match i with
+            | Fraction(x, 1) ->
+                let y = if x < 0 then x * -1 else x in
+                let g = gcd y nat in
+                Fraction(x / g, nat / g)
+            | _ -> raise X_no_match);;
+
+let nt_float =
+  let nt = caten nt_integer tok_dot in
+  let nt = pack nt (fun (i, dot) -> i) in
+  let nt = caten nt nt_mantissa in
+  pack nt (fun (i, man) -> 
+            match i with
+            | Fraction(x, 1) ->
+                let l = float_of_int x in
+                let f = if x <= 0 then l -. man else l +. man in
+                Float f
+            | _ -> raise X_no_match);;
+
+let nt_scientific = 
+  let nt_e = char_ci 'e' in
+  let nt_num = disj nt_float nt_integer in
+  let nt = caten nt_num nt_e in
+  let nt = pack nt (fun (n, e) -> n) in
+  let nt = caten nt nt_integer in
+  pack nt (fun (n, i) -> 
+            match i with
+            | Fraction(y, 1) -> 
+                let x = match n with
+                        | Fraction(x, 1) -> float_of_int x
+                        | Float(x) -> x
+                        | _ -> raise X_no_match in
+                let y = float_of_int y in
+                let f = x *. (10. ** y) in
+                Float f
+            | _ -> raise X_no_match)
+
+let nt_number =
+  let nt = disj_list [nt_scientific; nt_fraction; nt_float; nt_integer] in
+  let nt = not_followed_by nt (disj nt_symbol (pack tok_dot (fun _ -> Nil))) in
+  pack nt (fun x -> Number x);;
+
+
+let rec nt_sexpr s =
+  let nt = disj_list [nt_unquoted_spliced; nt_unquoted; nt_qquoted; nt_quoted; 
+                      nt_dotted_list; nt_list; nt_number; nt_boolean; nt_string; 
+                      nt_symbol; nt_char] in
+  let nt = make_clean nt in
+  nt s
+
+  and nt_list s =
+    let tok_lparen = make_paired (star nt_skip) (star nt_skip) tok_lparen in
+    let nt = star nt_sexpr in
+    let nt = make_paired tok_lparen tok_rparen nt in
+    let nt = pack nt
+    (fun l -> 
+      match l with
+      | [] -> Nil
+      | l -> List.fold_right (fun a b -> Pair(a, b)) l Nil) in
+    nt s
+
+  and nt_dotted_list s =
+    let tok_dot = make_spaced tok_dot in
+    let nt = caten (plus nt_sexpr) tok_dot in
+    let nt = pack nt (fun (e, _) -> e) in
+    let nt = caten nt nt_sexpr in
+    let nt = pack nt (fun (e,s ) -> e @ [s]) in
+    let nt = make_paired tok_lparen tok_rparen nt in
+    let nt = pack nt 
+    (fun l -> 
+      let i = List.nth l ((List.length l) - 1) in
+      let l = List.rev (List.tl (List.rev l)) in
+      List.fold_right (fun a b -> Pair(a, b)) l i) in
+    nt s
+
+  and nt_quoted s = 
+    let tok_quote = char (char_of_int 39) in
+    let nt = caten tok_quote nt_sexpr in
+    let nt = pack nt (fun (_, sexpr) -> Pair(Symbol "quote", Pair(sexpr, Nil))) in
+    nt s
+
+  and nt_qquoted s = 
+    let tok_qquote = char '`' in
+    let nt = caten tok_qquote nt_sexpr in
+    let nt = pack nt (fun (_, sexpr) -> Pair(Symbol "quasiquote", Pair(sexpr, Nil))) in
+    nt s
+
+  and nt_unquoted s = 
+    let tok_unquote = char ',' in
+    let nt = caten tok_unquote nt_sexpr in
+    let nt = pack nt (fun (_, sexpr) -> Pair(Symbol "unquote", Pair(sexpr, Nil))) in
+    nt s
+
+  and nt_unquoted_spliced s = 
+    let tok_unquote_splice = word ",@" in
+    let nt = caten tok_unquote_splice nt_sexpr in
+    let nt = pack nt (fun (_, sexpr) -> Pair(Symbol "unquote-splicing", Pair(sexpr, Nil))) in
+    nt s
+
+  and nt_sexpr_comment s =
+      let nt = make_spaced (word "#;") in
+      let nt = caten nt (star nt_sexpr_comment) in
+      let nt = caten nt nt_sexpr in
+      let nt = pack nt (fun _ -> []) in
+      let nt = make_spaced nt in
+      let nt = make_paired nt_line_comments nt_line_comments nt in
+      nt s
+  
+  and nt_comment s =
+    let nt = disj nt_sexpr_comment nt_line_comment in
+    nt s
+  
+  and nt_space s =
+    let nt = const (fun ch -> ch <= ' ') in
+    let nt = pack nt (fun ch -> [ch]) in
+    nt s
+  
+  and nt_skip s =
+    let nt = disj nt_space nt_comment in
+    nt s
+    
+  and make_clean nt s = 
+    let nt = make_paired (star nt_skip) (star nt_skip) nt in
+    nt s;;
+
+let read_sexprs string =
+  let nt = star nt_sexpr in
+  let (sexprs, _) = nt (string_to_list string) in
+  sexprs;;
   
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..20f2f18 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,2 @@
+Dan Atzmi - 312474125
+I (We) assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..3e50a13 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,4 +1,5 @@
 #use "tag-parser.ml";;
+open Tag_Parser;;
 
 type var = 
   | VarFree of string
@@ -21,6 +22,8 @@ type expr' =
   | Applic' of expr' * (expr' list)
   | ApplicTP' of expr' * (expr' list);;
 
+type pair = Pair of int * int list * int * int list * bool;;
+
 let rec expr'_eq e1 e2 =
   match e1, e2 with
   | Const' Void, Const' Void -> true
@@ -28,15 +31,6 @@ let rec expr'_eq e1 e2 =
   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
                                             (expr'_eq th1 th2) &&
                                               (expr'_eq el1 el2)
@@ -56,8 +50,9 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+  | _ -> false;;
+	
+                       
 exception X_syntax_error;;
 
 module type SEMANTICS = sig
@@ -69,17 +64,249 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let rec is_param v params i =
+  match params with
+  | [] -> -1
+  | hd :: tl -> if hd = v then i else is_param v tl (i + 1);;
+
+let rec search_var v env i =
+  match env with
+  | [] -> []
+  | hd :: tl -> let x = is_param v hd 0 in
+                  (match x with
+                  | -1 -> search_var v tl (i + 1)
+                  | x -> [i, x]);;
+
+let annotate_var v env =
+  let x = search_var v env 0 in
+    match x with
+    | [] -> VarFree v
+    | [major, minor] -> (match major with
+                        | 0 -> VarParam(v, minor)
+                        | _ -> VarBound(v, major - 1, minor))
+    | _ -> raise X_syntax_error;;
+
+let rec annotate_lexical_addresses' e env =
+  match e with
+  | Const Void -> Const' Void
+  | Const(Sexpr s) -> Const'(Sexpr s)
+  | Var(v) -> Var'(annotate_var v env)
+  | If(te, th, el) -> If'(annotate_lexical_addresses' te env, annotate_lexical_addresses' th env, annotate_lexical_addresses' el env)
+  | Seq(l) -> Seq'(List.map (fun x -> annotate_lexical_addresses' x env) l)
+  | Or(l) -> Or'(List.map (fun x -> annotate_lexical_addresses' x env) l)
+  | Set(Var v, value) -> Set'(annotate_var v env, annotate_lexical_addresses' value env)
+  | Def(Var v, value) -> Def'(annotate_var v env, annotate_lexical_addresses' value env)
+  | LambdaSimple(vars, body) -> let env = vars :: env in
+                                  LambdaSimple'(vars, annotate_lexical_addresses' body env)
+  | LambdaOpt(vars, var, body) -> let env = (vars @ [var]) :: env in
+                                    LambdaOpt'(vars, var, annotate_lexical_addresses' body env)
+  | Applic(e, args) -> Applic'(annotate_lexical_addresses' e env, List.map (fun x -> annotate_lexical_addresses' x env) args)
+  | _ -> raise X_syntax_error;;
+
+
+let rec annotate_tail_calls' e in_tp =
+  match e with
+  | (Var' _ | Const' _) -> e
+  | Applic'(proc, args) -> (match in_tp with 
+                          | true -> ApplicTP'(annotate_tail_calls' proc false, List.map (fun x -> annotate_tail_calls' x false) args)
+                          | _ -> Applic'(annotate_tail_calls' proc false, List.map (fun x -> annotate_tail_calls' x false) args))
+  | Or'(l) -> Or'(handle_seq l in_tp)
+  | Seq'(l) -> Seq'(handle_seq l in_tp)
+  | If'(te, th, el) -> If'(annotate_tail_calls' te false, annotate_tail_calls' th in_tp, annotate_tail_calls' el in_tp)
+  | Set'(var, value) -> Set'(var, annotate_tail_calls' value false)
+  | Def'(var, value) -> Def'(var, annotate_tail_calls' value false)
+  | LambdaSimple'(vars, body) -> LambdaSimple'(vars, annotate_tail_calls' body true)
+  | LambdaOpt'(vars, var, body) -> LambdaOpt'(vars, var, annotate_tail_calls' body true)
+  | _ -> e
+
+and handle_seq l in_tp =
+  let last = List.hd (List.rev l) in
+  let last = annotate_tail_calls' last in_tp in 
+  let l = List.rev (List.tl (List.rev l)) in
+  let l = List.map (fun x -> annotate_tail_calls' x false) l in
+  let l = l @ [last] in
+  l;;
+
+let counter = ref 0;;
+
+let next_val = 
+  fun () ->
+    counter := (!counter) + 1;
+    !counter;;
+
+let merge_two e1 e2 =
+  match e1 with
+  | [r1; w1] -> (match e2 with
+                | [r2; w2] -> [r1 @ r2; w1 @ w2]
+                | _ -> e1)
+  | _ -> []
+
+let rec merge_list lst =
+  match lst with
+  | [] -> []
+  | hd1 :: tl1 -> (match tl1 with
+                  | [] -> hd1
+                  | hd2 :: tl2 -> merge_list ([(merge_two hd1 hd2)] @ tl2))
+
+
+let rec get_read_write e var major minor i fathers is_seq seq_pos seq_fathers son_seq =
+  match e with
+  | Const' _ -> [[]; []]
+  | Var'(VarParam(v, x)) -> if v = var && x = minor && major = (-1)  
+                            then let (sp, sf) =
+                                if is_seq
+                                then (seq_pos, seq_fathers)
+                                else ((-1), []) in
+                                [[Pair(i, fathers, sp, sf, son_seq)]; []] 
+                            else [[]; []]
+  | Var'(VarBound(v, x, y)) -> if v = var && x = major && y = minor  
+                              then let (sp, sf) =
+                                if is_seq
+                                then (seq_pos, seq_fathers)
+                                else ((-1), []) in
+                                [[Pair(i, fathers, sp, sf, son_seq)]; []] 
+                              else [[]; []]
+  | (Applic'(proc, args) | ApplicTP'(proc, args)) -> merge_list
+                                                    ([(get_read_write proc var major minor (next_val()) fathers is_seq seq_pos seq_fathers false)] @ 
+                                                    [merge_list (List.map (fun x -> get_read_write x var major minor (next_val()) fathers is_seq seq_pos seq_fathers false) args)])
+  | Or'(l) -> merge_list 
+              (List.map (fun x -> get_read_write x var major minor (next_val()) fathers is_seq seq_pos seq_fathers false) l)
+  | Seq'(l) -> let l = handle_seq l var major minor fathers 0 ([i] @ seq_fathers) [] in
+                merge_list l
+  | If'(te, th, el) -> merge_list [(get_read_write te var major minor (next_val()) fathers is_seq seq_pos seq_fathers false); (get_read_write th var major minor (next_val()) fathers is_seq seq_pos seq_fathers false); (get_read_write el var major minor (next_val()) fathers is_seq seq_pos seq_fathers false)]
+  | Set'(VarParam(v, x), value) -> 
+                          if v = var && x = minor && major = (-1) 
+                          then let (sp, sf) =
+                                if is_seq
+                                then (seq_pos, seq_fathers)
+                                else ((-1), []) in
+                                merge_list  ([[[]; [Pair(i, fathers, sp, sf, son_seq)]]] @ [(get_read_write value var major minor (next_val())  fathers is_seq seq_pos seq_fathers false)])
+                          else merge_list [(get_read_write value var major minor (next_val()) fathers is_seq seq_pos seq_fathers false)]
+  | Set'(VarBound(v, x, y), value) ->
+                          if v = var && x = major && y = minor  
+                          then let (sp, sf) =
+                                if is_seq
+                                then (seq_pos, seq_fathers)
+                                else ((-1), []) in
+                                merge_list  ([[[]; [Pair(i, fathers, sp, sf, son_seq)]]] @ [(get_read_write value var major minor (next_val())  fathers is_seq seq_pos seq_fathers false)])
+                          else merge_list [(get_read_write value var major minor (next_val()) fathers is_seq seq_pos seq_fathers false)]
+  | Set'(v, value) -> get_read_write value var major minor (next_val()) fathers is_seq seq_pos seq_fathers false
+  | Def'(v, value) -> get_read_write value var major minor (next_val()) fathers is_seq seq_pos seq_fathers false
+  | LambdaSimple'(vars, body) -> let fathers = [i] @ fathers in
+                                  get_read_write body var (major + 1) minor (next_val()) fathers is_seq seq_pos seq_fathers false
+  | LambdaOpt'(vars, v, body) -> let fathers = [i] @ fathers in
+                                  get_read_write body var (major + 1) minor (next_val()) fathers is_seq seq_pos seq_fathers false
+  | _ -> [[]; []]
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+  and handle_seq seq var major minor fathers seq_pos seq_fathers output =
+    match seq with
+    | [] -> output
+    | hd :: tl -> let output = output @ [(get_read_write hd var major minor (next_val()) fathers true seq_pos seq_fathers true)] in 
+                  (handle_seq tl var major minor fathers (seq_pos + 1) seq_fathers output);;
 
-let box_set e = raise X_not_yet_implemented;;
+let rec box_get_set e var major minor =
+  match e with
+  | Const' _ -> e
+  | Var'(VarParam(v, x)) -> if v = var && x = minor && major = (-1) then BoxGet'(VarParam(v, x)) else e
+  | Var'(VarBound(v, x, y)) -> if v = var && x = major && y = minor then BoxGet'(VarBound(v, x, y)) else e
+  | Applic'(proc, args) -> Applic'(box_get_set proc var major minor, List.map (fun x -> box_get_set x var major minor) args)
+  | ApplicTP'(proc, args) -> ApplicTP'(box_get_set proc var major minor, List.map (fun x -> box_get_set x var major minor) args)
+  | Or'(l) -> Or'(List.map (fun x -> box_get_set x var major minor) l)
+  | Seq'(l) -> Seq'(List.map (fun x -> box_get_set x var major minor) l)
+  | If'(te, th, el) -> If'(box_get_set te var major minor, box_get_set th var major minor, box_get_set el var major minor)
+  | Set'(VarParam(v, x), value) ->
+                          if v = var && x = minor && major = (-1)  
+                          then BoxSet'(VarParam(v, x), box_get_set value var major minor)
+                          else Set'(VarParam(v, x), box_get_set value var major minor)
+  | Set'(VarBound(v, x, y), value) ->
+                          if v = var && x = major && y = minor
+                          then BoxSet'(VarBound(v, x, y), box_get_set value var major minor)
+                          else Set'(VarBound(v, x, y), box_get_set value var major minor)
+  | Set'(v, value) -> Set'(v, box_get_set value var major minor)
+  | Def'(v, value) -> Def'(v, box_get_set value var major minor)
+  | LambdaSimple'(vars, body) -> LambdaSimple'(vars, box_get_set body var (major + 1) minor)
+  | LambdaOpt'(vars, v, body) -> LambdaOpt'(vars, v, box_get_set body var (major + 1) minor)
+  | BoxSet'(v, value) -> BoxSet'(v, box_get_set value var major minor)
+  | _ -> e;;
+
+let rec exists_mutual_father f1 f2 =
+  match f1 with
+  | [] -> false
+  | hd :: tl -> if (List.exists (fun x -> x = hd) f2) then true else exists_mutual_father tl f2
+
+let is_third_criterion sp1 sf1 sp2 sf2 b1 =
+  if (not b1)
+  then false
+  else if (List.hd sf1) = (List.hd sf2)
+  then sp1 <= sp2
+  else if (List.exists (fun x -> x = (List.hd sf1)) sf2) && (List.length sf1) < (List.length sf2)
+  then true
+  else false;;
+
+let rec passed_criterions p lst =
+  match lst with
+  | [] -> true
+  | Pair(i1, fathers1, sp1, sf1, b1) :: rest -> 
+                            (match p with
+                            | Pair(i2, fathers2, sp2, sf2, b2) -> 
+                                                      if (is_third_criterion sp1 sf1 sp2 sf2 b1 || is_third_criterion sp2 sf2 sp1 sf1 b2)
+                                                      then passed_criterions p rest
+                                                      else if ((i1 != i2) && (not (exists_mutual_father fathers1 fathers2)))
+                                                      then false
+                                                      else passed_criterions p rest)
+
+let rec need_box res =
+  match res with
+  | ([[]; []] | [[]; [_]] | [[_]; []]) -> false
+  | [r; w] -> (match r with
+              | [] -> false
+              | hd :: tl -> 
+                            if passed_criterions hd w
+                            then need_box [tl; w]
+                            else true)
+  | _ -> raise X_syntax_error;;
+
+let rec box_vars vars e output i is_seq =
+  match vars with
+  | [] -> output
+  | hd :: tl -> 
+                let res = get_read_write e hd (-1) i 0 [] is_seq (-1) [] is_seq in
+                let res = need_box res in
+                (match res with
+                | true -> let output = 
+                          let ex = box_get_set output hd (-1) i in
+                          (match ex with
+                          | Seq'(l) -> Seq'([Set'(VarParam(hd, i), Box'(VarParam(hd, i)))] @ l)
+                          | ex -> Seq'([Set'(VarParam(hd, i), Box'(VarParam(hd, i)))] @ [ex])) in
+                          box_vars tl e output (i - 1) is_seq
+                |_ -> box_vars tl e output (i - 1) is_seq)
+  
+let rec box' e =
+  match e with
+  | (Var' _ | Const' _) -> e
+  | Applic'(proc, args) -> Applic'(box' proc, List.map (fun x -> box' x) args)
+  | ApplicTP'(proc, args) -> ApplicTP'(box' proc, List.map (fun x -> box' x) args)
+  | Or'(l) -> Or'(List.map (fun x -> box' x) l)
+  | Seq'(l) -> Seq'(List.map (fun x -> box' x) l)
+  | If'(te, th, el) -> If'(box' te, box' th, box' el)
+  | Set'(var, value) -> Set'(var, box' value)
+  | Def'(var, value) -> Def'(var, box' value)
+  | LambdaSimple'(vars, body) -> let is_seq = match body with | Seq'(l) -> true | _ -> false in
+                                  LambdaSimple'(vars, box' (box_vars (List.rev vars) body body ((List.length vars) - 1) is_seq))
+
+  | LambdaOpt'(vars, var, body) -> let is_seq = match body with | Seq'(l) -> true | _ -> false in
+                                    LambdaOpt'(vars, var, box' (box_vars (List.rev (vars @ [var])) body body (List.length vars) is_seq))
+  | _ -> e;;
+
+let annotate_lexical_addresses e = annotate_lexical_addresses' e [];;
+
+let annotate_tail_calls e = annotate_tail_calls' e false;;
+
+let box_set e = box' e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
-end;; (* struct Semantics *)
-
 
+end;; (* struct Semantics *)
\ No newline at end of file
diff --git a/structure_test.sh b/structure_test.sh
new file mode 100755
index 0000000..8221853
--- /dev/null
+++ b/structure_test.sh
@@ -0,0 +1,109 @@
+#!/bin/bash
+
+BASE_DIR=$(pwd)
+PATCH=$1
+AUTHENTICITY=readme.txt
+CODE=semantic-analyser.ml
+STATEMENT="realize that should our code be found to contain code from other sources, that a formal case shall be opened against"
+PROBLEM=0
+GIT_REPO="https://www.cs.bgu.ac.il/~comp211/compiler"
+LOCAL_REPO=compiler
+TMP_FOLDER=$(mktemp -d)
+OCAML_TMP_FILE=struct_test.ml
+OCAML_TYPE_TEST="#use \"semantic-analyser.ml\";;
+(Const'(Void): expr');;
+(Const'(Sexpr(Nil)): expr');;
+(Var'(VarFree(\"abc\")): expr');;
+(Var'(VarParam(\"abc\",0)) :expr');;
+(Var'(VarBound(\"abc\",0,0)) : expr');;
+(If'(Const'(Void),Const'(Void),Const'(Void)): expr');;
+(Box' (VarFree(\"abc\")): expr');;
+(BoxGet' (VarParam(\"abc\",0)) :expr');;
+(BoxSet' (VarParam(\"abc\",0), Const' (Sexpr(Nil)) ) :expr');;
+(Seq' [Const'(Void)] : expr');;
+(Set' ((VarParam(\"abc\",0)), Const'(Void)) : expr');;
+(Def' ((VarParam(\"abc\",0)), Const'(Void)) : expr');;
+(Or' [Const'(Void)] : expr');;
+(LambdaSimple'([\"Asdas\"],Seq' ([Const'(Void)])) : expr');;
+(LambdaOpt'([\"Asdas\"],\"Asdas\",(Seq' [Const'(Void)])) : expr');;
+(Applic'(Const'(Void),[Const'(Void)]));;
+(ApplicTP'(Const'(Void),[Const'(Void)]));;
+"
+OCAML_SIG_TEST="#use \"semantic-analyser.ml\";;
+try
+  ((Semantics.run_semantics (Const(Sexpr(Number(Fraction (1,1)))))) :expr')
+with 
+| X_not_yet_implemented -> print_string \"Warning: Your submission has problems with   Semantics.run_semantics! implementation\n\"; Const'(Void)
+| PC.X_no_match -> Const'(Void)
+| X_syntax_error -> Const'(Void);;
+"
+cleanup () {
+    #echo "cleaning up temporary files and exiting."
+    rm -rf $TMP_FOLDER
+}
+
+if [ $# -lt 1 ]; then
+    PATCH="compiler/compiler.patch" 
+fi
+
+if ! [ -f $PATCH ]; then
+    echo "ERROR: The patch file '$PATCH' cannot be found. Please provide the relative path filename to your patch file."
+    exit 2
+fi
+
+cd $TMP_FOLDER
+git clone -q $GIT_REPO
+if [ "$?" -ne 0 ]; then
+    echo "ERROR: There was a problem creating a temporary clone of the project repository. There might be a problem with your network connection. The structure test cannot be completed."
+    cleanup
+    exit 2
+fi
+
+cd $LOCAL_REPO
+git apply --ignore-whitespace --whitespace=nowarn $BASE_DIR/$PATCH
+if [ "$?" -ne 0 ]; then
+    echo "ERROR: The contents of your patch file are invalid and git cannot apply it. The structure test cannot be completed."
+    cleanup
+    exit 2
+fi
+
+
+if ! [ -f $AUTHENTICITY ]; then
+    echo "ERROR: Your submission is missing the authenticity statement file ($AUTHENTICITY)."
+    PROBLEM=1
+else 
+    ID=$(egrep -e '[0-9]{7,10}' $AUTHENTICITY)
+    STMNT=$(cat $AUTHENTICITY | tr -d [:space:] | grep -i "$(echo "$STATEMENT" | tr -d [:space:])")
+
+    if [ -z "$ID" ] || [ -z "$STMNT" ] ; then
+	echo "ERROR: Your authenticity statement (in $AUTHENTICITY) is incomplete."
+	PROBLEM=1
+    fi
+fi
+
+if ! [ -f $CODE ]; then
+    echo "ERROR: Your submission is missing the required code file: $CODE."
+    PROBLEM=1
+fi
+
+echo $OCAML_TYPE_TEST > $OCAML_TMP_FILE && ocaml $OCAML_TMP_FILE 
+if [ $? -ne 0 ]; then
+    echo "ERROR: Your OCaml code contains invalid changes to  types."
+    PROBLEM=1
+fi
+
+echo $OCAML_SIG_TEST > $OCAML_TMP_FILE && ocaml $OCAML_TMP_FILE 
+if [ $? -ne 0 ]; then
+    echo "ERROR: Your OCaml code contains invalid changes to the signatures of the Semantics module."
+    PROBLEM=1
+fi
+
+if [ $PROBLEM -ne 0 ]; then
+    echo "!!! Your submission is invalid. Please correct the problems and try again. !!!"
+else 
+    echo "Your submission passed the structure test.
+This does not mean that your assignment is correct, only that we can test it properly."
+fi
+
+cleanup
+exit $PROBLEM
\ No newline at end of file
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..d127584 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,4 +1,5 @@
 #use "reader.ml";;
+open Reader;;
 
 type constant =
   | Sexpr of sexpr
@@ -58,8 +59,269 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let rec is_improper_list lst =
+  match lst with
+  | Nil -> false;
+  | Symbol(x) -> true;
+  | Pair(a, b) -> is_improper_list b
+  | _ -> raise X_this_should_not_happen;;
 
+let rec generate_names arg n =
+  let res = arg ^ (string_of_int n) in
+    match n with
+    | 1 -> [res]
+    | _ -> res :: (generate_names arg (n - 1))
+
+let rec tag_parse sexpr = match sexpr with
+    | Nil -> Const(Void)
+    | Bool(x) -> Const(Sexpr(Bool(x)))
+    | Number(x) -> Const(Sexpr(Number(x)))
+    | Char(x) -> Const(Sexpr(Char(x)))
+    | String(x) -> Const(Sexpr(String(x)))
+    | Symbol(x) -> Var(x)
+    | Pair(a, b) -> match a with
+                    | Symbol "quote" -> parse_quote b
+                    | Symbol "or" -> parse_or b
+                    | Symbol "if" -> parse_if b
+                    | Symbol "begin" -> parse_seq b
+                    | Symbol "and" -> parse_and b
+                    | Symbol "lambda" -> parse_lambda b
+                    | Symbol "set!" -> parse_set b
+                    | Symbol "let" -> tag_parse (expand_let b)
+                    | Symbol "let*" -> tag_parse (expand_let_star b)
+                    | Symbol "letrec" -> tag_parse (expand_letrec b)
+                    | Symbol "define" -> parse_define b
+                    | Symbol "cond" -> tag_parse (expand_cond b)
+                    | Symbol "quasiquote" -> parse_quasiquote b
+                    | Symbol "pset!" -> tag_parse (expand_pset b)
+                    | _ -> parse_applic a b
+
+  and parse_quote sexpr =
+    match sexpr with
+    | Pair(sexpr, Nil) -> Const(Sexpr sexpr)
+    | _ -> raise X_syntax_error
+
+  and parse_or sexpr =
+    match sexpr with
+    | Nil -> Const(Sexpr(Bool false))
+    | Pair(x, Nil) -> tag_parse x
+    | Pair(x, y) -> Or(pair_to_expr_list sexpr)
+    | _ -> raise X_syntax_error
+
+  and parse_if sexpr =
+    match sexpr with
+    | Pair(test, Pair(dit, Nil)) -> If(tag_parse test, tag_parse dit, Const Void)
+    | Pair(test, Pair(dit, Pair(dif, Nil))) -> If(tag_parse test, tag_parse dit, tag_parse dif)
+    | _ -> raise X_syntax_error
+
+  and parse_seq sexpr =
+    match sexpr with
+    | Nil -> Const Void
+    | Pair(x, Nil) -> tag_parse x
+    | Pair(x, y) -> Seq(pair_to_seq_list sexpr)
+    | _ -> raise X_syntax_error
   
-end;; (* struct Tag_Parser *)
+  and parse_and sexpr =
+    match sexpr with
+    | Nil -> Const(Sexpr(Bool(true)))
+    | Pair(x, Nil) -> tag_parse x
+    | _ -> tag_parse (expand_and sexpr)
+
+  and parse_lambda sexpr = 
+    match sexpr with
+    | Pair(args, body) ->
+        let body = parse_seq body in
+        (match args with
+          | Symbol(x) -> LambdaOpt([], x, body)
+          | args -> let l = pair_to_string_list args in
+                  if (is_improper_list args) then
+                  let last = List.nth l ((List.length l) - 1) in
+                  let args = List.rev (List.tl (List.rev l)) in
+                  LambdaOpt(args, last, body) else
+                  LambdaSimple(l, body))
+    | _ -> raise X_syntax_error
+
+  and parse_applic proc args =
+    let proc = tag_parse proc in
+    let args = List.map (fun x -> tag_parse x) (pair_to_list args) in
+    Applic(proc, args)
+
+  and parse_set sexpr =
+    match sexpr with
+    | Pair(Symbol(name), Pair(value, Nil)) -> Set(Var name, tag_parse value)
+    | _ -> raise X_syntax_error
+
+  and parse_define sexpr = 
+    match sexpr with
+    | Pair(Pair(first, rest), value) -> tag_parse (expand_define sexpr)
+    | Pair(name, Pair(value, Nil)) -> Def(tag_parse name, tag_parse value)
+    | _ -> raise X_syntax_error
+
+  and parse_quasiquote sexpr =
+  match sexpr with
+  | Pair(s, Nil) -> tag_parse (expand_quasiquote s)
+  | _ -> raise X_this_should_not_happen
+
+  and expand_and sexpr =
+    match sexpr with
+    | Pair(expr1, rest) -> 
+        let if1 = Symbol "if" in
+        let then1 = Pair(Symbol "and", rest) in
+        let else1 = Bool false in
+        let res = [if1] @ [expr1] @ [then1] @ [else1] in
+        list_to_pair res 
+    | _ -> raise X_syntax_error
+
+  and expand_let sexpr =
+    match sexpr with
+    | Pair(bindings, body) ->
+        let bindings = pair_to_list bindings in
+        let args = List.map (fun p -> 
+                                (match p with 
+                                | Pair(a, _) -> a 
+                                | _ -> raise X_no_match)) bindings in
+        let args = list_to_pair args in
+        let values = List.map (fun p -> 
+                                (match p with 
+                                | Pair(_, Pair(value, Nil)) -> value 
+                                | _ -> raise X_no_match)) bindings in
+        let values = list_to_pair values in
+        Pair(Pair(Symbol "lambda", Pair(args, body)), values)
+    | _ -> raise X_no_match
+
+  and expand_let_star sexpr =
+    match sexpr with
+    | Pair(bindings, body) ->
+        (match bindings with
+        | Nil -> Pair(Symbol "let", Pair(bindings, body))
+        | Pair(_, Nil) -> Pair(Symbol "let", Pair(bindings, body))
+        | Pair(first, rest) -> let bindings = Pair(first, Nil) in
+                                let body = Pair(Symbol "let*", Pair(rest, body)) in
+                                Pair(Symbol "let", Pair(bindings, Pair(body, Nil)))
+        | _ -> raise X_syntax_error)
+    | _ -> raise X_syntax_error
+
+  and expand_letrec sexpr =
+    match sexpr with
+    | Pair(bindings, body) ->
+        let bindings = pair_to_list bindings in
+        let new_bindings = List.map (fun p -> match p with 
+                                              | Pair(a, _) -> Pair(a, Pair(Pair(Symbol "quote", Pair(Symbol "whatever", Nil)), Nil))
+                                              | _ -> raise X_syntax_error) bindings in
+        let new_bindings = list_to_pair new_bindings in
+        let sets = List.map (fun p -> match p with 
+                                      | Pair(a, b) -> Pair(Symbol "set!", Pair(a, b))
+                                      | _ -> raise X_syntax_error) bindings in
+        let last = Pair(Symbol "let", Pair (Nil, body)) in
+        let body = sets @ [last] in
+        let body = list_to_pair body in
+        Pair(Symbol "let", Pair(new_bindings, body))
+    | _ -> raise X_syntax_error
 
+  and expand_define sexpr =
+    match sexpr with
+    | Pair(Pair(first, rest), value) -> 
+        let proc = Symbol "define" in
+        let value = Pair(Symbol "lambda", Pair(rest, value)) in
+        let res = [proc] @ [first] @ [value] in
+        list_to_pair res
+    | _ -> raise X_syntax_error
+
+  and expand_cond sexpr =
+    match sexpr with
+    | Nil -> Nil
+    | Pair(Pair(expr, Pair(Symbol "=>", Pair(exprf, Nil))), rest_ribs) -> 
+        let rest_ribs = expand_cond rest_ribs in 
+        let let1 = Symbol "let" in
+        let value = Pair(Symbol "value", Pair(expr, Nil)) in
+        let f = Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(exprf, Nil))), Nil)) in
+        let rest = if rest_ribs = Nil 
+                    then [] 
+                    else [Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(rest_ribs, Nil))), Nil))] in
+        let bindings = [value] @ [f] @ rest in
+        let if1 = Symbol "if" in
+        let test1 = Symbol "value" in
+        let then1 = Pair(Pair(Symbol "f", Nil), Symbol "value") in
+        let else1 = if rest = []
+                    then Nil
+                    else Pair(Symbol "rest", Nil) in
+        let body = [if1] @ [test1] @ [then1] @ [else1] in
+        let res = Pair(let1, Pair((list_to_pair bindings), Pair((list_to_pair body), Nil))) in
+        res
+
+    | Pair(Pair(Symbol "else", exprs), rest_ribs) ->
+        let exprs = pair_to_list exprs in 
+        list_to_pair ([Symbol "begin"] @ exprs)
+
+    | Pair(Pair(test, exprs), rest_ribs) ->
+        let exprs = Pair(Symbol "begin", exprs) in 
+        let rest_ribs = (expand_cond rest_ribs) in
+        list_to_pair ([Symbol "if"] @ [test] @ [exprs] @ [rest_ribs])
+
+    | _ -> raise X_syntax_error
+
+  and expand_quasiquote sexpr =
+    match sexpr with
+    | Pair(Symbol "unquote", Pair(s, Nil)) -> s
+    | Pair(Symbol "unquote-splicing", Pair(s, Nil)) -> raise X_syntax_error
+    | Nil -> Pair(Symbol "quote", Pair(Nil, Nil))
+    | Symbol x -> Pair(Symbol "quote", Pair(Symbol x, Nil))
+    | Pair(Pair(Symbol "unquote-splicing", Pair(s, Nil)), b) -> Pair(Symbol "append", Pair(s, Pair(expand_quasiquote b, Nil)))
+    | Pair(a, Pair(Symbol "unquote-splicing", Pair(s, Nil))) -> Pair(Symbol "cons", Pair(expand_quasiquote a, Pair(s, Nil)))
+    | Pair(a, b) -> Pair(Symbol "cons", Pair(expand_quasiquote a, Pair(expand_quasiquote b, Nil)))
+    | _ -> raise X_syntax_error
+
+  and expand_pset sexpr = 
+    let bindings = pair_to_list sexpr in
+    let vars = List.map (fun p -> match p with | Pair(v, _) -> v | _ -> raise X_syntax_error) bindings in
+    let vars = List.map (fun s -> match s with | Symbol x -> x | _ -> raise X_syntax_error) vars in
+    let exprs = List.map (fun p -> match p with | Pair(Symbol x, Pair(e, Nil)) -> e | _ -> raise X_syntax_error) bindings in
+    let exprs = list_to_pair exprs in
+    let arg = List.fold_left (fun a b -> a ^ b) "" vars in
+    let args = generate_names arg (List.length vars) in
+    let args = List.rev args in
+    let args = List.map (fun s -> Symbol s) args in
+    let body = List.map2 (fun v e -> Pair(Symbol "set!", Pair(Symbol v, Pair(e, Nil)))) vars args in
+    let body = list_to_pair body in
+    let args = list_to_pair args in
+    let body = Pair(Symbol "begin", body) in
+    let proc = Pair(Symbol "lambda", Pair(args, Pair(body, Nil))) in
+    let res = Pair(proc, exprs) in
+    res
+    
+
+  and list_to_pair sexpr =
+    List.fold_right (fun a b -> Pair(a, b)) sexpr Nil
+
+  and pair_to_list sexpr =
+    match sexpr with
+    | Nil -> []
+    | Pair(a, b) -> a :: pair_to_list b
+    | a -> [a]
+
+  and pair_to_string_list sexpr = 
+      match sexpr with
+      | Nil -> []
+      | Symbol(x) -> [x]
+      | Pair(Symbol(a), b) -> a :: pair_to_string_list b
+      | _ -> raise X_syntax_error
+  
+  and pair_to_expr_list sexpr = 
+      match sexpr with
+      | Nil -> []
+      | Pair(a, b) -> tag_parse a :: pair_to_expr_list b
+      | _ -> raise X_syntax_error
+
+  and pair_to_seq_list sexpr = 
+      match sexpr with
+      | Nil -> []
+      | Pair(Pair(Symbol "begin", b), _) -> pair_to_seq_list b
+      | Pair(a, b) -> tag_parse a :: pair_to_seq_list b
+      | _ -> raise X_syntax_error;;
+
+let rec tag_parse_expressions sexpr =
+  match sexpr with
+  | [] -> []
+  | hd :: tl -> tag_parse hd :: tag_parse_expressions tl;;
+
+end;; (* struct Tag_Parser *)
