diff --git a/reader.ml b/reader.ml
index 32445c2..b95bcb1 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,6 @@
 
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -41,6 +42,388 @@ let normalize_scheme_symbol str =
   else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+(* -------------------------------------------- *)
+let digit = range '0' '9';;
+let nt_digitSeq = plus(digit);;
+let nt_naturalPack = pack nt_digitSeq (fun (r)-> (int_of_string( list_to_string(r))));;
+
+let nt_plus = char '+';;
+let nt_minus = char '-';;
+let nt_plusOrMinus = disj nt_plus nt_minus;;
+let nt_plusMinus_natural =pack (caten nt_plusOrMinus nt_digitSeq)  (fun ((x,y))->x::y);;
+let nt_IntegerParser = disj nt_plusMinus_natural nt_digitSeq;;
+let nt_integerBuilt = (fun(r)-> Number(Fraction(int_of_string(list_to_string(r)),int_of_string("1"))))
+let nt_myIntegerPacked =  pack ( nt_IntegerParser ) nt_integerBuilt ;;
+
+
+(* -----fraction-------------- *)
+let functionForFlattenLeftPair = (fun (((p1,p2),r))-> (List.append p1 [p2],r));;
+
+let nt_slash = char '/';;
+let first = caten nt_IntegerParser nt_slash;;
+let flatFirst = pack first  (fun ((p1,p2))-> (List.append p1 [p2])) ;;
+
+let firstfractiontry = caten flatFirst nt_digitSeq;;
+let nt_fructionParser = pack firstfractiontry (fun ((p1,p2))-> (List.append p1 p2));;
+
+let rec gcdCode  = (fun (l)->
+  match l with
+  |[(x,y)] ->
+          begin
+          match x with
+          | 0 -> y
+          | x -> (gcdCode [((y mod x), x)])
+          end
+  |_-> raise X_this_should_not_happen
+  );;
+
+
+let wrapnumberInt = (fun (l)->( nt_IntegerParser  l ));;
+let wrapnumberInt2 = (fun ((x,y))-> (char '/') y );;
+let wrapnumberInt3 = (fun ((x,y))-> y) ;;
+let wrapnumberInt4 = (fun (l)->    wrapnumberInt3 (wrapnumberInt2 (wrapnumberInt(l))) );;
+let wrapnumberInt5 = ( fun((x,y)) -> x );;
+let wrapnumberInt6 = (fun(l)-> wrapnumberInt5 ( wrapnumberInt(l)) );;
+let wrapnumberInt7 = (fun(l)-> [ wrapnumberInt6(l) , wrapnumberInt4(l) ] );;(*end of parsing*)
+let wrapnumberInt8 = (fun(l)-> [ int_of_string(list_to_string(wrapnumberInt6(l)))   , int_of_string(list_to_string(wrapnumberInt4(l)))  ] );;(*end of parsing*)
+let wrapnumberInt9  =  (fun(l)->  (gcdCode( wrapnumberInt8( l ) )));;
+
+let wrapnumberInt10 = (fun (l,gcd)->
+  match l with
+  |[(x,y)]->(x/gcd,y/gcd)
+  |_-> raise X_this_should_not_happen);;
+
+
+let wrapnumberInt11 =  fun (l) ->( wrapnumberInt10( l ,  (gcdCode(l))));;
+let wrapnumberInt12 = (fun(l)-> wrapnumberInt11(wrapnumberInt8(l)) );;
+
+let buildfrac1 = fun (x,y)-> Number(Fraction(x,y));;
+let buildfrac2 = fun(l)-> buildfrac1(wrapnumberInt12(l));;
+
+let nt_fractionbuilder = pack nt_fructionParser buildfrac2;;
+
+
+(*-----float------------------------ *)
+let nt_dot = star(char '.');;
+let firstFloat = caten nt_IntegerParser nt_dot;;
+
+let firstFloatFlat = pack firstFloat (fun ((p1,p2))-> (List.append p1 p2));;
+
+let secontflaot = caten firstFloatFlat nt_digitSeq;;
+let nt_floatParserForBuilder = pack secontflaot (fun ((p1,p2))-> (List.append p1 p2));;
+
+let nt_floatBuilder = pack nt_floatParserForBuilder (fun  (x) -> Number(Float(float_of_string(list_to_string(x))))  );;
+
+
+(* -------sentific----------------------- *)
+let nt_eOrE = disj (char 'E') (char 'e');;
+
+let nt_integerOrFloat = disj  nt_floatParserForBuilder  nt_IntegerParser;;
+
+let nt_integerOrFloatUnpacked = (fun (l) ->(  (fun ((x,y))-> x)     (nt_integerOrFloat(l)))  );; (*important function*)
+
+let partsentific1 = caten nt_integerOrFloat nt_eOrE;;
+
+let partsentific2 = pack partsentific1 (fun ((p1,p2))-> (List.append p1 [p2]));;
+
+let partsentific3 = caten partsentific2 nt_IntegerParser;;
+
+let nt_Scientificparser = pack partsentific3 (fun ((p1,p2))-> (List.append p1 p2));;
+
+let partsentific4 = pack nt_Scientificparser (fun (x) -> nt_integerOrFloat(x) );;
+
+let partsentific5 = pack  partsentific4 (fun (l)->
+match l with
+|(x,a::b)-> (x,b)
+| _-> raise X_this_should_not_happen);;
+
+let nt_sentificbulider = pack partsentific5 (fun (x,y)-> Number(Float((float_of_string(list_to_string(x)))*.(10.**(float_of_string(list_to_string(y)))))));;
+
+
+(* WHITESPACES *)
+let nt_whitespaces = star (char ' ');;
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function(_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function(e, _) -> e) in
+        nt;;
+let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
+
+(* COMMENTS *)
+let nt_semicolon_tok = make_spaced(char ';');;
+let make_singled nt_left nt_right nt =
+  let nt = caten nt nt_left in
+  let nt = pack nt (function(e, _) -> e) in
+  let nt = caten nt_right nt in
+  let nt = pack nt (function(e, _) -> e) in
+        nt;;
+let make_commented nt = (make_singled (star nt_semicolon_tok) nt_epsilon nt);;
+
+
+(* LINE COMMENTS *)
+let endOfLine = char '\n';;
+
+let dotpsik = char ';';;
+let nt_amirSucks = (pack dotpsik) (function (l) -> []);;
+
+let untilcomment = caten nt_whitespaces dotpsik;;
+
+let untilcomment2 = pack untilcomment ( fun((x,y))-> List.append x [y] );;
+
+let rec afterComment = fun (l) -> match l with
+| a::b ->
+        begin
+        match a with
+        | '\n' -> ([],b)
+        | _ -> match (List.length b) with
+              | 0 -> ([],[])
+              | _ -> afterComment(b)
+        end
+| _ -> raise X_this_should_not_happen;;
+
+
+let untilcomment3 = pack untilcomment2 (fun (l) -> []);;
+
+let untilcomment4 = caten untilcomment3 afterComment;;
+
+let nt_comment = pack untilcomment4 (fun (l)-> []);;
+
+let nt_spacedComment = (make_spaced nt_comment);;
+
+
+(* BOOLEAN *)
+let nt_hashtag = char '#';;
+let nt_T = char 'T';;
+let nt_t = char 't';;
+let nt_tOrT = (disj nt_T nt_t);;
+let nt_F = char 'F';;
+let nt_f = char 'f';;
+let nt_fOrF = (disj nt_F nt_f);;
+let tok_true =  (caten nt_hashtag nt_tOrT);;
+let tok_false = (caten nt_hashtag nt_fOrF);;
+let nt_true = (pack (tok_true)) (function _ -> Bool(true));;
+let nt_false = (pack (tok_false)) (function _ -> Bool(false));;
+let nt_boolean = (disj nt_true nt_false);;
+
+
+(* SYMBOLS *)
+let nt_lowerCase_tok = (range 'a' 'z');;
+let nt_upperCase_tok = (range 'A' 'Z');;
+let nt_digits_tok = (range '0' '9');;
+let nt_punctuation_tok = (disj_list [char '!'; char '$';char '^';char '*';char '_';char '-';char '+';char '=';char '>';char '<';char '/';char '?'; char ':']);;
+
+let nt_dot = char '.';;
+
+let nt_preSymbol = (pack (plus(disj_list [nt_lowerCase_tok;nt_upperCase_tok;nt_digits_tok;nt_punctuation_tok;nt_dot])))
+                      (function (l) -> match l with
+                        | (['.']) -> raise PC.X_no_match
+                        | car::cdr -> l
+                        | [] -> raise PC.X_no_match);;
+
+let nt_symbol = (pack nt_preSymbol)(function (l) -> Symbol(list_to_string(
+                      List.map (lowercase_ascii) l)));;
+
+let nt_spacedSymbol = (make_spaced nt_symbol);;
+
+
+(* STRING META-CHAR (I CHOOSE YOU!) *)
+let nt_r = char 'r';;
+let nt_R = char 'R';;
+let nt_rOrR = (disj nt_r nt_R);;
+let nt_n = char 'n';;
+let nt_N = char 'N';;
+let nt_nOrN = (disj nt_n nt_N);;
+
+let nt_symBackslash = char '\\';;
+let nt_backback = (caten nt_symBackslash nt_symBackslash);;
+let nt_backslash = (pack nt_backback) (function _ -> '\\');;
+let nt_symQuotation = char '\"';;
+let nt_backQuotation = (caten nt_symBackslash nt_symQuotation);;
+let nt_quotation = (pack nt_backQuotation) (function _ -> '\"');;
+let nt_symBackT = (caten nt_symBackslash nt_tOrT);;
+let nt_backT = (pack nt_symBackT) (function _ -> '\t');;
+let nt_symBackR = (caten nt_symBackslash nt_rOrR);;
+let nt_backR = (pack nt_symBackR) (function _ -> '\r');;
+let nt_symBackN = (caten nt_symBackslash nt_nOrN);;
+let nt_backN = (pack nt_symBackN) (function _ -> '\n');;
+let nt_symBackF = (caten nt_symBackslash nt_fOrF);;
+let nt_backF = (pack nt_symBackF) (function _ -> '\012');;
+
+let nt_parserMetaChar = (disj_list [nt_symBackR;nt_symBackN;nt_symBackT; nt_symBackF; nt_backQuotation;nt_backback]);;
+let nt_metaChar = (disj_list [nt_backR;nt_backN;nt_backT; nt_backF;nt_backslash;nt_quotation]);;
+
+
+(* STRING LITERAL CHAR *)
+let nt_allChars = (disj_list [(range '\000' '\033'); (range '\035' '\091'); (range '\093' '\255')]);;
+let nt_stringLiteralChar = (pack nt_allChars) (function (c) -> Char(c));;
+
+
+(* STRING *)
+let rec last_element = (function (l) -> match l with
+                          | [] -> raise X_this_should_not_happen
+                          | [a] -> a
+                          | car::cdr -> last_element(cdr));;
+let rec but_last = (function (l) -> match l with
+                        | [] -> []
+                        | [a] -> []
+                        | car::cdr -> (List.append [car] (but_last cdr)));;
+
+let nt_stringChar = (disj nt_allChars nt_metaChar);;
+
+let nt_string = (pack (caten nt_symQuotation (caten (star nt_stringChar) nt_symQuotation)))
+                  (function ((a, (l, b))) -> String (list_to_string l));;
+
+
+(* NAMED CHARS *)
+let nt_hashBack = (caten nt_hashtag nt_symBackslash);;
+let nt_nul = pack (caten nt_hashBack (word_ci "nul")) (function _ -> Char('\000'));;
+let nt_newline = pack (caten nt_hashBack (word_ci "newline")) (function _ -> Char('\n'));;
+let nt_return = pack (caten nt_hashBack (word_ci "return")) (function _ -> Char('\r'));;
+let nt_tab = pack (caten nt_hashBack (word_ci "tab")) (function _ -> Char('\t'));;
+let nt_page = pack (caten nt_hashBack (word_ci "page")) (function _ -> Char('\012'));;
+let nt_space = pack (caten nt_hashBack (word_ci "space")) (function _ -> Char('\032'));;
+let nt_namedChars = (disj_list [nt_nul;nt_newline;nt_return;nt_tab;nt_page;nt_space]);;
+
+
+(* VISIBLE CHARS *)
+let nt_visibleChars = (pack (caten nt_hashBack (range '\032' '\255'))) (function ((h, b), c) -> Char(c));;
+
+
+(* CHARS *)
+let nt_chars = (disj nt_namedChars nt_visibleChars);;
+
+(* NUMBERS *)
+let nt_numbers = disj_list[nt_Scientificparser;nt_floatParserForBuilder ;nt_fructionParser; nt_IntegerParser];;
+let nt_numbersalmost = disj_list[nt_sentificbulider;nt_floatBuilder;nt_fractionbuilder;nt_myIntegerPacked];;
+let nt_numbersBuilder = not_followed_by nt_numbersalmost nt_symbol;;
+
+
+(* HELP FUNCTIONS FOR SEXPR RECURSION *)
+exception X_1;;
+exception X_2;;
+exception X_3;;
+exception X_4;;
+let tok_lparen = make_spaced(char '(');;
+let tok_rparen = make_spaced(char ')');;
+
+let nt_nil = (pack (caten tok_lparen tok_rparen)) (function _ -> Nil);;
+
+let rec nested_pairs = (function (l) -> match l with
+              | [] -> Nil
+              | car::cdr -> Pair(car, nested_pairs(cdr)));;
+
+let rec dotted_pairs = (function (l) -> match l with
+              | ([a], b) -> Pair(a, b)
+              | (car::cdr, c) -> Pair(car, (dotted_pairs (cdr, c)))
+              | ([], _) -> raise PC.X_no_match);;
+
+let rec listed_list_to_list = (function (l) -> match l with
+              | [] -> []
+              | [a] -> a
+              | a::b -> (List.append a (listed_list_to_list b)));;
+
+let rec commenting_sexpr = (function (l) -> match l with
+              | ([], b) -> b
+              | (c::d, e::f) -> (commenting_sexpr (d, f))
+              | (_::_, []) -> raise PC.X_no_match);;
+
+let nt_symSexpComment = ((make_spaced (word "#;")));;
+
+let unlist = (function (l) -> match l with
+                | [] -> Nil
+                | [a]-> a
+                | _ -> raise PC.X_no_match);;
+
+
+(* SEXPR RECURSIVE FUNCTION *)
+let rec nt_sexpr s =
+  let nt_sexpr =  (disj_list[nt_numbersBuilder;nt_boolean; nt_symbol; nt_string; nt_chars; nt_nil; nt_list; nt_dottedList; nt_quote; nt_qquote; nt_unquote;nt_splicing]) in
+  nt_sexpr s
+
+
+(* LISTS *)
+and nt_list s =
+let nt_list = (pack (caten tok_lparen (caten (star (make_spaced nt_sexprBuilder)) tok_rparen)))
+                (function ((a, (l, b))) -> (nested_pairs (listed_list_to_list l))) in
+nt_list s
+
+and nt_dottedList s =
+let nt_dottedList = (pack (caten tok_lparen (caten (plus (make_spaced nt_sexprBuilder)) (caten nt_dot (caten (plus (make_spaced nt_sexprBuilder)) tok_rparen)))))
+                (function ((a, (l, (b, (m, c))))) -> (dotted_pairs ((listed_list_to_list l), (unlist (listed_list_to_list m))))) in
+nt_dottedList s
+
+
+(* QUOTE *)
+and nt_quote s =
+let nt_quote = (pack (caten (char '\039') nt_sexprBuilder))
+          (function ((a, b)) -> (Pair ((Symbol "quote"), Pair((unlist b), Nil)))) in
+nt_quote s
+and nt_qquote s =
+let nt_qquote = (pack (caten (char '`') nt_sexprBuilder))
+          (function ((a, b)) -> (Pair ((Symbol "quasiquote"), Pair((unlist b), Nil)))) in
+nt_qquote s
+and nt_unquote s =
+let nt_unquote = (pack (caten (char ',') nt_sexprBuilder))
+          (function ((a, b)) -> (Pair ((Symbol "unquote"), Pair((unlist b), Nil)))) in
+nt_unquote s
+and nt_splicing s =
+let nt_splicing = (pack (caten (word ",@") nt_sexprBuilder))
+          (function ((a, b)) -> (Pair ((Symbol "unquote-splicing"), Pair((unlist b), Nil)))) in
+nt_splicing s
+
+
+(* SEXPRS COMMENTS *)
+and nt_sexpComment s =
+let nt_sexpComment = (pack (caten (star nt_symSexpComment) (plus (make_spaced nt_sexpr))))
+                  (function (l) -> ( (commenting_sexpr (l)))) in
+nt_sexpComment s
+
+
+(* LINE COMMENTS 2 *)
+and nt_help1 s =
+let nt_help1 = caten nt_sexpComment nt_spacedComment in
+nt_help1 s
+
+and nt_help2 s =
+let nt_help2 = caten nt_spacedComment nt_sexpComment in
+nt_help2 s
+
+and nt_help3 s =
+let nt_help3 = (caten (nt_spacedComment) (caten nt_sexpComment nt_spacedComment)) in
+nt_help3 s
+
+and nt_helpFun1 s =
+let nt_helpFun1 = (pack nt_help1) (function ((x,y)) -> x) in
+nt_helpFun1 s
+
+and nt_helpFun2 s =
+let nt_helpFun2 = (pack nt_help2) (function ((x,y)) -> y) in
+nt_helpFun2 s
+
+and nt_helpFun3 s =
+let nt_helpFun3 = (pack nt_help3) (function ((x,(y,z))) -> y) in
+nt_helpFun3 s
+
+and nt_sexprAlmost s =
+let nt_sexprAlmost = (disj_list [nt_helpFun2; nt_helpFun1; nt_helpFun3; nt_spacedComment]) in
+nt_sexprAlmost s
+
+and nt_sexprBuilder s =
+let nt_sexprBuilder = disj nt_sexprAlmost nt_sexpComment in
+nt_sexprBuilder s;;
+
+
+(* END *)
+let nt_specialChars = (star (disj_list [(char ' '); (char '\n'); (char '\t'); (char '\012')]));;
+let make_metaChared nt = make_paired nt_specialChars nt_specialChars nt;;
+
+let nt_metaCharedSexpr = (make_metaChared nt_sexprBuilder);;
+let nt_final = (pack (plus nt_metaCharedSexpr)) (function (l) -> (listed_list_to_list l));;
+
+let read_sexprs string =
+  let inputAsList = string_to_list string in
+  let ast, alol = (nt_final) inputAsList in
+  ast;;
   
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..2bf3dc5 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Oriel Limor 308493766
+Amir Levy 311328314
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..d7d69d4 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -69,17 +69,432 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+  exception Z_1;;
+  exception Z_2;;
+  exception Z_3;;
+  exception Z_4;;
+  
+  (* let annotate_lexical_addresses e = List.map getlexical e;;
+  
+  let rec getlexical = (fun(l)-> match l with
+  
+  
+  
+  )
+  let rec *)
+  
+  (*-------lexical adressing -----------------------------------------------*)
+  let getMinorFromTuple = (fun (l)-> List.nth l 1 );;
+  let getMajorFromTuple = (fun (l)-> List.nth l 0 );;
+  
+  let rec getlexical = (fun(e,lstlst)-> match e with
+  | Const(x)-> Const'(x)
+  | Var(x)-> Var'(buildVarTag(x,lstlst))
+  | If(x,y,z)->If'(getlexical(x,lstlst),getlexical(y,lstlst),getlexical(z,lstlst))
+  | Seq(x)->  Seq'(getlexicalAList(x,lstlst))
+  | Set(Var(x),y)-> Set'(buildVarTag(x,lstlst),getlexical(y,lstlst))
+  | Def(Var(x),y)->Def'(VarFree(x),getlexical(y,lstlst))
+  | Or(x)-> Or'(getlexicalAList(x,lstlst))
+  | LambdaSimple(stringlist,expr)-> LambdaSimple'(stringlist,getlexical(expr,  (([stringlist])@ (lstlst) )  ))
+  | LambdaOpt(stringlist,onestring,bodies) ->LambdaOpt'(stringlist,onestring,getlexical(bodies,((([stringlist @ [onestring]]) @ (lstlst) )  ) ))
+  | Applic(expr,exprList) ->Applic'(getlexical(expr,lstlst),getlexicalAList(exprList,lstlst))
+  |_->raise X_syntax_error
+  )
+  
+  and getlexicalAList = (fun(exprList,lstlst)->
+    match exprList with
+    |[]->[]
+    |a::b-> [(getlexical(a,lstlst))]@(getlexicalAList(b,lstlst))
+    )
+  
+  and buildVarTag = (fun( variable,argsLstLst )-> 
+    let majorMinor  = getMajorMinor(variable,argsLstLst) in 
+    let major = getMajorFromTuple(majorMinor) in 
+    let minor =  getMinorFromTuple(majorMinor) in
+    match major with 
+    |(-2)-> VarFree(variable)
+    |(-1)-> VarParam(variable,minor)
+    |(a) when (a>(-1)) -> VarBound(variable,major,minor)
+    |_->raise X_syntax_error
+    )
+  
+  
+  
+  (*assume it recives an array of arrays named argsList - with args collected from lmbdas*)
+  (*l is the element(the arg) to be found*)
+  (*argsList's first array is Major 0 , the next one is 2 and so on*)
+  (*it returns the major and mimor of it*)
+  and getMajorMinor = (fun(element,argsList)-> 
+  getMjMi((-1),element,argsList)    (*-2 means empty list , -1 params , 0 and bigger env*)
+  (*dont forget!!!! to order first arrays to be lower numbers*)
+  ) 
+  
+  and getMjMi = (fun(curMajor,element,argsList)-> 
+  match argsList with 
+  |[] -> [-2;-2] 
+  (*meaning -> element was not found *)
+  |a::b-> 
+    let minorIndex = getMinorIndex(element,a,0) in
+    if ( minorIndex > -1 ) then [curMajor;minorIndex]
+    else getMjMi((curMajor+1),element, b)
+  
+  )
+  
+  
+  and getMinorIndex =(fun(element,mylist,currentIndex)-> match mylist with
+  |[]-> -1 (*meaning-> element was not found in list*)
+  |a::b when (String.equal a element)-> currentIndex
+  |a::b-> getMinorIndex(element,b,(currentIndex+1))
+  (* |_->raise X_syntax_error *)
+  )
+  ;;
+  
+  
+  
+  (*--------------------------------------------------------------------------------------*)
+  
+  (*----------Anotating tail calls----------------------------------------------------------------------------*)
+  
+  
+  
+  let rec getTP = (fun(e,in_tp)->match e with
+  | Const'(x)->Const'(x)
+  | Var'(x)->Var'(x) 
+  | If'(x,y,z) when (in_tp == true) -> If'(getTP(x,false),getTP(y,true),getTP(z,true) )
+  | If'(x,y,z) -> If'(getTP(x,false),getTP(y,false),getTP(z,false) )
+  | Seq'(x) -> Seq'(tcEndOfList(x,in_tp))
+  | Set'(x,y) -> Set'(x,getTP(y,false)) 
+  | Def'(x,y) -> Def'(x,getTP(y,false))
+  | Or' (x) -> Or'(tcEndOfList(x,in_tp))
+  | LambdaSimple'(stringList,bodies) -> LambdaSimple'(stringList,getTP(bodies,true))
+  | LambdaOpt'(stringlist,oneString,bodies)->LambdaOpt'(stringlist,oneString,getTP(bodies,true))
+  | Applic'(x,y) when (in_tp == true) -> ApplicTP'(getTP(x,false),getTPAList(y,false))
+  | Applic'(x,y) -> Applic'(getTP(x,false),getTPAList(y,false))
+  |_->raise X_syntax_error
+  
+  )
+  
+  and tcEndOfList =  (fun(lst,in_tp)-> match lst with
+  
+    |[]->[]
+    |[a]-> [getTP(a,in_tp)]
+    |a::b -> [getTP(a,false)] @ tcEndOfList(b,in_tp)
+    
+    
+  )
+  
+  and getTPAList = (fun(exprList,in_tp)->
+    match exprList with
+    |[]->[]
+    |a::b-> [(getTP(a,in_tp))]@(getTPAList(b,in_tp))
+    )
+  ;;
+  
+  
+  
+  (*--------------------------------------------------------------------------------------------*)
+  
+  
+  
+  let rec boxTheArg = (fun(myArgName,mylambda)-> match mylambda with
+  | LambdaSimple'(stringList,bodies)->
+    let minor = (getArgMinor(myArgName,stringList,0)) in
+    LambdaSimple'(stringList,addFlattly(
+      Set'(VarParam(myArgName, minor), Box'(VarParam(myArgName,minor))),
+      addBoxToBody(myArgName,bodies)  ))
+  | LambdaOpt'(stringList,onestring,bodies)->
+    let minor = (getArgMinor(myArgName,stringList@[onestring],0)) in
+    LambdaOpt'(
+      stringList,onestring, addFlattly(
+        Set'(VarParam(myArgName, minor), Box'(VarParam(myArgName,minor))),
+        addBoxToBody(myArgName,bodies)    ) )
+  |_-> raise X_syntax_error
+  )
+  
+  and addFlattly= (fun(myBoxExp,bodies)->match bodies with
+  |Seq'(x)->Seq'(([myBoxExp] @ x))
+  |_-> Seq'([myBoxExp] @ [bodies] ))
+  
+  
+  and getArgMinor =(fun(element,mylist,currentIndex)-> match mylist with
+  |[]-> -1 (*meaning-> element was not found in list*)
+  |a::b when (String.equal a element)-> currentIndex
+  |a::b-> getArgMinor(element,b,(currentIndex+1))
+  (* |_->raise X_syntax_error *)
+  )
+  
+  and addBoxToBody = (fun(myArgName,mybodies)-> 
+    let recAddBox = (fun(e)->(addBoxToBody(myArgName,e))) in
+    match mybodies with
+  | Const'(x)->Const'(x)
+  | Var'(x)-> 
+    begin
+    match x with 
+     | VarFree(a)->if(a=myArgName) then BoxGet'(x) else Var'(x)
+     | VarParam(a,b)->if(a=myArgName) then BoxGet'(x) else Var'(x)
+     | VarBound(a,b,c)->if(a=myArgName) then BoxGet'(x) else Var'(x)
+   end 
+  (* | Box' of var
+  | BoxGet' of var
+  | BoxSet' of var * expr' *)
+  | If'(x,y,z) -> If'(recAddBox(x),recAddBox(y),recAddBox(z))
+  | Seq'(x) -> Seq'(List.map recAddBox x)
+  | Set'(x,y) ->
+    begin
+      match x with
+      | VarFree(a)->if(a=myArgName) then BoxSet'(x,recAddBox(y)) else Set'(x,recAddBox(y))
+      | VarParam(a,b)->if(a=myArgName) then BoxSet'(x,recAddBox(y)) else Set'(x,recAddBox(y))
+      | VarBound(a,b,c)->if(a=myArgName) then BoxSet'(x,recAddBox(y)) else Set'(x,recAddBox(y))
+    end
+  
+    (* if(x==myArgName) then Set'(x,recAddBox(y))
+     else Set'(x,recAddBox(y)) *)
+  | Def'(x,y) -> Def'(x,recAddBox(y))
+  | Or' (x) -> Or' (List.map recAddBox x) 
+  | LambdaSimple'(stringList,bodies)->
+    if(List.mem myArgName (stringList))
+      then mybodies 
+       else LambdaSimple'(stringList,recAddBox(bodies))
+  | LambdaOpt'(stringlist,onestring,bodies)->
+    if(List.mem myArgName (stringlist@[onestring]))
+       then mybodies 
+        else LambdaOpt'(stringlist,onestring,recAddBox(bodies))
+  | Applic'(xexpr,exprList) -> Applic'(recAddBox(xexpr),(List.map recAddBox  exprList))
+  | ApplicTP'(xexpr,(exprList)) -> ApplicTP'(recAddBox(xexpr),(List.map recAddBox  exprList))
+  |_->raise X_syntax_error
+   
+    )
+  
+  and argNotInArgs = (fun(arg,argList)->
+    if(List.mem arg argList) then 1 else 0  
+    )
+  
+  ;;
+  
+  let amir_supplement = (function (n) -> match n with
+    | [-2] -> false 
+    | _ -> true);;
+  
+  let different_element = (function (n,l,m) -> 
+    (* match l with
+    |  *)
+    if((not(List.mem (List.hd l) (List.tl l)) && (List.tl l)!=[]) || not(List.mem (List.hd l) m)) then (4,n)
+    else (3,n));;
+  
+     
+  let rec numSec = (fun(num,listOfTuples)->
+    let result = assistance(num,listOfTuples,[]) in 
+    if(result = []) then [(-2)] else result
+    )
+  
+  and assistance = (fun(num,listOfTuples,listOfRights)-> match listOfTuples with
+    |a::b -> 
+      begin
+      match a with 
+      |(x,y) when (x=num)->assistance(num,b, (listOfRights @ [y]) )
+      |(x,y) -> assistance(num,b,listOfRights)
+      end
+    |[]-> listOfRights
+    );;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+  
+  
+  
+  let myglobal = ref 0;; 
+    let special = (fun()-> ( myglobal :=(!myglobal)+1)  )  ;; 
+    let special2 = (fun(l)->if((special())=())  then !myglobal else 0);;
+  
+  let appender = (function (n,l) -> 
+    if (n == 0) then l
+    else if (List.mem n l) then l
+    else ([n] @ l));;
+  
+  let rec boxer = (function (e, v, n) -> match e with
+  | Const'(x) -> (0,n)
+  | Var'(VarFree(x)) -> var_handler (x,v,n)
+  | Var'(VarParam(x,y)) -> var_handler (x,v,n)
+  | Var'(VarBound(x,y,z)) -> var_handler (x,v,n)
+  (* | Var'(VarBound(x,y,z)) -> (match v with 
+                  | x -> (1,n)
+                  | _ -> (0,n)) *)
+  | If'(x,y,z) -> if_handler (n, boxer (x,v,n) , boxer (y,v,n), boxer (z,v,n))
+  | Seq'(x) -> seq_handler (n, (List.map (fun (y) -> (boxer (y,v,n))) x))
+  | Set'(VarFree(x),y) -> pre_set_handler(x,v,n,y)
+  | Set'(VarParam(x,i),y) -> pre_set_handler(x,v,n,y)
+  | Set'(VarBound(x,i,j),y) -> pre_set_handler(x,v,n,y)
 
-let box_set e = raise X_not_yet_implemented;;
+  | Def'(x,y) -> (boxer (y,v,n))
+  | Or' (x) -> seq_handler (n, (List.map (fun (y) -> (boxer (y,v,n))) x))
+  | LambdaSimple'(stringList,bodies) -> (boxer (bodies,v,special2()))
+  | LambdaOpt'(stringlist,oneString,bodies) -> (boxer (bodies,v,special2()))
+  | Applic'(x,y) -> applic_handler (n, (boxer (x,v,n)), (List.map (fun (z) -> (boxer (z,v,n))) y))
+  | ApplicTP'(x,y) -> applic_handler (n, (boxer (x,v,n)), (List.map (fun (z) -> (boxer (z,v,n))) y))
+  |_->raise X_syntax_error
+                )
+  
+  and if_handler = (function (n, (x,a), (y,b), (z,c)) ->
+    if (x==4 || y==4 || z==4 ||
+        (x==3 && y>=1 && a!=b) || (x==3 && z>=1 && a!=c) || 
+        (y==3 && x>=1 && a!=b) || (y==3 && z>=1 && b!=c) ||
+        (z==3 && x>=1 && a!=c) || (z==3 && y>=1 && b!=c) ||
+        (x==2 && y==1 && a!=b) || (x==2 && z==1 && a!=c) ||
+        (y==2 && x==1 && a!=b) || (y==2 && z==1 && b!=c) ||
+        (z==2 && x==1 && a!=c) || (z==2 && y==1 && b!=c)) then (4,n) 
+    else if (x==3 || (x==2 && y==1) || (x==2 && z==1) || (y==2 && x==1) || (z==2 && x==1)) then (3,n)
+    else if (y==3 || (y==2 && z==1) || (z==2 && y==1)) then (3,n)
+    else if (z==3) then (3,n)
+    else if (x==2) then (2,n)
+    else if (y==2) then (2,n)
+    else if (z==2) then (2,n)
+    else if (x==1) then (1,n)
+    else if (y==1) then (1,n)
+    else if (z==1) then (1,n)
+    else (0,n))
+     
+  
+  and var_handler = (function (x,v,n) -> 
+    if(v = x) then (1,n)
+    else (0,n))
+  
+  and pre_set_handler = (function (x,v,n,y) ->
+    if (v = x) then (set_handler (2,n,(boxer (y,v,n))))
+    else (set_handler (0,n,(boxer (y,v,n)))))
+  
+  and seq_handler = (function (n,l) -> 
+    if (amir_supplement (numSec (4,l))) then (4,n)
+    else if ((amir_supplement (numSec (1,l))) && (amir_supplement (numSec (2,l)))) then (different_element (n,numSec (1,l),numSec (2,l))) 
+    else if (amir_supplement (numSec (3,l))) then (3,n)
+    else if (amir_supplement (numSec (1,l))) then (1,n)
+    else if (amir_supplement (numSec (2,l))) then (2,n)
+    else (0,n))
+  
 
-let run_semantics expr =
-  box_set
-    (annotate_tail_calls
-       (annotate_lexical_addresses expr));;
   
-end;; (* struct Semantics *)
+  and applic_handler = (function (n, (x,y), l) -> 
+    if (amir_supplement(numSec(4,l)) || x == 4) then (4,n)
+    else if (((amir_supplement (numSec (1,l))) && (amir_supplement (numSec (2,l))))) then (different_element (n,numSec (1,l),numSec (2,l)))
+    else if ((x == 1 && (amir_supplement (numSec (2,l))))) then (different_element (n,([y] @ numSec (1,l)),numSec (2,l)))
+    else if ((x == 2 && (amir_supplement (numSec (1,l))))) then (different_element (n,numSec (1,l),([y] @ numSec (2,l))))
+    else if (amir_supplement (numSec (3,l))) then (3,n)
+    else if (x == 3) then (3, n)
+    else if (amir_supplement (numSec (2,l))) then (2,n)
+    else if (x == 2) then (2, n)
+    else if (amir_supplement (numSec (1,l))) then (1,n)
+    else if (x == 1) then (1, n)
+    else (0,n))
+  
+  and set_handler = (function (x,n,(y,z)) -> 
+    if (y == 4) then (4,n)
+    else if (y == 3) then (3,n)
+    else if (y == 2 && x == 2) then (2,n)
+    else if (y == 1 && x == 2) then (3,n)
+    else if (y == 0 && x == 2) then (2,n)
+    else if (y == 2 && x == 0) then (2,n)
+    else if (y == 1 && x == 0) then (1,n)
+    else (0,n));;
+  
+
+  let first_tuple = (function (a,b) -> a);;
+  
+  let two_times = (function (n,l) -> 
+    if ((List.length (List.filter (fun (a) -> (a==n)) l)) >=2 ) then true
+    else false);;
+  
+  let rec sec_box = (function (e, n) -> match e with
+    | If'(x,y,z) -> If'(sec_box (x,n), sec_box (y,n), sec_box (z,n))
+    | Seq'(x) -> Seq' (List.map (fun (y) -> (sec_box (y,n))) x)
+    | Set'(x,y) -> Set'(x, sec_box (y,n))
+    | Def'(x,y) -> Def'(x, sec_box (y,n))
+    | Or' (x) -> Or' (List.map (fun (y) -> (sec_box (y,n))) x)
+    | LambdaSimple'(stringList,bodies) -> (List.fold_left (fun a b -> helper_to_box (lambda_helper(bodies, b, n+1), a, b)) (LambdaSimple'(stringList,bodies)) stringList)        
+    | LambdaOpt'(stringList,oneString,bodies) -> (List.fold_left (fun a b -> helper_to_box (lambda_helper(bodies, b, n+1), a, b)) (LambdaOpt'(stringList,oneString,bodies)) (stringList @ [oneString])) 
+    | Applic'(x,y) -> Applic' (sec_box (x,n), (List.map (fun (z) -> (sec_box (z,n))) y))
+    | ApplicTP'(x,y) -> ApplicTP' (sec_box (x,n), (List.map (fun (z) -> (sec_box (z,n))) y))
+    | _ -> e)
+  
+  and lambda_helper = (function (e,v,n) -> match e with 
+    | Const'(x) -> 0
+    | Var'(VarFree(x)) -> var_helper(x,v)
+    | Var'(VarParam(x,i)) -> var_helper(x,v)
+    | Var'(VarBound(x,i,j)) -> var_helper(x,v)
+    | If'(x,y,z) -> if_helper(lambda_helper (x,v,n), lambda_helper (x,v,n), lambda_helper (x,v,n))
+    | Seq'(x) -> (seq_helper ((List.map (fun (a) -> lambda_helper (a,v,n)) x)))
+    | Set'(VarFree(x),y) -> set_helper (x, lambda_helper (y,v,n), v)
+    | Set'(VarParam(x,i),y) -> set_helper (x, lambda_helper (y,v,n), v)
+    | Set'(VarBound(x,i,j),y) -> set_helper (x, lambda_helper (y,v,n), v)
+    | Or' (x) -> (seq_helper ((List.map (fun (a) -> lambda_helper (a,v,n)) x)))
+    | LambdaSimple'(stringList,bodies) -> first_tuple (boxer (LambdaSimple'(stringList,bodies),v,0))
+    | LambdaOpt'(stringlist,oneString,bodies) -> first_tuple (boxer (LambdaOpt'(stringlist,oneString,bodies),v,0))
+    | Applic'(x,y) -> applic_helper (lambda_helper (x,v,n), (List.map (fun (a) -> lambda_helper (a,v,n)) y))
+    | ApplicTP'(x,y) -> applic_helper (lambda_helper (x,v,n), (List.map (fun (a) -> lambda_helper (a,v,n)) y))
+    | _ -> 0)
+  
+  and var_helper = (function (x,v) -> 
+    if(x==v) then 1
+    else 0) 
 
+  and seq_helper = (function (l) -> 
+    if ((List.mem 5 l) || two_times(4,l) || two_times(3,l) ||
+       ((List.mem 4 l) && (List.mem 3 l)) || ((List.mem 4 l) && (List.mem 2 l)) ||
+       ((List.mem 4 l) && (List.mem 1 l)) || ((List.mem 3 l) && (List.mem 2 l)) ||
+       ((List.mem 3 l) && (List.mem 1 l)) || ((List.mem 2 l) && (List.mem 1 l))
+        ) then 5
+    else if (List.mem 4 l) then 4 
+    else if (List.mem 3 l) then 3 
+    else if (List.mem 2 l) then 2 
+    else if (List.mem 1 l) then 1 
+    else 0)
+  
+  and if_helper = (function (x, y, z) -> 
+    if (x==5 || y==5 || z==5 ||
+        (x==4 && y>=1) || (x==4 && z>=1) || (y==4 && x>=1) || (y==4 && z>=1) ||
+        (z==4 && x>=1) || (z==4 && y>=1) || (x==3 && y>=1) || (x==3 && z>=1) || 
+        (y==3 && x>=1) || (y==3 && z>=1) || (z==3 && x>=1) || (z==3 && y>=1) ||
+        (x==1 && y==2) || (x==1 && z==2) || (y==1 && x==2) || (y==1 && z==2) ||
+        (z==1 && x==2) || (z==1 && y==2)
+        ) then 5
+    else if (x==4 || y==4 || z==4) then 4 
+    else if (x==3 || y==3 || z==3) then 3
+    else if (x==2 || y==2 || z==2) then 2
+    else if (x==1 || y==1 || z==1) then 1
+    else 0)
+  
+  and set_helper = (function (x, y, v) -> 
+    if ((x==v && y>=3) || (x==v && y==1) || y==5) then 5
+    else if (x!=v) then y
+    else if (x==v && y==2) then 2
+    else 0)
+  
+  and applic_helper = (function (x, l) -> 
+    if(x==5 || (List.mem 5 l) || two_times(4,l) || two_times(3,l) ||
+      ((List.mem 4 l) && (List.mem 3 l)) || ((List.mem 4 l) && (List.mem 2 l)) ||
+      ((List.mem 4 l) && (List.mem 1 l)) || ((List.mem 3 l) && (List.mem 2 l)) ||
+      ((List.mem 3 l) && (List.mem 1 l)) || ((List.mem 2 l) && (List.mem 1 l)) || 
+      (x>=1 && List.mem 4 l) || (x>=1 && List.mem 3 l) || (x>=3 && List.mem 2 l) ||
+      (x==1 && List.mem 2 l) || (x==1 && List.mem 1 l)) then 5
+    else if (x==4 || List.mem 4 l) then 4
+    else if (x==3 || List.mem 3 l) then 3
+    else if (x==2 || List.mem 2 l) then 2
+    else if (x==1 || List.mem 1 l) then 1
+    else 0)
+  
+  and helper_to_box = (function (n, ogLambda, v) -> 
+    if (n == 5) then (boxTheArg (v, ogLambda))
+    else ogLambda);;
 
+   let box_set e = sec_box(e,0);; 
+
+   let annotate_lexical_addresses e = getlexical(e,[]) ;;
+
+  
+   let annotate_tail_calls e = getTP(e,false);;
+  
+  
+   let run_semantics expr =
+     box_set
+       (annotate_tail_calls
+          (annotate_lexical_addresses expr));;
+
+
+
+end;; (* struct Semantics *)
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..59970dc 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,4 +1,6 @@
 #use "reader.ml";;
+open Reader;;
+
 
 type constant =
   | Sexpr of sexpr
@@ -58,8 +60,448 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
 
+
+
+(*_____________________________________________________*)
+
+
+exception X_Illegal_use_of_unquote_splicing;;
+exception X_in_append;;
+exception Y_1;;
+exception Y_2;;
+exception Y_3;;
+exception Y_4;;
+
+let rec lambda_arguments_to_list = (function (arg) -> match arg with
+          | (Symbol x, Nil) -> [x]
+          | (Symbol x, Symbol y) -> [x]
+          | (Symbol x, Pair(y, z)) -> List.append [x] (lambda_arguments_to_list ((y,z)))
+          | _ -> raise X_syntax_error);;
+
+let rec unnested_pairs = (function (l) -> match l with 
+          | Nil -> [Nil]
+          | Symbol x -> [Symbol x]
+          | Pair(car, cdr) -> List.append [car] (unnested_pairs cdr)
+          | _ -> raise X_syntax_error);;
+
+let rec lambdaOpt_after_dot = (function (arg) -> match arg with
+          | (Symbol x, Symbol y) -> y
+          | (Symbol x, Pair(y, z)) -> lambdaOpt_after_dot ((y,z))
+          | _ -> raise X_syntax_error);;
+
+let rec lambda_body_to_list = (function (body) -> match body with
+          | (a, Nil) -> [a]
+          | (a, Pair(b, c)) -> List.append [a] (lambda_body_to_list ((b,c)))
+          | _ -> raise X_syntax_error);;
+
+let rec last_element = (function (l) -> match l with
+          | [] -> raise X_syntax_error
+          | [a] -> a
+          | car::cdr -> last_element(cdr));;
+
+let rec but_last = (function (l) -> match l with
+        | [] -> []
+        | [a] -> []
+        | car::cdr -> (List.append [car] (but_last cdr)));;
+
+let rec pair_append = (function (l) -> match l with
+          | (Pair(a,Nil), p) -> Pair(a, p)
+          | (Pair(a,b), p)-> Pair(a, (pair_append (b, p)))
+          | _ -> raise X_in_append);;
+
+
+let rec motherShip = (function (l) -> match l with
+              | Bool(x) -> Const(Sexpr (Bool(x)))
+              | Char(x) -> Const(Sexpr (Char(x)))
+              | Number(x) -> Const(Sexpr (Number(x)))
+              | String(x) -> Const(Sexpr (String(x)))
+              | Nil -> Const(Void)
+              | Pair ((Symbol "quote"), Pair(x, Nil)) -> Const(Sexpr (x))
+              | Pair ((Symbol "if"), Pair(x, Pair (y, Pair(z, Nil)))) -> If ((motherShip x), (motherShip y), (motherShip z))
+              | Pair ((Symbol "if"), Pair(x, Pair (y, Nil))) -> If ((motherShip x), (motherShip y), Const(Void))
+              | Pair (Symbol "lambda", Pair (Nil, Pair (a, b))) -> LambdaSimple([], (lambda_body_maker (lambda_body_to_list ((a,b)))))
+              | Pair (Symbol "lambda", Pair (Pair (x, y), Pair (a, b))) -> (simple_or_opt (lambda_arguments_to_list ((x, y)), (a,b), (x,y)))
+              | Pair (Symbol "lambda", Pair ((Symbol x), Pair (a, b))) -> LambdaOpt([], x, (lambda_body_maker (lambda_body_to_list ((a,b)))))
+              |Pair(Symbol "define",Pair(Pair(vari,arglist),bodies))-> (motherShip(Pair(Symbol "define", Pair (vari,Pair(Pair (Symbol "lambda",Pair(arglist,bodies)),Nil)))))           
+              |Pair(Symbol("define"),Pair(x,Pair(y,Nil)))-> Def(motherShip(x),motherShip(y))
+              |Pair(Symbol("or"),Nil) -> Const (Sexpr (Bool false)) 
+              |Pair(Symbol("or"),Pair(y,Nil))-> motherShip(y)
+              |Pair(Symbol("or"),y) -> Or(getListFromPairs(y))
+              |Pair(Symbol("set!"),Pair(x,Pair(y,Nil)))-> Set(motherShip(x),motherShip(y))
+              |Pair(Symbol("begin"),Nil)-> Const(Void)
+              |Pair(Symbol("begin"),Pair(x,Nil)) when (not(x= Symbol("begin"))) ->motherShip(x)
+              |Pair(Symbol("begin"),y) -> Seq(forBegin_getListFromPairs(y))
+              | Pair (Symbol "and", Nil) -> motherShip (Bool(true))
+              | Pair (Symbol "and", Pair (x, Nil)) -> (motherShip x)
+              | Pair (Symbol "and", Pair (x, y)) -> motherShip (Pair (Symbol "if", Pair (x, Pair (Pair (Symbol "and", y), Pair (Bool(false), Nil)))))
+              | Pair (Symbol "cond", Pair (Pair (xpr, rest), rib)) -> motherShip (cond_handler (Pair (Pair (xpr, rest), rib)))
+              | Pair ((Symbol "quasiquote"), Pair(x, Nil)) -> (motherShip (quasiquote_handler x))
+              |Pair (Symbol "let",Pair(Nil,y)) ->  (motherShip(Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(Nil)),y)),listToPairList(tesValues(Nil)) ) ))  
+              |Pair (Symbol "let",Pair(x,y)) ->(motherShip(Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(x)),y)),listToPairList(tesValues(x)) ) ))
+              (* |Pair (Symbol "letrec",Pair(x,y)) ->(motherShip(createLetExpr( (getWhatEverBindings(tesargs(x),tesargs(x),tesValues(x)))   ,  (myAddSetwithBangBodies(tesargs(x),tesValues(x),y))    )))   *)
+              |Pair (Symbol "letrec",Pair(x,y)) ->(motherShip(createLetExpr2( (getWhatEverBindings(tesargs(x),tesargs(x),tesValues(x)))   ,  (myAddSetwithBangBodies(tesargs(x),tesValues(x),y))    )))  
+
+              |(*empty args for let*)Pair (Symbol "let*",Pair(Nil,y)) -> (motherShip(Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(Nil)),y)),listToPairList(tesValues(Nil)) )))   
+              (*|one arg for let**)|Pair (Symbol "let*",Pair(Pair(Pair(x,Pair(y,Nil)),Nil),z)) -> (motherShip(Pair (Symbol "let",Pair(Pair(Pair(x,Pair(y,Nil)),Nil),z)))) 
+              |(*the recursion condition*)Pair (Symbol "let*",Pair(x,y)) -> (motherShip(createLetExpr(getListWithFirstBindingOnly(x),(*args*)        (testLetstar( Pair (Symbol "let*",Pair(getListWithTheRestOfTheBindings(x),y))))            ) (*body*)))
+              |Pair (Symbol "pset!",x)   -> (motherShip (buildPset(l)) )
+              |Pair(x,y)-> Applic(motherShip(x),getListFromPairs(y))
+              |Symbol(x) -> (  Var(x) )
+              )
+
+
+(*------------------------Pset! functions-----------------------------------*)
+and myPSet = (fun (l) -> match l with 
+|Pair (Symbol "pset!",x)   ->  buildPset(l)
+|_->Nil
+)
+
+and tryCatchPset = (fun (l) -> match l with 
+|Pair (Symbol "pset!",x)   ->  x
+|_->Nil
+)
+
+and buildPset = (fun(l)->
+  (lettester(
+    createLetExpr(
+      getBindingsForLet(
+        symbolListToTempVraibles(getPsetListOfSymbols(tryCatchPset(l))),
+        getPsetListOfValues(tryCatchPset(l))    ),
+      pSetwithBangBodies(
+        getPsetListOfSymbols((tryCatchPset(l))),
+        symbolListToTempVraibles(getPsetListOfSymbols(  (tryCatchPset(l))))  ) )
+  ))
+
+  )
+
+
+
+and getPsetListOfValues = (fun(l)-> match l with
+|Pair(Pair(x,Pair(y,q)),z) -> ((List.append ([(y)]) (getPsetListOfValues(z))  ))
+|Pair(Pair(x,y),Nil) -> ([y])
+|_->[]
+)
+
+and getPsetListOfSymbols = (fun(l)-> match l with
+|Pair(Pair(x,Pair(y,q)),Nil) -> ([x])
+|Pair(Pair(x,Pair(y,q)),z) -> ((List.append ([(x)]) (getPsetListOfSymbols(z))  ))
+|_->[]
+)
+
+
+
+(*---------------naming------------------*)
+and symbolListToTempVraibles = (fun(l)->
+   
+  createTempVars((symbolListToLongestString(l)),1, (List.length (l) )  ) 
   
-end;; (* struct Tag_Parser *)
+  )
+
+and  createTempVars = (fun(longString,num,lengthOfList)->match lengthOfList with
+  |0 ->[]
+  |_ -> List.append [  
+        Symbol(String.concat "" [longString;(string_of_int num)]  )  ] 
+      (createTempVars(longString,(num+1),(lengthOfList-1)   ) )
+  ) 
+ 
+and symbolListToLongestString = (fun(l)->
+  findlongestString( getStringListFromSymbolList(l)  )  
+
+)
+and getStringListFromSymbolList = (fun(l)-> match l with 
+  |Symbol(a)::b -> (List.append ([a]) (getStringListFromSymbolList(b)))
+  |a::b-> (List.append (["1"]) (getStringListFromSymbolList(b)))
+  |_->["x1";"x2";"x3"]
+  )
+
+and findlongestString = (fun(l)->
+  wrapedfindlongestString(l,"1")
+  )
+  
+  and wrapedfindlongestString = (fun(l,longestString)-> match l with 
+  | a::b when ((String.length  a )<  (String.length longestString) ) -> wrapedfindlongestString(b,longestString)
+  | a::b when ((String.length  a)>=   (String.length longestString) ) -> wrapedfindlongestString(b,a)
+  |[]->longestString
+  |_-> "1"
+  )
+
+  and getBindingsForLet = ( fun(tempArgsList,valueList)->( match tempArgsList with
+  |[]->Nil
+  |a::b-> 
+    begin
+    match valueList with 
+    |x::y ->   Pair(Pair(a,Pair(x,Nil)),
+    getBindingsForLet(b,y))
+    |_->Nil
+    end
+  ) ) 
+
+  and pSetwithBangBodies = (fun(completeArgsList,completeValueList)->(match completeArgsList with
+  |[]->   Nil 
+  |a::b-> begin
+          match completeValueList with 
+        |x::y ->     Pair(Pair(Symbol "set!",Pair(a,Pair(x,Nil))),pSetwithBangBodies(b,y))
+        |_->raise X_syntax_error
+        end
+  )) 
+(*---------pset functions-----------------*)
+
 
+and lettester = fun(l) -> match l with
+|Pair (Symbol "let",Pair(Nil,y)) ->  ((Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(Nil)),y)),listToPairList(tesValues(Nil)) ) ))  
+|Pair (Symbol "let",Pair(x,y)) ->((Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(x)),y)),listToPairList(tesValues(x)) ) ))
+|_->l
+              
+
+and getListWithFirstBindingOnly = (fun(l)->(match l with
+|Pair(x,y)->Pair(x,Nil)
+|_->raise X_syntax_error))
+
+and getListWithTheRestOfTheBindings=(fun(l)->match l with
+|Pair(x,y)->y
+|_->raise X_syntax_error)
+
+and  createLetExpr2 = (fun(bindingsList,body)->
+  Pair (Symbol "let",
+   Pair(bindingsList, body  )    )      )
+
+and  createLetExpr = (fun(bindingsList,body)->
+    Pair (Symbol "let",
+  Pair(bindingsList,(Pair(body,Nil)) )))
+
+and testLetstar = (fun(l)-> (match l with
+  |(*empty args for let*)
+  Pair (Symbol "let*",
+   Pair(Nil,y)) 
+   ->
+    Pair
+   (Pair (Symbol "lambda",
+     Pair (listToPairList(tesargs(Nil)),y)),listToPairList(tesValues(Nil)) ) 
+  (*one arg for let**)
+     |  Pair (Symbol "let*",Pair(Pair(Pair(x,Pair(y,Nil)),Nil),z)) -> 
+      (Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(Pair(Pair(x,Pair(y,Nil)),Nil))),z)),listToPairList(tesValues(Pair(Pair(x,Pair(y,Nil)),Nil))) ) )
+  
+     (*the recursion condition*)   
+      
+
+   |Pair (Symbol "let*",Pair(x,y)) -> 
+      (Pair(Pair (Symbol "lambda",Pair (listToPairList(tesargs(getListWithFirstBindingOnly(x))),
+      Pair(  (testLetstar( Pair (Symbol "let*",Pair(getListWithTheRestOfTheBindings(x), y   )  ))) ,Nil)
+    )),listToPairList(tesValues(getListWithFirstBindingOnly(x))) ) ) 
+
+  |_->Symbol "sorry man"
+  ))  
+
+  and getWhatEverBindings = ( fun(modofiedArgsList,completeArgsList,completeValueList)->( match modofiedArgsList with
+ |[]->Nil
+ (* |a::[]-> *)
+ (* |a::b-> Pair(Pair(a,Pair(Symbol "whatever",Nil)), *)
+ |a::b-> Pair(Pair(a,Pair(     Pair(Symbol"quote",Pair(Symbol "whatever",Nil)),Nil   )),
+ getWhatEverBindings(b,
+ completeArgsList,
+ completeValueList))
+ ) )
+
+ (* and getWhatEverBindings = ( fun(modofiedArgsList,completeArgsList,completeValueList)->( match modofiedArgsList with
+ |[]->Nil
+ |a::b-> Pair(Pair(a,Pair(
+  Pair(Symbol"quote",Pair(Symbol "whatever",Nil))
+ ,Nil)),
+ getWhatEverBindings(b,
+ completeArgsList,
+ completeValueList))
+ ) ) *)
+
+
+and getWhatEverBindings_andSetBangBindings = ( fun(modofiedArgsList,completeArgsList,completeValueList)->( match modofiedArgsList with
+|[]->addSetBangBindings(completeArgsList,completeValueList)
+|a::b-> Pair(Pair(a,Pair(Symbol "whatever",Nil)),
+getWhatEverBindings_andSetBangBindings(b,
+completeArgsList,
+completeValueList))
+) )
+and myAddSetwithBangBodies = (fun(completeArgsList,completeValueList,originalBodies)->(match completeArgsList with
+|[]->   Pair(lettester(createLetExpr2(Nil,originalBodies)),Nil)   
+|a::b-> begin
+        match completeValueList with 
+      |x::y ->     Pair(Pair(Symbol "set!",Pair(a,Pair(x,Nil))),myAddSetwithBangBodies(b,y,originalBodies))
+      |_->raise X_syntax_error
+      end
+)) 
+(* and myAddSetwithBangBodies = (fun(completeArgsList,completeValueList,originalBodies)->(match completeArgsList with
+|[]->   Pair( lettester(createLetExpr(Nil,originalBodies)) ,Nil)
+|a::b-> begin
+        match completeValueList with 
+      |x::y ->     Pair(Pair(Symbol "set!",Pair(a,Pair(x,Nil))),myAddSetwithBangBodies(b,y,originalBodies))
+      |_->raise X_syntax_error
+      end
+))   *)
+
+
+and addSetBangBindings = (fun(completeArgsList,completeValueList)->(match completeArgsList with
+|[]->Nil
+|a::b-> begin
+        match completeValueList with 
+      |x::y ->     Pair(Pair(a,Pair(x,Nil)),addSetBangBindings(b,y))
+      |_->raise X_syntax_error
+      end
+))              
+
+and tesValues = (fun(l)->match l with
+|Nil->[Nil]
+|Pair(Pair(x,Pair(y,e)),Nil)->[y]
+|Pair(Pair(x,Pair(y,e)),z)-> List.append ([y]) (tesValues(z))
+|_->raise X_syntax_error
+)
+
+(*gets list that looks loke this -Pair(Pair(x,y),z) *)
+(*returns the list like this [Sexpr x; Sexpr y ; ..]*)
+and tesargs = (fun(l)->match l with
+|Nil->[Nil]
+|Pair(Pair(x,y),Nil)->[x]
+|Pair(Pair(x,y),z)-> List.append ([x]) (tesargs(z))
+|_->raise X_syntax_error
+ )
+
+and listToPairList = (fun(l)-> match l with
+ |[Nil]->Nil
+ |a::[]->Pair(a,Nil)
+ |a::b->Pair(a,listToPairList(b))
+ |_->raise X_syntax_error
+ )              
+
+and listWithoutBeggining = (fun(p)-> match p with
+|[]->[]
+|[Var "begin"]->[]
+|[Seq(x)] -> listWithoutBeggining(x)
+|[a]->[a]
+|Var("begin")::b ->listWithoutBeggining(b)
+|Seq(x)::b ->  List.append (listWithoutBeggining(x)) (listWithoutBeggining(b))  
+|a::b -> List.append ([a]) (listWithoutBeggining(b)))
+(* |_->[]) *)
+
+and forBegin_getListFromPairs = (fun(u)->
+    let resultList = getListFromPairs(u) in
+    listWithoutBeggining(resultList)
+    )
+
+and getListFromPairs = (fun(u)->
+  match u with
+|Nil -> []
+|Pair(x,y) -> (List.append [(motherShip(x))]  (getListFromPairs(y)) )
+| a -> [motherShip a] 
+)
+
+and simple_or_opt = (function (l, (a,b), (x,y)) -> match (last_element (unnested_pairs (Pair(x,y)))) with
+      | Nil -> LambdaSimple(l, (lambda_body_maker (lambda_body_to_list ((a,b)))))
+      | _  -> LambdaOpt(l, (lambdaOpt_after_dot ((x,y))), (lambda_body_maker (lambda_body_to_list ((a,b))))))
+
+and lambda_body_maker = (function (body) -> match body with
+      | [a] -> (motherShip a)
+      | car::cdr -> Seq (listWithoutBeggining (List.map (motherShip) body))
+      | _-> raise X_syntax_error)
+
+
+and cond_handler = (function (c) -> match c with
+      | Nil -> Nil
+      | Pair (Pair (xpr, Pair (Symbol "=>", rest)), Nil) -> Pair (Symbol "let",
+            Pair
+            (Pair
+              (Pair (Symbol "value",
+                Pair (xpr, Nil)),
+              Pair
+                (Pair (Symbol "f",
+                  Pair
+                  (Pair
+                    (Symbol "lambda",
+                    Pair (Nil, rest)),
+                  Nil)),
+                Nil)),
+            Pair
+              (Pair (Symbol "if",
+                Pair (Symbol "value",
+                Pair
+                  (Pair
+                    (Pair (Symbol "f",
+                      Nil),
+                    Pair (Symbol "value",
+                    Nil)),
+                  Nil))),
+              Nil)))
+      | Pair (Pair (xpr, Pair (Symbol "=>", rest)), rib) -> Pair (Symbol "let",
+            Pair
+            (Pair
+              (Pair (Symbol "value",
+                Pair (xpr, Nil)),
+              Pair
+                (Pair (Symbol "f",
+                  Pair
+                  (Pair
+                    (Symbol "lambda",
+                    Pair (Nil, rest)),
+                  Nil)),
+                Pair
+                (Pair (Symbol "rest",
+                  Pair
+                    (Pair
+                      (Symbol "lambda",
+                      Pair (Nil, (cond_handler rib))),
+                    Nil)),
+                Nil))),
+            Pair
+              (Pair (Symbol "if",
+                Pair (Symbol "value",
+                Pair
+                  (Pair
+                    (Pair (Symbol "f",
+                      Nil),
+                    Pair (Symbol "value",
+                    Nil)),
+                  Pair
+                  (Pair (Symbol "rest",
+                    Nil),
+                  Nil)))),
+              Nil)))
+      | Pair (Pair (Symbol "else", rest), garbage) -> Pair (Symbol "begin", rest)
+      | Pair (Pair (xpr, rest), Nil) -> Pair (Symbol "if",
+            Pair (xpr,
+            Pair
+              (Pair (Symbol "begin", rest), Nil)))
+      | Pair (Pair (xpr, rest), rib) -> Pair (Symbol "if",
+            Pair (xpr,
+            Pair
+              (Pair (Symbol "begin", rest), Pair ((cond_handler rib), Nil))))
+      |_->raise Y_3
+      )
+
+
+and quasiquote_handler = (function (q) -> match q with
+      | Pair (Symbol "unquote", Pair (x, Nil)) -> (x)
+      | Pair (Symbol "unquote-splicing", Pair (x, Nil)) -> raise X_Illegal_use_of_unquote_splicing
+      | Symbol x -> (Pair ((Symbol "quote"), Pair(Symbol x, Nil)))
+      | Nil -> (Pair ((Symbol "quote"), Pair(Nil, Nil)))
+      | Pair (Pair (Symbol "unquote-splicing", Pair (x, Nil)), y) -> Pair (Symbol "append", Pair (x, Pair (quasiquote_handler y, Nil)))
+      | Pair (x, Pair (Symbol "unquote-splicing", Pair (y, Nil))) -> (Pair (Symbol "List", Pair(x, Pair ( Pair (Symbol "quote", Pair (Symbol "quasiquote", Nil)), Pair (Pair (Symbol "quote", Pair (y, Nil)), Nil)))))  
+      (* (pair_append (quasiquote_handler x, quasiquote_handler y)) *)
+      | Pair (x, y) -> Pair (Symbol "cons", Pair (quasiquote_handler x, Pair (quasiquote_handler y, Nil)))
+      |_->raise X_syntax_error
+      ) ;;
+
+(*_____________________________________________________*)
+
+
+
+
+
+
+
+let tag_parse_expressions sexpr = List.map motherShip  sexpr;;  
+end;; (* struct Tag_Parser *)
+(*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1*)
+(* importantfunc(read_sexprs("((lambda (x y) (+ x 3)(+ x 4 ) )10 11)"));;
+Pair
+(Pair (Symbol "lambda",
+Pair (hereGoesTheListOfArgs,
+heregoes the list of bodies),
+here goes the list of values) *)
