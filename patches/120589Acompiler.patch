diff --git a/reader.ml b/reader.ml
index 32445c2..4b8226d 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,5 @@
-
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -31,6 +31,85 @@ let rec sexpr_eq s1 s2 =
 
 module Reader: sig
   val read_sexprs : string -> sexpr list
+
+  val hash : char list -> char * char list
+  val semicolon : char list -> char * char list
+  val hash_semicolon : char list -> (char * char) * char list
+  val dot : char list -> char * char list
+  val slash : char list -> char * char list
+  val nt_whitespaces : char list -> char list * char list
+  val make_paired : ('a -> 'b * 'c) -> ('d -> 'e * 'f) -> ('c -> 'g * 'd) -> 'a -> 'g * 'f
+  val nt_line_comments : char list -> char list * char list
+  val make_spaced : (char list -> 'a * char list) -> char list -> 'a * char list
+
+
+  val boolOrBackSlash : char -> sexpr
+  val nt_boolean : char list -> sexpr * char list
+  val digit : char list -> char * char list
+
+  val nt_e : char list -> char * char list
+  val natural : char list -> char list * char list
+  val lowerCase : char list -> char * char list 
+  val upperCase : char list -> char * char list 
+  val nt_SymbolCharNoDot : char list -> char * char list 
+  val nt_SymbolChar : char list -> char * char list 
+
+  val nt_Symbol : char list -> sexpr * char list 
+
+
+  val sign : char list -> char * char list
+
+  val gen_integer : char option * char list -> string
+  val nt_integer : char list -> string * char list
+
+  val nt_e_exponent : char list -> (char * string) option * char list
+
+  val gen_float : string * ('a * (char list * ('b * string) option)) -> sexpr 
+  val nt_float : char list -> sexpr * char list
+
+  val gen_fraction : string * (char * char list) -> sexpr 
+  val nt_fraction : char list -> sexpr * char list
+
+  val gen_integer_or_float_undotted : string * ('a * string) option -> sexpr
+
+  val nt_int_integer : char list -> sexpr * char list
+  val nt_number : char list -> sexpr * char list 
+
+
+  val string_meta_char_match : char list -> char * char list
+
+  (* val string_meta_char_match : string -> char  *)
+  val string_meta_char : char list -> char * char list 
+  val stringLiteralChar : char list -> char * char list 
+  val string_char : char list -> char * char list 
+  val string_char_star : char list -> char list * char list 
+  val double_qoute : char list -> char * char list
+  val nt_string : char list -> sexpr * char list 
+
+  val namedChar_match : string -> char 
+  val namedChar : char list -> char * char list 
+  val string_meta_char : char list -> char * char list 
+  val visibleSimpleChar : char list -> char * char list 
+  val prefixed_char : char list -> char list * char list 
+  val nt_char : char list -> sexpr * char list 
+
+
+  val tok_lparen : char list -> char * char list 
+  val tok_rparen : char list -> char * char list 
+
+
+  val nt_sexper_not_pair : char list -> sexpr * char list
+  val nt_pair : char list -> sexpr * char list 
+  val nt_list_proper : char list -> sexpr * char list 
+  val nt_list_improper : char list -> sexpr * char list 
+  val _sexpr : char list -> sexpr * char list 
+  val nt_nil : char list -> sexpr * char list 
+  (* val sexp_comment : char list -> sexpr * char list  *)
+
+  
+
+  val quotes : char list -> sexpr * char list 
+
 end
 = struct
 let normalize_scheme_symbol str =
@@ -41,6 +120,259 @@ let normalize_scheme_symbol str =
   else Printf.sprintf "|%s|" str;;
 
 
-let read_sexprs string = raise X_not_yet_implemented;;
+
+
+let hash = (char '#');;
+let semicolon = (char ';');;
+
+let hash_semicolon = caten hash semicolon;;
+
+let t = (char 't');;
+let f = (char 'f');;
+let sign = disj (char '+') (char '-');;
+let dot = (char '.');;
+
+let slash = (char '/');;
+
+let boolOrBackSlash x  = match x with
+  | 'f'-> Bool(false)
+  | 'F'-> Bool(false)
+  | 't'-> Bool(true)
+  | 'T'-> Bool(true)
+  | _ -> raise X_not_yet_implemented;;
+
+
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+
+  
+let nt_whitespaces = star nt_whitespace;;
+
+let nt_line_comments = (pack (caten semicolon (caten (star (const (fun ch -> (ch != '\010') && (ch != '\004')))) (char '\n')))) (fun (e, (es, a)) -> (e :: es@[a]));;
+
+
+let make_spaced nt =
+  make_paired nt_whitespaces nt_whitespaces nt;;
+
+let spaced_dot = make_spaced dot;;
+
+let nt_boolean = 
+  let bool_token = (caten hash (disj (char_ci 't') (char_ci 'f'))) in 
+  pack bool_token (fun (hash, t_or_f) -> (boolOrBackSlash t_or_f));;
+
+
+
+let digit = range '0' '9';; 
+
+let nt_e = (char_ci 'e');;
+
+
+let natural = plus digit;;
+
+
+let lowerCase = range 'a' 'z';;
+let upperCase = range 'A' 'Z';;
+ 
+let nt_SymbolCharNoDot = disj_list [digit; lowerCase; (pack upperCase lowercase_ascii); make_one_of char "!$^*-_=+<>/?:"];;
+
+let nt_SymbolChar = disj nt_SymbolCharNoDot dot;;
+
+let nt_Symbol = (pack
+                      (disj (pack (caten nt_SymbolChar (plus nt_SymbolChar)) (fun (e, es) -> (e :: es)))
+                            (pack (caten nt_SymbolCharNoDot nt_epsilon) (fun (e, es) -> (e :: es))))
+                      (fun (hd)-> Symbol(list_to_string hd)));;
+
+
+
+
+let gen_integer (l, tl) = match l with
+  | Some('+') ->  (list_to_string tl)
+  | Some('-') ->  (String.concat "" ["-";(list_to_string tl)])
+  | None  ->  (list_to_string tl)
+  | _ -> raise X_no_match;;
+
+
+let nt_integer = pack (caten (maybe sign) natural) gen_integer;; 
+
+let nt_e_exponent = maybe (caten nt_e nt_integer);;
+
+
+let gen_float (hd ,(p ,(tl,exp ))) = match exp with 
+    | Some(_,x) -> Number(Float((10.0 ** (float_of_string(x)) *.
+                        float_of_string (String.concat "" [ hd;".";(list_to_string tl)]))))
+    | None -> Number(Float(float_of_string (String.concat "" [ hd;".";(list_to_string tl)])));;
+
+
+let nt_float = (pack (caten nt_integer (caten dot (caten natural nt_e_exponent))) gen_float) ;;
+
+
+let gen_fraction (l ,(p , tl)) =
+  let numerator = (int_of_string l) in
+  let denominator = (int_of_string (list_to_string tl)) in
+  let rec gcd a b = 
+    if (a == 0)
+      then b
+      else gcd (b mod a) a
+  in
+  let ans = (gcd numerator denominator) in 
+  let ans_without_sign = 
+    if (ans > 0) then ans else ans * (-1) in
+  Number(Fraction(numerator/ ans_without_sign, denominator/ans_without_sign));;
+
+    
+
+let nt_fraction = (pack (caten nt_integer (caten slash natural)) gen_fraction);;
+
+
+let gen_integer_or_float_undotted (hd, tl) = match tl with
+    | Some(_,x) -> Number(Float((10.0 ** (float_of_string(x)) *.  (float_of_string hd ))))
+    | None -> Number(Fraction(int_of_string hd, 1));;
+
+let nt_int_integer = (pack (caten nt_integer nt_e_exponent) gen_integer_or_float_undotted);;
+
+let nt_number = not_followed_by (disj_list [nt_float; nt_fraction; nt_int_integer]) nt_SymbolChar ;;
+
+
+
+let en = pack (word "\\n") (fun n -> '\n');;
+let slesh = pack (word "\\\\") (fun slesh -> '\\');;
+let ti = pack (word "\\t") (fun ti -> '\t');;
+let pi = pack (word "\\p") (fun pi -> '\r');;
+let ar = pack (word "\\r") (fun ar -> '\r');;
+let ef = pack (word "\\f") (fun f -> '\012');;
+
+let regular_string_char = const (fun ch -> ch != '\\' && ch != '\"');;
+
+
+let string_meta_char_match = disj_list [en; slesh; ti; pi; ar ;ef];;
+let string_meta_char =disj regular_string_char string_meta_char_match;;
+
+
+
+let stringLiteralChar = disj_list [(range '\032' '\033'); (range '\035' '\091');(range '\093' '\126')];;
+
+let string_char = disj stringLiteralChar string_meta_char;;
+
+let string_char_star = star string_char;;
+
+let double_qoute = (char_ci '\"');;
+
+let nt_string = (pack  (make_paired double_qoute double_qoute string_char_star)   (fun (hd)-> String(list_to_string hd)));;
+
+
+
+let namedChar_match str = match str with
+  | "nul"       -> '\000'
+  | "newline"   -> '\010'
+  | "return"    -> '\013'
+  | "tab"       -> '\009'
+  | "page"      -> '\012'
+  | "space"     -> '\032'
+  | _           -> raise X_no_match;;
+  
+
+
+
+(* This code parse the ocaml language and not scheme language *)
+let namedChar = (pack (disj_list [word_ci "nul"; word_ci "newline"; word_ci "return"; word_ci "tab"; word_ci "page"; word_ci "space"]) 
+                             (fun (hd)-> (namedChar_match (list_to_string (List.map lowercase_ascii hd)))));;
+
+
+let visibleSimpleChar = range '\032' '\126';;
+
+let prefixed_char = (pack (caten hash (char '\\'))  (fun (one, two) -> (one :: [two]))) ;;
+
+
+let nt_char =  
+    let char_token = (caten prefixed_char (disj namedChar visibleSimpleChar)) in 
+    pack char_token (fun (prefixed, tokenized) -> (Char (tokenized)));;
+
+
+
+let tok_lparen = make_spaced ( char '(');;
+
+let tok_rparen = make_spaced ( char ')');;
+
+(* let nt_nil = (pack (make_paired tok_lparen tok_rparen (disj_list [nt_epsilon; nt_line_comments; nt_whitespaces])) (fun (_)-> Nil ));; *)
+(* comments inside instead of epsilon *)
+(* These may enclose whitespaces and comments *)
+
+
+
+let nt_sexper_not_pair = make_spaced (disj_list [nt_boolean ; nt_number ; nt_string; nt_Symbol; nt_char ]);;
+
+
+  
+
+let rec _sexpr lst= 
   
+  let core_sexp_comment =  pack (caten (word "#;") _sexpr) (fun (a, sexpr)-> [] ) in
+  let spaced_core_sexp_comment = make_spaced core_sexp_comment in
+  let wrapper_new = (disj_list [spaced_core_sexp_comment; (star nt_line_comments); nt_epsilon]) in
+  (* let wrapper_old = (disj (star nt_line_comments) nt_epsilon) in *)
+  let core = (caten wrapper_new
+  (* (caten (disj_list [sexp_comment; nt_pair; nt_sexper_not_pair; nt_list_proper; nt_list_improper ; quotes ; nt_nil]) *)
+  (caten (disj_list [ nt_pair; nt_sexper_not_pair; nt_list_proper; nt_list_improper ; quotes ; nt_nil])
+  wrapper_new)) in 
+              (pack core (fun (lp, (hdtl, rp)) -> hdtl)) lst
+
+and nt_pair lst=
+  let nt_dot = caten tok_lparen (caten _sexpr (caten spaced_dot (caten _sexpr tok_rparen))) in 
+              pack nt_dot (fun (lp, (car, (dot, (cdr, rp)))) -> Pair(car, cdr)) lst
+
+and nt_list_proper lst= 
+  let nt_proper_list = caten tok_lparen (caten (star _sexpr) tok_rparen) in 
+                                (pack nt_proper_list (fun (lp, (hdtl, rp)) -> (List.fold_right (fun e aggr -> Pair(e, aggr)) (hdtl) Nil ))) lst
+
+
+and nt_list_improper lst= 
+let nt_improper_list = caten tok_lparen (caten (plus _sexpr) (caten spaced_dot (caten _sexpr tok_rparen))) in 
+                              (pack nt_improper_list (fun (lp, (hdtl, (dot, (cdr, rp)))) -> 
+                                                    (List.fold_right (fun e aggr -> Pair(e, aggr)) (hdtl) cdr ))) lst
+
+and quotes lst=
+  let quote_match str = match str with
+  | "'"       -> "quote"
+  | "`"   -> "quasiquote"
+  | ",@"       -> "unquote-splicing"
+  | ","       -> "unquote"
+  | _           -> raise X_no_match in
+  (pack (caten (disj_list [(word "'"); (word "`"); (word ",@"); (word ",")]) _sexpr) 
+                            (fun (tok_quote, exper)-> Pair( Symbol((quote_match (list_to_string tok_quote))) , Pair(exper, Nil)))) lst
+
+(* and sexp_comment lst= (pack (caten hash_semicolon (caten _sexpr _sexpr)) (fun ((hash , semi) , (_ , sexprB))-> sexprB)) lst *)
+
+and nt_nil lst=
+                let sexp_comment_nil =  pack (caten (word "#;") _sexpr) (fun (a, sexpr)-> [] ) in
+                (pack (make_paired tok_lparen tok_rparen (disj_list [sexp_comment_nil; nt_line_comments; nt_whitespaces ;nt_epsilon]) ) (fun (_)-> Nil )) lst;;
+
+
+
+
+
+
+
+let read_sexprs string = let (a, b) = (star (make_spaced _sexpr)) (string_to_list string) in a;;
+
+
+
+
+
+ 
 end;; (* struct Reader *)
+open Reader;; 
+
+(* 
+`(1 ;asd\n 2 3 #;#;#;123 2 3)
+
+[Pair (Symbol "quasiquote",Pair(Pair (Number (Fraction (1, 1)), Pair (Number (Fraction (2, 1)), Pair (Number (Fraction (3, 1)), Nil))),Nil))] *)
+
+(* read_sexprs ("(    #;#t    )");; *)
+
+
+ (* Failed cases 57 59 62 72 122 133 *)
diff --git a/readme.txt b/readme.txt
index e69de29..0969450 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,11 @@
+Izhak Moalem      205489230
+Yuval Kashi       206055964
+
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..3f112b8 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -21,65 +21,681 @@ type expr' =
   | Applic' of expr' * (expr' list)
   | ApplicTP' of expr' * (expr' list);;
 
-let rec expr'_eq e1 e2 =
-  match e1, e2 with
-  | Const' Void, Const' Void -> true
-  | Const'(Sexpr s1), Const'(Sexpr s2) -> sexpr_eq s1 s2
-  | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
-  | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
-  | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
-                                            (expr'_eq th1 th2) &&
-                                              (expr'_eq el1 el2)
-  | (Seq'(l1), Seq'(l2)
-  | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
-  | (Set'(var1, val1), Set'(var2, val2)
-  | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq (Var'(var1)) (Var'(var2))) &&
-                                             (expr'_eq val1 val2)
-  | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) ->
-     (List.for_all2 String.equal vars1 vars2) &&
-       (expr'_eq body1 body2)
-  | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) ->
-     (String.equal var1 var2) &&
+  let rec expr'_eq e1 e2 =
+    match e1, e2 with
+    | Const' Void, Const' Void -> true
+    | Const'(Sexpr s1), Const'(Sexpr s2) -> sexpr_eq s1 s2
+    | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
+    | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+    | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+    | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
+    | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+    | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+    | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
+    | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
+    | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
+    | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
+    | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
+    | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
+    | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
+                                              (expr'_eq th1 th2) &&
+                                                (expr'_eq el1 el2)
+    | (Seq'(l1), Seq'(l2)
+    | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
+    | (Set'(var1, val1), Set'(var2, val2)
+    | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq (Var'(var1)) (Var'(var2))) &&
+                                               (expr'_eq val1 val2)
+    | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) ->
        (List.for_all2 String.equal vars1 vars2) &&
          (expr'_eq body1 body2)
-  | Applic'(e1, args1), Applic'(e2, args2)
-  | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
-	 (expr'_eq e1 e2) &&
-	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+    | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) ->
+       (String.equal var1 var2) &&
+         (List.for_all2 String.equal vars1 vars2) &&
+           (expr'_eq body1 body2)
+    | Applic'(e1, args1), Applic'(e2, args2)
+    | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
+     (expr'_eq e1 e2) &&
+       (List.for_all2 expr'_eq args1 args2)
+    | _ -> false;;
+	
+                       
 exception X_syntax_error;;
+exception X_entering_lambda;;
+exception X_search_var;;
+exception X_annotate_lexical_addresses;;
+exception X_box_make_the_change_with_box_set_get;;
+exception X_box_stuffing_lists;;
+exception X_stuffing_lists_stuffing_lists;;
+exception X_box_rib_stuffing;;
+exception X_;;
+exception X_map_stuffing_lists;;
+
 
 module type SEMANTICS = sig
+  
+  val entering_lambda : var list -> var list 
+  val param_list_to_var_params : string list -> var list 
+  val search_var : var list * string -> var
+  val list_last_element : 'a list -> 'a
+  val list_without_last : 'a list -> 'a list
+  val extract_from_3d_array : 'a list list list -> int -> 'a list -> 'a list 
+  val box_stuffing_lists : expr' -> string -> expr' list list
+  val extract_ribs_3d_array : 'a list list -> 'a list -> 'a list 
+  val box_rib_stuffing : expr' -> string -> string list ref list list 
+  val does_param_has_different_ribs : 'a list list -> bool
+  val box_make_the_change_with_box_set_get : bool -> expr' -> string -> expr'
+
+  
+  val run_semantics_first : expr -> expr'
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
   val annotate_tail_calls : expr' -> expr'
   val box_set : expr' -> expr'
+
+
+
+
 end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+(* let rec index_of lst index exp = match exp with
+  | (List.hd lst) -> index
+  | _ -> index_of (List.tl lst) (index + 1) exp *)
+
+
+  
+(* entering lambda changes all the var_params to var_bounds and make +1 to the envs *)
+
+let entering_lambda lst = 
+  let add_one_to_majors_env var = match var with
+  | VarParam(var_name,minor) -> VarBound(var_name,0,minor)
+  | VarBound(var_name,major,minor) ->VarBound(var_name,major + 1,minor)
+  | _ -> raise X_entering_lambda
+  in
+    List.map add_one_to_majors_env lst;;
+
+
+(* from string_name list to var_params *)
+let param_list_to_var_params param_list = 
+  let rec param_list_to_var_params_rec param_list index var_Params  =
+  if(List.length param_list == 0) 
+  then var_Params
+  else param_list_to_var_params_rec (List.tl param_list) (index + 1) var_Params@[VarParam((List.hd param_list), index)]
+  in
+  param_list_to_var_params_rec param_list 0 [];;
+
+  
+(* for every var we create the correct var type based on the env *)
+  let search_var (lst, str_name) = 
+  
+    let rec find_var lst = match (List.hd lst) with
+      | VarParam(name,minor) -> if (String.equal str_name name) then VarParam(str_name,minor) else (check_empty_list (List.tl lst))
+      | VarBound(name,major,minor) ->if (String.equal str_name name) then VarBound(str_name,major,minor) else (check_empty_list (List.tl lst))
+      | _ -> raise X_search_var
+
+    and check_empty_list lst = match lst with
+      | [] -> VarFree(str_name)
+      | _ -> find_var lst
+    in
+    check_empty_list (List.rev lst);;
+
+
+  
+
+
+
+
+let annotate_lexical_addresses expr =
+  let rec recursive_lexical lst expr = match expr with
+    | Const(x) -> Const'(x)
+    | Var(x) -> Var'(search_var (lst, x))
+    | If(test_expr, then_expr, else_expr)  -> If'(recursive_lexical lst test_expr, recursive_lexical lst then_expr, recursive_lexical lst else_expr)
+    | Seq(seq_lst) -> Seq'(List.map (recursive_lexical lst) seq_lst)
+    | Set(Var(x),bval) -> Set'((search_var (lst, x)), (recursive_lexical lst bval))
+    | Def(Var(x),bval) -> Def'((search_var (lst, x)), (recursive_lexical lst bval))
+    | Or(or_lst) -> Or'(List.map (recursive_lexical lst) or_lst)
+    | LambdaSimple(param_list, body_exp ) -> LambdaSimple'(param_list,
+                                                          (recursive_lexical ((entering_lambda lst)@(param_list_to_var_params param_list)) body_exp))
+    | LambdaOpt(param_list, var_variadic ,body_exp ) -> 
+                                            let param_strings =  param_list@[var_variadic] in
+                                            let param_vars = param_list_to_var_params param_strings in
+                                            LambdaOpt'(param_list, var_variadic, (recursive_lexical ((entering_lambda lst)@param_vars) body_exp))
+    | Applic(expr, expr_list) -> Applic'(recursive_lexical lst expr , List.map (recursive_lexical lst) expr_list )
+    | _ -> raise X_annotate_lexical_addresses
+    in
+    recursive_lexical [] expr;;
+
+(* 
+    Annotate (expr , tp? ) :
+    If expr is Var or Const , return expr .
+    El seif expr is Applic ,
+    If tp? is true , return TC−Applic ( Annotate ( children , #f ) )
+    Else return Applic ( Annotate ( children , #f ) )
+    Else return expr with its children annotated according to the various rules
+ *)
+
+let annotate_tail_calls expr_tag = raise X_not_yet_implemented;;
+
+let list_last_element lst = 
+    let rev = (List.rev lst) in
+    let last = List.hd rev in
+    last;;
+
+let list_without_last lst = 
+    let rev = (List.rev lst) in
+    let without_last = (List.rev (List.tl rev)) in
+    without_last;;
+
+let annotate_tail_calls expr_tag = 
+  let rec annotate expr tp = match expr with
+  | Const'(x) -> Const'(x)
+  | Var'(x) -> Var'(x)
+  | If'(test_expr, then_expr, else_expr) -> If'((annotate test_expr false), (annotate then_expr tp), (annotate else_expr tp))
+  | Or'(or_lst) ->
+          let last = list_last_element or_lst in
+          let without_last = list_without_last or_lst in
+          let annotate_last = annotate last tp in
+          let annotate_map expr = (annotate expr false) in
+          let annotate_without_last = (List.map annotate_map without_last) in
+              Or'(annotate_without_last@[annotate_last])
+  | Def'(x,bval) -> Def'(x, (annotate bval false))
+  
+  | Seq'(seq_lst) -> 
+          let last = list_last_element seq_lst in
+          let without_last = list_without_last seq_lst in
+          let annotate_last = annotate last tp in
+          let annotate_map expr = (annotate expr false) in
+          let annotate_without_last = (List.map annotate_map without_last) in
+              Seq'(annotate_without_last@[annotate_last])
+  
+  | Set'(x,bval) -> Set'(x, (annotate bval false))
+  | LambdaSimple'(param_list, body_exp ) -> LambdaSimple'(param_list,(annotate body_exp true))
+  | LambdaOpt'(param_list, var_variadic ,body_exp ) -> LambdaOpt'(param_list, var_variadic,(annotate body_exp true))
+  
+  | Applic'(expr, expr_list) -> 
+          let annotate_foo expr = (annotate expr false) in
+          let annotate_proc = annotate_foo expr in
+          let annotate_map = (List.map annotate_foo expr_list) in
+                                if (tp == false)
+                                then Applic'(annotate_proc, annotate_map)
+                                else ApplicTP'(annotate_proc, annotate_map)
+  | _ -> raise X_annotate_lexical_addresses in
+  (annotate expr_tag false);;
+
+
+
+
+
+
+(* box_set_box_get *)
+(* list.exist var in shouldbeboxed *)
+let box_make_the_change_with_box_set_get boolean expr var_name = 
+  if(boolean)
+  then
+    let rec boxit expr var_name depth = match expr with
+      | Const'(s1)-> Const'(s1)
+      | Var'(VarFree v1)-> Var'(VarFree v1)
+      | Var'(VarParam (v1,mn1))-> 
+                                  if((String.equal v1 var_name) && (depth == (-1)))
+                                  then BoxGet'(VarParam (v1,mn1))
+                                  else Var'(VarParam (v1,mn1))
+      | Var'(VarBound (v1,mj1,mn1))-> 
+                                  if((String.equal v1 var_name) && (depth == mj1))
+                                  then BoxGet'(VarBound (v1,mj1,mn1))
+                                  else Var'(VarBound (v1,mj1,mn1))
+      | If'(t1, th1, el1)-> If'(boxit t1 var_name depth, boxit th1 var_name depth, boxit el1 var_name depth)
+      | Seq'(l1)->
+                              let func expr = boxit expr var_name depth in 
+                              let seq_body =  List.map func l1 in
+                              Seq'(seq_body)
+      | Or'(l1)->
+                              let func expr = boxit expr var_name depth in 
+                              let or_body =  List.map func l1 in
+                              Or'(or_body)
+      | Def'(var1, val1)->
+                              Def'(var1, boxit val1 var_name depth)
+      | Set'(x,bval) ->       let var_type x = match x with
+                              | VarParam (v1,mn1) ->
+                                                              if ((String.equal v1 var_name) && (depth == (-1)))
+                                                              then BoxSet'(x, boxit bval var_name depth)
+                                                              else Set'(x, boxit bval var_name depth)
+                              | VarBound (v1,mj1,mn1)-> 
+                                                              if((String.equal v1 var_name) && (depth == mj1))
+                                                              then BoxSet'(x, boxit bval var_name depth)
+                                                              else Set'(x, boxit bval var_name depth)
+                              | VarFree (v1) ->               Set'(x, boxit bval var_name depth)
+                              (* | _ -> raise X_box_make_the_change_with_box_set_get *)
+                              in
+                              var_type x
+
+      | LambdaSimple'(vars1, body1)->
+                              LambdaSimple'(vars1,boxit body1 var_name (depth+1))
+                              
+
+      | LambdaOpt'(vars1, var1, body1)->
+                              LambdaOpt'(vars1, var1, boxit body1 var_name (depth+1))
+      | Applic'(e1, args1)->
+                              let func expr = boxit expr var_name depth in
+                              let applic_body =  List.map func args1 in
+                              Applic'((boxit e1 var_name depth), applic_body)
+      | ApplicTP'(e1, args1)->
+                              let func expr = boxit expr var_name depth in
+                              let applic_body =  List.map func args1 in
+                              ApplicTP'((boxit e1 var_name depth), applic_body)
+      | x -> x
+      (* | _ -> raise X_box_make_the_change_with_box_set_get *)
+      in
+      boxit expr var_name (-1)
+    else
+      expr;;
+
+
+
+
+
+(* val extract_from_3d_array : 'a list list list -> int -> 'a list -> 'a list =      <fun>  *)
+(* [ [[];[]] ; [[];[]]     ] *)
+(* please put 3D arr and index 0 -read or 1 -write ans [] for first result *)
+let extract_from_3d_array arr index result = 
+  let is_read_write = if (index == 0) then true else false in
+  let rec extraction arr index result = match arr with
+  | []  -> result
+  | _ -> extraction (List.tl arr) index result@(if (is_read_write) then (List.hd (List.hd arr)) else (List.hd (List.tl (List.hd arr))))
+  in extraction arr index result;;
+
+
+
+
+  (* we check by the depth and the var_name so we take only the interesting vars that we need *)
+let box_stuffing_lists expr var_name =
+let rec stuffing_lists expr var_name depth lists  = match expr, lists with
+  | Const'(s1), [list_var_read;list_var_write] -> [list_var_read;list_var_write]
+  | Var'(VarFree v1), [list_var_read;list_var_write] -> [list_var_read;list_var_write]
+  | Var'(VarParam (v1,mn1)), [list_var_read;list_var_write]->
+                              if ((String.equal v1 var_name) && (depth == (-1)))
+                              then [list_var_read@ [Var'(VarParam (v1,mn1))] ;list_var_write]
+                              else [list_var_read;list_var_write]
+
+  | Var'(VarBound (v1,mj1,mn1)), [list_var_read;list_var_write]-> 
+                              if((String.equal v1 var_name) && (depth == mj1))
+                              then [list_var_read@[Var'(VarBound (v1,mj1,mn1))]; list_var_write]
+                              else [list_var_read;list_var_write]
+  
+  | Set'(x,bval) ,[list_var_read;list_var_write]->
+
+                    let var_type x = match x with
+                    | VarParam (v1,mn1) ->
+                                                    if ((String.equal v1 var_name) && (depth == (-1)))
+                                                    then stuffing_lists bval var_name depth [list_var_read ;list_var_write @[Var'(VarParam (v1,mn1))]]
+                                                    else stuffing_lists bval var_name depth [list_var_read;list_var_write]
+                    | VarBound (v1,mj1,mn1)-> 
+                                                    if((String.equal v1 var_name) && (depth == mj1))
+                                                    then stuffing_lists bval var_name depth [list_var_read; list_var_write @[Var'(VarBound (v1,mj1,mn1))]]
+                                                    else stuffing_lists bval var_name depth [list_var_read;list_var_write]
+
+                    | VarFree (v1) ->               stuffing_lists bval var_name depth [list_var_read;list_var_write]
+                    (* | _ -> raise X_stuffing_lists_stuffing_lists *)
+                    in
+                    var_type x
+
+  | If'(test_exp, then_exp, else_exp), [list_var_read;list_var_write]-> 
+                                            let if_lst = [test_exp; then_exp; else_exp] in
+                                            map_stuffing_lists if_lst var_name depth [list_var_read;list_var_write]
+
+                                            (* let test_exp = stuffing_lists test_exp var_name depth [[];[]] in
+                                             let then_exp = stuffing_lists then_exp var_name depth [[];[]] in
+                                             let else_exp = stuffing_lists else_exp var_name depth [[];[]] in
+                                             let make_3d_array = [test_exp; then_exp; else_exp] in
+                                             let more_var_read = extract_from_3d_array make_3d_array 0 [] in
+                                             let more_var_write = extract_from_3d_array make_3d_array 1 [] in
+                                             [list_var_read@more_var_read ;list_var_write@more_var_write] *)
+  | Seq'(seq_lst), [list_var_read;list_var_write]->
+                    map_stuffing_lists seq_lst var_name depth [list_var_read;list_var_write]
+                    (* let current_run exp = stuffing_lists exp var_name depth [[];[]] in
+                    let map_seq_of_results = List.map current_run seq_lst in
+                    let more_var_read = extract_from_3d_array map_seq_of_results 0 [] in
+                    let more_var_write = extract_from_3d_array map_seq_of_results 1 [] in
+                    [list_var_read@more_var_read ;list_var_write@more_var_write] *)
+                    
+  | Or'(or_lst), [list_var_read;list_var_write]->
+                    map_stuffing_lists or_lst var_name depth [list_var_read;list_var_write]
+                    (* let current_run exp = stuffing_lists exp var_name depth [[];[]] in
+                    let map_seq_of_results = List.map current_run or_lst in
+                    let more_var_read = extract_from_3d_array map_or_of_results 0 [] in
+                    let more_var_write = extract_from_3d_array map_or_of_results 1 [] in
+                    [list_var_read@more_var_read ;list_var_write@more_var_write] *)
+
+  | Def'(var1, val1), [list_var_read;list_var_write]-> stuffing_lists val1 var_name depth [list_var_read;list_var_write]
+  
+  | LambdaSimple'(params_str_lst, expr_tag_body), [list_var_read;list_var_write]->
+                                (* TODO check - if: should_be_boxed is empty- then we won't return seq *)
+                                (* let bady_rec = stuffing_lists expr_tag_body [[];[]] *)
+                                (* [list_var_read;list_var_write] *)
+                                stuffing_lists expr_tag_body var_name (depth+1) [list_var_read;list_var_write]
+
+  | LambdaOpt'(params_str_lst, vs_str, expr_tag_body), [list_var_read;list_var_write]->
+                                stuffing_lists expr_tag_body var_name (depth+1) [list_var_read;list_var_write]
+  | Applic'(e1, args1) ,[list_var_read;list_var_write]-> 
+                    let lst = [e1]@args1 in
+                    map_stuffing_lists lst var_name depth [list_var_read;list_var_write]
+
+  | ApplicTP'(e1, args1), [list_var_read;list_var_write]->
+                    let lst = [e1]@args1 in
+                    map_stuffing_lists lst var_name depth [list_var_read;list_var_write]
+
+  | _ -> raise X_box_stuffing_lists 
+  
+  and map_stuffing_lists lst var_name depth lists = match lists with 
+          | [list_var_read;list_var_write] ->
+                    let current_run exp = stuffing_lists exp var_name depth [[];[]] in
+                    let map_of_results = List.map current_run lst in
+                    let more_var_read = extract_from_3d_array map_of_results 0 [] in
+                    let more_var_write = extract_from_3d_array map_of_results 1 [] in
+                    [list_var_read@more_var_read ;list_var_write@more_var_write]
+          | _ -> raise X_map_stuffing_lists 
+  in
+
+  stuffing_lists expr var_name (-1) [[];[]] ;;
+
+  
+
+
+
+
+  (* res_lists = [[ref a; ref b; ref c] ; [ref a] ; [ref a ; ref d]]
+
+  curr_list_ref = [ref a; ref b; ref c] *)
+
+(* [ [[]] ; [[]]     ] *)
+let extract_ribs_3d_array arr result = 
+  let rec extraction arr result = match arr with
+  | []  -> result
+  | _ -> extraction (List.tl arr) result@(List.hd arr)
+  in extraction arr result;;
+
+let box_rib_stuffing expr var_name =
+    let rec rib_stuffing expr var_name depth curr_list_ref res_lists  = match expr with
+      | Const'(s1)-> res_lists
+      | Var'(VarFree v1)-> res_lists
+      | Var'(VarParam (v1,mn1))->
+                              if ((String.equal v1 var_name) && (depth == (-1)))
+                              then res_lists@[curr_list_ref]
+                              else res_lists
+    
+      | Var'(VarBound (v1,mj1,mn1))-> 
+                              if((String.equal v1 var_name) && (depth == mj1))
+                              then res_lists@[curr_list_ref]
+                              else res_lists
+      | Set'(x,bval) ->
+
+                  let var_type x = match x with
+                    | VarParam (v1,mn1) ->
+                                                    if ((String.equal v1 var_name) && (depth == (-1)))
+                                                    then rib_stuffing bval var_name depth curr_list_ref res_lists@[curr_list_ref]
+                                                    else rib_stuffing bval var_name depth curr_list_ref res_lists
+                    | VarBound (v1,mj1,mn1)-> 
+                                                    if((String.equal v1 var_name) && (depth == mj1))
+                                                    then rib_stuffing bval var_name depth curr_list_ref res_lists@[curr_list_ref]
+                                                    else rib_stuffing bval var_name depth curr_list_ref res_lists
+                    | VarFree (v1) ->               rib_stuffing bval var_name depth curr_list_ref res_lists
+                    (* | _ -> raise X_box_rib_stuffing *)
+                    in
+                    var_type x
+
+      | If'(test_exp, then_exp, else_exp)-> 
+                                            let if_lst = [test_exp; then_exp; else_exp] in
+                                            map_stuffing_ribs if_lst var_name depth curr_list_ref res_lists
+                                            
+                                            
+      | Seq'(seq_lst)-> map_stuffing_ribs seq_lst var_name depth curr_list_ref res_lists
+                        
+      | Or'(or_lst)-> map_stuffing_ribs or_lst var_name depth curr_list_ref res_lists
+                       
+      | Def'(var1, val1)-> rib_stuffing val1 var_name depth curr_list_ref res_lists
+      
+      | LambdaSimple'(params_str_lst, expr_tag_body)->
+                            rib_stuffing expr_tag_body var_name (depth+1) (curr_list_ref@[(ref params_str_lst)]) res_lists
+                                        
+      | LambdaOpt'(params_str_lst, vs_str, expr_tag_body)->
+                            rib_stuffing expr_tag_body var_name (depth+1) (curr_list_ref@[(ref params_str_lst)]) res_lists
+
+      | Applic'(e1, args1)-> 
+                            let lst = [e1]@args1 in
+                            map_stuffing_ribs lst var_name depth curr_list_ref res_lists
+    
+      | ApplicTP'(e1, args1)->
+                            let lst = [e1]@args1 in
+                            map_stuffing_ribs lst var_name depth curr_list_ref res_lists
+    
+      | _ -> raise X_box_rib_stuffing 
+      
+
+    and map_stuffing_ribs lst var_name depth curr_list_ref res_lists = 
+      
+                let current_run exp = rib_stuffing exp var_name depth curr_list_ref [] in
+                let map_of_results = List.map current_run lst in
+                let more_var_ribs = extract_ribs_3d_array map_of_results [] in
+                res_lists@more_var_ribs
+      
+
+      in
+      rib_stuffing expr var_name (-1) [(ref ["to_remove"])] [];;
+
+
+
+
+
+(* return the lst with intersection TODO we compare the major of varbound*)
+let search_read_write_together list_read list_write = raise X_not_yet_implemented;;
+
+(* return the lst with set for every var in lst *)
+(* Set'(Var'(VarParam(v, minor)), Box'(VarParam(v,minor))) *)
+let create_seq_boxset should_be_boxed = raise X_not_yet_implemented;;
+
+
+
+(* let bady_gen_lists_rw = box expr_tag_body [] []
+                            let should_be_boxed = search_read_write_together list_read list_write in
+                            let seq_box_lst = create_seq_boxset should_be_boxed in 
+                            let body_box = seq_box_lst@(change_var_with_box_set_get bady_rec should_be_boxed)) *)
+
+
+
+
+(* let box_set expr = raise X_not_yet_implemented;; *)
+
+
+let does_param_has_different_ribs var_shows = 
+  let rec triangle_run answer var_shows = match var_shows with
+  | [] -> answer
+  | _ -> 
+          let head = (List.hd var_shows) in
+          let rest = (List.tl var_shows) in 
+          let memq_param lst show = List.memq show lst in
+          let func lst = List.map (memq_param lst) head in
+          let bool_lst_lst_gen = List.map func rest in
+          triangle_run (answer@bool_lst_lst_gen) rest 
+  in
+  let func_bool bool_lst = List.fold_left (||) false bool_lst in
+  let bool_lst_of_ribs_Not = List.map  func_bool  (triangle_run [] var_shows)
+  in
+  let final_and = List.fold_left (&&) true bool_lst_of_ribs_Not in
+  let is_ribs_to_box = not final_and in
+  is_ribs_to_box;;
+
+
+
+
+let box_set expr = 
+  let rec box expr = match expr with
+  | Const'(s1)->
+                      Const'(s1)
+  | Var'(VarFree v1)->
+                      Var'(VarFree v1)
+  | Var'(VarParam (v1,mn1))->
+                      Var'(VarParam (v1,mn1))
+  | Var'(VarBound (v1,mj1,mn1))->
+                      Var'(VarBound (v1,mj1,mn1))
+  | Set'(x,bval) -> 
+                      Set'(x,box bval)
+  | If'(test_exp, then_exp, else_exp)-> 
+                      If'(box test_exp, box then_exp, box else_exp)
+  | Seq'(seq_lst)-> 
+                      let map_box = List.map box seq_lst in
+                      Seq'(map_box)
+  | Or'(or_lst)-> 
+                      let map_box = List.map box or_lst in
+                      Or'(map_box)
+  | Def'(var1, val1)->
+                      Def'(var1, box val1)
+  | LambdaSimple'(params_str_lst, expr_tag_body)->
+
+  let rules var_name = 
+                      (* ALL R_W *)
+                      (* let func_r_w var_name = (box_stuffing_lists expr_tag_body var_name) in *)
+                      let lst_RW = (box_stuffing_lists expr_tag_body var_name) in
+                      (* let all_params_r_w_lists = List.map func_r_w params_str_lst in *)
+                      (* [ [[];[]]; [[];[]] ] *)
+
+                       (* Single R_W *)
+                      (* let func_is_r_w param = if ((List.length (List.hd param) > 0 ) && (List.length (List.hd (List.tl param)) > 0) ) then true else false in *)
+                      let rule_one_bool = if ((List.length (List.hd lst_RW) > 0 ) && (List.length (List.hd (List.tl lst_RW)) > 0) ) then true else false in
+                      (* let params_read_write = List.map (func_is_r_w) all_params_r_w_lists in *)
+                      (* let rule_one_bool = does_param_has_read_write_together *)
+                      
+                
+                      (* ALL Ribs *)
+                      (* let func_ribs var_name = (box_rib_stuffing expr_tag_body var_name) in *)
+                      let lst_ribs = (box_rib_stuffing expr_tag_body var_name) in
+                      (* let all_params_ribs_lists = List.map func_ribs params_str_lst in *)
+                      (* [[];[];[]] *)
+
+                      (* Single Ribs *)
+                      let func_rest piece = (List.tl piece) in
+                      (* let params_ribs_lists_clean_first_junk_func param_appearances = List.map func_rest param_appearances in *)
+                      let params_ribs_lists_clean_first_junk_func = List.map func_rest lst_ribs in
+                      
+                      (* let params_ribs_cleaned = List.map params_ribs_lists_clean_first_junk_func all_params_ribs_lists in *)
+
+                      (* let rule_two_bool = does_param_has_different_ribs params_ribs_cleaned in *)
+                      let rule_two_bool = does_param_has_different_ribs params_ribs_lists_clean_first_junk_func in
+                      
+                      (* R_W  && Ribs *)
+                      let should_box_param = rule_one_bool && rule_two_bool in
+                      should_box_param 
+
+                      in
+                      (* All params_str *)
+                      let all_params_boolean_box_array = List.map rules params_str_lst
+
+                      in
+
+
+                      let rec recursive_sets boolean_array params_array index sets_array = match boolean_array with
+                      | [] -> sets_array
+                      | _ -> if(List.hd boolean_array) 
+                             then (recursive_sets (List.tl boolean_array) (List.tl params_array) (index + 1) (sets_array@[Set'(VarParam(List.hd params_array, index), Box'(VarParam(List.hd params_array,index)))] )) 
+                             else (recursive_sets (List.tl boolean_array) (List.tl params_array) (index + 1) sets_array) 
+                      in
+                      let sets_lst = recursive_sets all_params_boolean_box_array params_str_lst 0 []
+                      in
+                      
+
+                      (* box_make_the_change_with_box_set_get boolean expr var_name =  *)
+                      let rec recursive_change_to_box boolean_array params_array body = match boolean_array with
+                      | [] -> body
+                      | _ -> let new_body = (box_make_the_change_with_box_set_get (List.hd boolean_array) body (List.hd params_array) ) in
+                              recursive_change_to_box (List.tl boolean_array) (List.tl params_array) new_body
+                      in
+                      let body = recursive_change_to_box all_params_boolean_box_array params_str_lst expr_tag_body
+
+                      in
+
+
+
+                      let construct_sets_with_new_body = match body with 
+                      | Seq'(seq_list) -> Seq'(sets_lst@seq_list)
+                      | _ -> Seq'(sets_lst@[body])
+                      in
+                      LambdaSimple'(params_str_lst, construct_sets_with_new_body)
+                                    
+  | LambdaOpt'(params_str_lst, vs_str, expr_tag_body)->
+  let param_str_lst_and_vs =params_str_lst@[vs_str] in 
+
+  let rules var_name = 
+                      (* ALL R_W *)
+                      let lst_RW = (box_stuffing_lists expr_tag_body var_name) in
+                       (* Single R_W *)
+                      let rule_one_bool = if ((List.length (List.hd lst_RW) > 0 ) && (List.length (List.hd (List.tl lst_RW)) > 0) ) then true else false in
+
+                      (* ALL Ribs *)
+                      let lst_ribs = (box_rib_stuffing expr_tag_body var_name) in
+                      (* Single Ribs *)
+                      let func_rest piece = (List.tl piece) in
+                      let params_ribs_lists_clean_first_junk_func = List.map func_rest lst_ribs in
+
+                      let rule_two_bool = does_param_has_different_ribs params_ribs_lists_clean_first_junk_func in
+                      
+                      (* R_W  && Ribs *)
+                      let should_box_param = rule_one_bool && rule_two_bool in
+                      should_box_param 
+
+                      in
+                      (* All params_str *)
+                      let all_params_boolean_box_array = List.map rules param_str_lst_and_vs
+                      in
+                      let rec recursive_sets boolean_array params_array index sets_array = match boolean_array with
+                      | [] -> sets_array
+                      | _ -> if(List.hd boolean_array) 
+                             then (recursive_sets (List.tl boolean_array) (List.tl params_array) (index + 1) (sets_array@[Set'(VarParam(List.hd params_array, index), Box'(VarParam(List.hd params_array,index)))] )) 
+                             else (recursive_sets (List.tl boolean_array) (List.tl params_array) (index + 1) sets_array) 
+                      in
+                      let sets_lst = recursive_sets all_params_boolean_box_array param_str_lst_and_vs 0 []
+                      in
+                      
+
+                      let rec recursive_change_to_box boolean_array params_array body = match boolean_array with
+                      | [] -> body
+                      | _ -> let new_body = (box_make_the_change_with_box_set_get (List.hd boolean_array) body (List.hd params_array) ) in
+                              recursive_change_to_box (List.tl boolean_array) (List.tl params_array) new_body
+                      in
+                      let body = recursive_change_to_box all_params_boolean_box_array param_str_lst_and_vs expr_tag_body
+
+                      in
+
+
+
+                      let construct_sets_with_new_body = match body with 
+                      | Seq'(seq_list) -> Seq'(sets_lst@seq_list)
+                      | _ -> Seq'(sets_lst@[body])
+                      in
+                      LambdaOpt'(params_str_lst, vs_str, construct_sets_with_new_body)
+
+  | Applic'(e1, args1)->
+                        let map_box = List.map box args1 in
+                        Applic'((box e1), map_box)
+  | ApplicTP'(e1, args1)->
+                        let map_box = List.map box args1 in
+                        ApplicTP'((box e1), map_box)
+  
+  | _ -> raise X_box_rib_stuffing 
+
+
+  in
+  box expr;;
+
+
+
+
+
+let run_semantics_first expr = (annotate_tail_calls (annotate_lexical_addresses expr));;
 
-let box_set e = raise X_not_yet_implemented;;
 
 let run_semantics expr =
   box_set
-    (annotate_tail_calls
-       (annotate_lexical_addresses expr));;
+    (annotate_tail_calls (annotate_lexical_addresses expr));;
   
 end;; (* struct Semantics *)
-
-
+open Semantics;;
