diff --git a/pc.ml b/pc.ml
index 6a25660..2127c68 100644
--- a/pc.ml
+++ b/pc.ml
@@ -2,7 +2,7 @@
  * A parsing-combinators package for ocaml
  *
  * Prorammer: Mayer Goldberg, 2018
- *)
+*)
 
 (* general list-processing procedures *)
 
@@ -14,14 +14,14 @@ let rec ormap f s =
 let rec andmap f s =
   match s with
   | [] -> true
-  | car :: cdr -> (f car) && (andmap f cdr);;	  
+  | car :: cdr -> (f car) && (andmap f cdr);;
 
 let lowercase_ascii  =
   let delta = int_of_char 'A' - int_of_char 'a' in
   fun ch ->
-  if ('A' <= ch && ch <= 'Z')
-  then char_of_int ((int_of_char ch) - delta)
-  else ch;;
+    if ('A' <= ch && ch <= 'Z')
+    then char_of_int ((int_of_char ch) - delta)
+    else ch;;
 
 let string_to_list str =
   let rec loop i limit =
@@ -35,154 +35,154 @@ let list_to_string s =
 
 module PC = struct
 
-(* the parsing combinators defined here *)
-  
-exception X_not_yet_implemented;;
+  (* the parsing combinators defined here *)
 
-exception X_no_match;;
+  exception X_not_yet_implemented;;
 
-let const pred =
-  function 
-  | [] -> raise X_no_match
-  | e :: s ->
-     if (pred e) then (e, s)
-     else raise X_no_match;;
+  exception X_no_match;;
 
-let caten nt1 nt2 s =
-  let (e1, s) = (nt1 s) in
-  let (e2, s) = (nt2 s) in
-  ((e1, e2), s);;
+  let const pred =
+    function
+    | [] -> raise X_no_match
+    | e :: s ->
+      if (pred e) then (e, s)
+      else raise X_no_match;;
 
-let pack nt f s =
-  let (e, s) = (nt s) in
-  ((f e), s);;
+  let caten nt1 nt2 s =
+    let (e1, s) = (nt1 s) in
+    let (e2, s) = (nt2 s) in
+    ((e1, e2), s);;
 
-let nt_epsilon s = ([], s);;
+  let pack nt f s =
+    let (e, s) = (nt s) in
+    ((f e), s);;
 
-let caten_list nts =
-  List.fold_right
-    (fun nt1 nt2 ->
-     pack (caten nt1 nt2)
-	  (fun (e, es) -> (e :: es)))
-    nts
-    nt_epsilon;;
+  let nt_epsilon s = ([], s);;
 
-let disj nt1 nt2 =
-  fun s ->
-  try (nt1 s)
-  with X_no_match -> (nt2 s);;
+  let caten_list nts =
+    List.fold_right
+      (fun nt1 nt2 ->
+         pack (caten nt1 nt2)
+           (fun (e, es) -> (e :: es)))
+      nts
+      nt_epsilon;;
 
-let nt_none _ = raise X_no_match;;
-  
-let disj_list nts = List.fold_right disj nts nt_none;;
+  let disj nt1 nt2 =
+    fun s ->
+      try (nt1 s)
+      with X_no_match -> (nt2 s);;
 
-let delayed thunk s =
-  thunk() s;;
+  let nt_none _ = raise X_no_match;;
 
-let nt_end_of_input = function
-  | []  -> ([], [])
-  | _ -> raise X_no_match;;
+  let disj_list nts = List.fold_right disj nts nt_none;;
 
-let rec star nt s =
-  try let (e, s) = (nt s) in
+  let delayed thunk s =
+    thunk() s;;
+
+  let nt_end_of_input = function
+    | []  -> ([], [])
+    | _ -> raise X_no_match;;
+
+  let rec star nt s =
+    try let (e, s) = (nt s) in
       let (es, s) = (star nt s) in
       (e :: es, s)
-  with X_no_match -> ([], s);;
-
-let plus nt =
-  pack (caten nt (star nt))
-       (fun (e, es) -> (e :: es));;
-
-let guard nt pred s =
-  let ((e, _) as result) = (nt s) in
-  if (pred e) then result
-  else raise X_no_match;;
-  
-let diff nt1 nt2 s =
-  match (let result = nt1 s in
-	 try let _ = nt2 s in
-	     None
-	 with X_no_match -> Some(result)) with
-  | None -> raise X_no_match
-  | Some(result) -> result;;
-
-let not_followed_by nt1 nt2 s =
-  match (let ((_, s) as result) = (nt1 s) in
-	 try let _ = (nt2 s) in
-	     None
-	 with X_no_match -> (Some(result))) with
-  | None -> raise X_no_match
-  | Some(result) -> result;;
-	  
-let maybe nt s =
-  try let (e, s) = (nt s) in
+    with X_no_match -> ([], s);;
+
+  let plus nt =
+    pack (caten nt (star nt))
+      (fun (e, es) -> (e :: es));;
+
+  let guard nt pred s =
+    let ((e, _) as result) = (nt s) in
+    if (pred e) then result
+    else raise X_no_match;;
+
+  let diff nt1 nt2 s =
+    match (let result = nt1 s in
+           try let _ = nt2 s in
+             None
+           with X_no_match -> Some(result)) with
+    | None -> raise X_no_match
+    | Some(result) -> result;;
+
+  let not_followed_by nt1 nt2 s =
+    match (let ((_, s) as result) = (nt1 s) in
+           try let _ = (nt2 s) in
+             None
+           with X_no_match -> (Some(result))) with
+    | None -> raise X_no_match
+    | Some(result) -> result;;
+
+  let maybe nt s =
+    try let (e, s) = (nt s) in
       (Some(e), s)
-  with X_no_match -> (None, s);;
+    with X_no_match -> (None, s);;
 
-(* useful general parsers for working with text *)
+  (* useful general parsers for working with text *)
 
-let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
+  let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
 
-let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
+  let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
 
-let char_ci =
-  make_char (fun ch1 ch2 ->
-	     (lowercase_ascii ch1) =
-	       (lowercase_ascii ch2));;
+  let char_ci =
+    make_char (fun ch1 ch2 ->
+        (lowercase_ascii ch1) =
+        (lowercase_ascii ch2));;
 
-let make_word char str = 
-  List.fold_right
-    (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
-    (List.map char (string_to_list str))
-    nt_epsilon;;
+  let make_word char str =
+    List.fold_right
+      (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
+      (List.map char (string_to_list str))
+      nt_epsilon;;
 
-let word = make_word char;;
+  let word = make_word char;;
 
-let word_ci = make_word char_ci;;
+  let word_ci = make_word char_ci;;
 
-let make_one_of char str =
-  List.fold_right
-    disj
-    (List.map char (string_to_list str))
-    nt_none;;
+  let make_one_of char str =
+    List.fold_right
+      disj
+      (List.map char (string_to_list str))
+      nt_none;;
 
-let one_of = make_one_of char;;
+  let one_of = make_one_of char;;
 
-let one_of_ci = make_one_of char_ci;;
+  let one_of_ci = make_one_of char_ci;;
 
-let nt_whitespace = const (fun ch -> ch <= ' ');;
+  let nt_whitespace = const (fun ch -> ch <= ' ');;
 
-let make_range leq ch1 ch2 (s : char list) =
-  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
+  let make_range leq ch1 ch2 (s : char list) =
+    const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
 
-let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
+  let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
 
-let range_ci =
-  make_range (fun ch1 ch2 ->
-	      (lowercase_ascii ch1) <=
-		(lowercase_ascii ch2));;
+  let range_ci =
+    make_range (fun ch1 ch2 ->
+        (lowercase_ascii ch1) <=
+        (lowercase_ascii ch2));;
 
-let nt_any (s : char list) = const (fun ch -> true) s;;
+  let nt_any (s : char list) = const (fun ch -> true) s;;
 
-let trace_pc desc nt s =
-  try let ((e, s') as args) = (nt s)
+  let trace_pc desc nt s =
+    try let ((e, s') as args) = (nt s)
       in
       (Printf.printf ";;; %s matched the head of \"%s\", and the remaining string is \"%s\"\n"
-		     desc
-		     (list_to_string s)
-		     (list_to_string s') ;
+         desc
+         (list_to_string s)
+         (list_to_string s') ;
        args)
-  with X_no_match ->
-    (Printf.printf ";;; %s failed on \"%s\"\n"
-		   desc
-		   (list_to_string s) ;
-     raise X_no_match);;
+    with X_no_match ->
+      (Printf.printf ";;; %s failed on \"%s\"\n"
+         desc
+         (list_to_string s) ;
+       raise X_no_match);;
 
-(* testing the parsers *)
+  (* testing the parsers *)
 
-let test_string nt str =
-  let (e, s) = (nt (string_to_list str)) in
-  (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
+  let test_string nt str =
+    let (e, s) = (nt (string_to_list str)) in
+    (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
 
 end;; (* end of struct PC *)
 
diff --git a/reader.ml b/reader.ml
index 32445c2..7283eb3 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,13 +1,13 @@
 
 #use "pc.ml";;
-
+open PC;;
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
-  
+
 type number =
   | Fraction of int * int
   | Float of float;;
-  
+
 type sexpr =
   | Bool of bool
   | Nil
@@ -33,14 +33,268 @@ module Reader: sig
   val read_sexprs : string -> sexpr list
 end
 = struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
+  let normalize_scheme_symbol str =
+    let s = string_to_list str in
+    if (andmap
+          (fun ch -> (ch = (lowercase_ascii ch)))
+          s) then str
+    else Printf.sprintf "|%s|" str;;
+
+  let nt_whitespaces = star nt_whitespace;;
+
+  let make_paired nt_left nt_right nt =
+    let nt = caten nt_left nt in
+    let nt = pack nt (function (_, e) -> e) in
+    let nt = caten nt nt_right in
+    let nt = pack nt (function (e, _) -> e) in
+    nt;;
+
+  let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
+  let make_left_spaced nt = make_paired nt_whitespaces nt_epsilon nt;;
+  let make_right_spaced nt = make_paired nt_epsilon nt_whitespaces nt;;
+
+  (* (pack (char '\n') (function (_) -> [])) *)
+  let nt_end_of_line = (pack (char '\n') (function (_) -> []));;
+
+  let tok_semicolun = make_spaced ( char ';');;
+
+  let nt_boolean = pack (disj (make_spaced (word_ci "#t")) (make_spaced (word_ci "#f")))
+      (function
+        | ['#'; 't'] -> Bool(true)
+        | ['#'; 'T'] -> Bool(true)
+        | ['#'; 'f'] -> Bool(false)
+        | ['#'; 'F'] -> Bool(false)
+        | _ -> raise X_no_match);;
+
+  let int_of_list ds = int_of_string(list_to_string ds);;
+  let digit = range '0' '9';;
+  let digits = plus digit;;
+
+  let tok_int =
+    let nt =caten
+        (maybe (disj (make_left_spaced (char '+')) (make_left_spaced (char '-'))))
+        digits
+    in make_left_spaced nt;;
+
+  let nt_int = pack tok_int
+      (function
+        |(Some(sign),ds) -> Fraction(int_of_list (sign::ds),1)
+        |(_,ds) -> Fraction(int_of_list ds,1));;
+
+  let rec gcd1 a b =
+    match b with
+    | 0 -> a
+    | b -> gcd1 b (a mod b)
+
+  let nt_fraction =
+    let rec gcd a b =
+      match b with
+      | 0 -> a
+      | b -> gcd b (a mod b) in
+    let abs = fun x -> if x < 0 then -x else x in
+    let frac = caten (caten tok_int (char '/')) digits in
+    let frac = make_spaced frac in
+    let frac = pack frac
+        (function
+          | (((Some(sign),a),_),b) -> (int_of_list (sign::a),int_of_list b)
+          | (((_,a),_),b) -> (int_of_list a,int_of_list b)) in
+    pack frac (function (a,b) ->
+        let g = abs (gcd a b) in
+        Fraction(a/g, b/g));;
+
+  let float_of_list ds = float_of_string(list_to_string ds);;
+  let nt_float =
+    let fl = caten tok_int (caten (char '.') digits) in
+    let fl = pack (make_spaced fl)
+        (function
+          | ((Some(sign),numberA),(point,numberB)) -> (sign::numberA)@[point]@numberB
+          | ((_,numberA),(point,numberB)) -> numberA@[point]@numberB) in
+    pack fl (function (e)->Float(float_of_list e));;
+
+
+  let nt_number = pack (disj_list [nt_fraction;nt_float;nt_int]) (function (e) -> Number(e));;
+
+
+  let nt_number_scientific_notation =
+    let nt = caten (disj nt_float nt_int) (caten (char_ci 'e') nt_int) in
+    let nt = pack nt
+        (function
+          | (Fraction(e1,_),(_,Float(e2))) -> raise X_no_match
+          | (Float(e1),(_,Float(e2))) -> raise X_no_match
+          | (Float(n1) , (_,Fraction(n2,_))) -> Number(Float(n1*.(10.0**float_of_int(n2))))
+          | (Fraction(n1,_) , (_,Fraction(n2,_))) -> Number(Float(float_of_int(n1)*.(10.0**float_of_int(n2)))))
+    in (disj nt nt_number) ;;
+
+  let letter_lowercase = range 'a' 'z';;
+  let letter_uppercase = pack (range 'A' 'Z') (function (e) -> lowercase_ascii e);;
+  (* map char string: *)
+  let punctuation = one_of "!$^*-_=+<>/?:";;
+  let tok_dot = char '.';;
+  let tok_char_not_dot = disj_list [digit;letter_lowercase;letter_uppercase;punctuation];;
+  let tok_symbol_char = disj tok_char_not_dot tok_dot
+
+  (* ⟨Symbol⟩ ::= ⟨SymbolCharNoDot⟩ | ⟨SymbolChar⟩⟨SymbolChar⟩+ *)
+  let nt_symbols =
+    let nt1 = pack tok_char_not_dot (function (e) -> [e]) in
+    let nt2 = pack (caten tok_symbol_char (plus tok_symbol_char)) (function (ch,ch_list) -> [ch]@ch_list) in
+    let nt = pack (disj nt2 nt1)
+        (function (e)-> Symbol(list_to_string e)) in
+    make_spaced nt;;
+
+
+  let nt_char =
+    let nt_named_chars = disj_list (List.map word_ci
+                                      ["#\\nul";"#\\newline";"#\\return";"#\\tab";"#\\page";"#\\space"]) in
+
+    let nt_named_chars = pack (make_spaced nt_named_chars) list_to_string in
+    let nt_named_chars = pack nt_named_chars
+        (function (res) -> match (String.lowercase_ascii res) with
+            | "#\\nul" -> char_of_int 0
+            | "#\\newline" -> char_of_int 10
+            | "#\\return" -> char_of_int 13
+            | "#\\tab" -> char_of_int 9
+            | "#\\page" -> char_of_int 12
+            | "#\\space" -> char_of_int 32
+            | _ -> raise  X_no_match
+        ) in
+    let nt_visble_char = const (fun ch -> ch > ' ') in
+    let nt_visble_char = pack (make_spaced (caten (make_left_spaced (word "#\\")) nt_visble_char))
+        (function (_,e) -> e) in
+    pack (disj nt_named_chars nt_visble_char)
+      (function (e) -> Char(e));;
+
+  let nt_literal_char = const (fun ch -> ch != '\"' && ch != '\\'  && ch >= ' ');;
+  (* \f is not  a valid special meta char in Ocaml - so we need to parse it differently*)
+  let nt_meta_char =
+    let meta_chars = one_of  "\\\r\n\t" in
+    let meta_chars_pair = pack (caten (char '\\') (one_of "rntf\"\\"))
+        (function
+          | (_,'r') -> char_of_int 13
+          | (_,'n') -> char_of_int 10
+          | (_,'t') -> char_of_int 9
+          | (_,'f') -> char_of_int 12
+          | (_,'\"') -> char_of_int 34
+          | (_,'\\') -> char_of_int 92
+          | _ -> raise X_no_match) in
+    disj meta_chars_pair meta_chars;;
+
+  (* String -> "(StringliteralChar | StringMetaChar)* "  *)
+  (* ToDo: nt_string should work without removing (quote) from string meta char *)
+  let nt_string =
+    let nt_left_string_quote = (make_left_spaced (char '\"')) in
+    let nt_right_string_quote =  (make_right_spaced (char '\"')) in
+    let nt_string_char = star (disj nt_literal_char nt_meta_char) in
+    let nt  = pack (caten nt_left_string_quote (caten nt_string_char nt_right_string_quote))
+        (function (quote_start,(body,quote_end)) -> String (list_to_string body)) in
+    nt;;
+
+  let nt_line_comment=
+    let nt_end_of_comment = disj nt_end_of_line nt_end_of_input in
+    (* let nt_line_comment = not_followed_by nt_any nt_end_of_comment in *)
+    let nt_comment_body = star (const (fun ch -> ch != '\n')) in
+    let nt_line_comment = caten  (make_left_spaced (char ';')) (caten nt_comment_body nt_end_of_comment) in
+    pack nt_line_comment (fun e -> "Comment")
+
+
+  let lParen = (make_spaced (char '('));;
+  let rParen = (make_spaced (char ')'));;
+  let dot = (make_spaced (char '.'));;
+
+  let rec nt_list_pair s=
+    let nt = star nt_sexpr in
+    let packed =  pack (caten lParen (caten nt rParen))
+        (function
+            (_, (sexp_list, _)) ->
+            List.fold_right
+              (fun a b -> Pair(a,b))
+              sexp_list
+              Nil) in
+    packed s
+
+  (* ToDo: update pair the will work with nested () *)
+  and nt_dotted_list_pair s=
+    let nt = caten (plus nt_sexpr) (caten dot nt_sexpr) in
+    let packed =  pack (caten lParen (caten nt rParen))
+        (function
+            (_,((sexpr_list , (_ , sexpr)) , _)) ->
+            List.fold_right
+              (fun a b ->   Pair(a,b))
+              sexpr_list
+              sexpr) in
+    packed s
+
+  and nt_make_quote nt_char str s=
+    let nt_q = caten nt_char nt_sexpr in
+    let packed = pack nt_q (function (_,sexpr) ->
+        Pair(Symbol(str),Pair(sexpr,Nil))) in
+    packed s
+
+  and nt_make_quote2 nt_word str s=
+    let nt_q = caten nt_word nt_sexpr in
+    let packed = pack nt_q (function(_,sexpr) ->
+        Pair(Symbol(str),Pair(sexpr,Nil))) in
+    packed s
+
+  and nt_quoted s = nt_make_quote (make_spaced (char '\'')) "quote" s
+  and nt_qquoted s = nt_make_quote (make_spaced (char '`')) "quasiquote" s
+  and nt_unquoted s = nt_make_quote (make_spaced (char ',')) "unquote" s
+  and nt_unquoted_spliced s= nt_make_quote2 (make_spaced (word ",@")) "unquote-splicing" s
+
+  (* ⟨Sexpr⟩ ::= ⟨Boolean⟩ | ⟨Char⟩ | ⟨Number⟩ | ⟨String⟩
+     | ⟨Symbol⟩ | ⟨List⟩ | ⟨DottedList⟩ | ⟨Quoted⟩
+     | ⟨QuasiQuoted⟩ | ⟨Unquoted⟩
+     | ⟨UnquoteAndSpliced⟩ *)
+
+  (*    S -> #;(S | nt_epsilon)sexpr    *)
+  and nt_sexpr_comment s=
+    let nt =
+      fun x ->
+        pack (caten (make_spaced (word "#;"))
+                (caten (disj nt_sexpr_comment (pack nt_epsilon (fun _ -> "Comment"))) nt_sexpr))
+          (fun _ -> "Comment")
+          x in
+    nt s
+
+
+  and nt_comment s= (disj nt_line_comment nt_sexpr_comment) s
+
+  and nt_nil s=
+    let packed = pack (caten lParen (caten (star nt_comment) rParen))
+        (function _ -> Nil) in
+    packed s
+
+  and nt_sexpr s=
+    let (_,s) = ((star nt_comment) s) in
+    let nt_number_not_followed_symbol =
+      not_followed_by nt_number_scientific_notation
+        (disj_list [letter_lowercase;letter_uppercase;punctuation]) in
+    let (e1,s) =
+      (
+        disj_list [
+
+          nt_number_not_followed_symbol;
+          (* nt_boolean_not_followed_symbol; *)
+          nt_boolean;
+          (* nt_number_scientific_notation; *)
+          nt_symbols;
+
+          nt_char;
+          nt_string;nt_list_pair;nt_dotted_list_pair;
+          nt_quoted;nt_qquoted;nt_unquoted;nt_unquoted_spliced;nt_nil] s
+      ) in
+    let (e2, s) = (star nt_comment) s in
+    (e1,s);;
+
+  let read_sexprs string =
+    let nt =  (star nt_sexpr)  in
+    let (e,s) = nt (string_to_list string) in
+    let (_,s2) = nt_whitespaces s in
+    match e,s,s2 with
+    | e,_,[] -> e
+    | _ -> raise X_no_match
+
+  (* ToDo: check if Case sensiticty is already implemented*)
 
+end;;
 
-let read_sexprs string = raise X_not_yet_implemented;;
-  
-end;; (* struct Reader *)
+open Reader;;
diff --git a/readme.txt b/readme.txt
index e69de29..f4b8a63 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Itay Osovlansky 311129274
+Alon Sadan 302769344
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
\ No newline at end of file
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..3424509 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,6 +1,6 @@
 #use "tag-parser.ml";;
 
-type var = 
+type var =
   | VarFree of string
   | VarParam of string * int
   | VarBound of string * int * int;;
@@ -39,25 +39,25 @@ let rec expr'_eq e1 e2 =
   | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
                                             (expr'_eq th1 th2) &&
-                                              (expr'_eq el1 el2)
+                                            (expr'_eq el1 el2)
   | (Seq'(l1), Seq'(l2)
-  | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
+    | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
   | (Set'(var1, val1), Set'(var2, val2)
-  | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq (Var'(var1)) (Var'(var2))) &&
+    | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq (Var'(var1)) (Var'(var2))) &&
                                              (expr'_eq val1 val2)
   | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) ->
-     (List.for_all2 String.equal vars1 vars2) &&
-       (expr'_eq body1 body2)
+    (List.for_all2 String.equal vars1 vars2) &&
+    (expr'_eq body1 body2)
   | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) ->
-     (String.equal var1 var2) &&
-       (List.for_all2 String.equal vars1 vars2) &&
-         (expr'_eq body1 body2)
+    (String.equal var1 var2) &&
+    (List.for_all2 String.equal vars1 vars2) &&
+    (expr'_eq body1 body2)
   | Applic'(e1, args1), Applic'(e2, args2)
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
-	 (expr'_eq e1 e2) &&
-	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+    (expr'_eq e1 e2) &&
+    (List.for_all2 expr'_eq args1 args2)
+  | _ -> false;;
+
 exception X_syntax_error;;
 
 module type SEMANTICS = sig
@@ -69,17 +69,541 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+  exception Itay_X_Expr of expr;;
+  exception Itay_X_Expr' of expr';;
+  exception Itay_X_string_list_list of string list list;;
+
+  let rec find_exist_item item lst =
+    match lst with
+    | [] -> -1
+    | hd::tl -> if hd = item then 0 else 1 + find_exist_item item tl;;
+
+  let find item lst =
+    match (List.mem item lst) with
+    | true -> find_exist_item item lst
+    | false -> -1;;
+
+  let annotate_lexical_var var env =
+    let rec env_major_minor item lst major_acc =
+      (* assuming lst is without last item in origin lst and also is reversed *)
+      match lst with
+      | [] -> major_acc,-1
+      | _ ->
+        let minor = find item (List.hd lst) in
+        if minor >= 0 then major_acc,minor
+        else env_major_minor item (List.tl lst) (major_acc+1) in
+    let name = match var with
+      | Var(s) -> s
+      | _ -> raise X_syntax_error in
+    match env with
+    | [] -> VarFree(name)
+    | lst ->
+      let index = find name (List.hd env) in
+      (
+        if index >= 0 then VarParam(name,index)
+        else
+          let major,minor = env_major_minor name (List.tl env) 0 in
+          if minor = -1 then VarFree(name)
+          else VarBound(name,major,minor)
+      );;
+
+  (* let annotate_lexical_var var env = VarFree("not implmented yet");; *)
+
+
+  (* env should be list of list vars/string where the the item_i represent the level i in the current scope *)
+  (* ToDo: maybe declare env type  *)
+  let rec annotate_lexical_expr expr env =
+    match expr with
+    | Const(e) -> Const'(e)
+    | Var(e) -> Var'(annotate_lexical_var expr env)
+    | If(test,dit,dif) -> If'(annotate_lexical_expr test env,annotate_lexical_expr dit env,annotate_lexical_expr dif env)
+    | Seq(exprs) ->  Seq'(List.map (fun e -> annotate_lexical_expr e env) exprs)
+    | Set(a,b) -> Set'(annotate_lexical_var a env,annotate_lexical_expr b env)
+    | Def(name,value) -> Def'(annotate_lexical_var name env,annotate_lexical_expr value env)
+    | Or(exprs) ->  Or'(List.map (fun e -> annotate_lexical_expr e env) exprs)
+    | LambdaSimple(arglist,body) -> LambdaSimple'(arglist, annotate_lexical_expr body ([arglist] @ env))
+    | LambdaOpt(arglist,opt,body) -> LambdaOpt'(arglist,opt,annotate_lexical_expr body ([arglist @ [opt]] @ env))
+    | Applic(proc,args) -> Applic'(annotate_lexical_expr proc env,List.map (fun e -> annotate_lexical_expr e env) args);;
+
+  let rec annotate_tail expr' isTP =
+    match expr',isTP with
+    | Var'(expr'),_ -> Var'(expr')
+    | Const'(expr'),_ -> Const'(expr')
+
+    | Or'(exprs),_ ->
+      (match exprs with
+       | [] -> Or'[]
+       | lst ->
+         let lst = List.rev lst in
+         let exprs2 = (annotate_tail (List.hd lst) isTP)::List.map (fun e -> annotate_tail e false) (List.tl lst) in
+         Or'(List.rev exprs2))
+
+    | Seq'(exprs),_ ->
+      (match exprs with
+       | [] -> Seq'[]
+       | lst ->
+         let lst = List.rev lst in
+         let exprs2 = (annotate_tail (List.hd lst) isTP)::List.map (fun e -> annotate_tail e false) (List.tl lst) in
+         Seq'(List.rev exprs2))
+
+    | If'(test,dit,dif),_ -> If'(annotate_tail test false,annotate_tail dit isTP,annotate_tail dif isTP)
+    | Def'(var',expr),_ -> Def'(var',annotate_tail expr false)
+    | Set'(var',expr),_ -> Set'(var',annotate_tail expr false)
+
+    | LambdaSimple'(arglist,body),_ -> LambdaSimple'(arglist, annotate_tail body true)
+    | LambdaOpt'(arglist,opt,body),_ -> LambdaOpt'(arglist, opt,annotate_tail body true)
+
+    | Applic'(proc,args),true -> ApplicTP'(annotate_tail proc false,List.map (fun e -> annotate_tail e false) args)
+    | Applic'(proc,args),false -> Applic'(annotate_tail proc false,List.map (fun e -> annotate_tail e false) args)
+
+    | _ -> raise (Itay_X_Expr' expr')
+
+
+  let rec get_reads_closure expr var_str closuresList curr_closure=
+    match expr with
+    | Const'(e) -> closuresList
+    | Var'(v) ->
+      (match v with
+       | VarFree(x) -> if x = var_str then closuresList @ curr_closure else closuresList
+       | VarParam(x,_) -> if x = var_str then closuresList @ curr_closure else closuresList
+       | VarBound(x,_,_) -> if x = var_str then closuresList @ curr_closure else closuresList)
+    | If'(test,dit,dif) ->
+      (
+        let ifClosures = List.map (fun e -> (get_reads_closure e var_str closuresList curr_closure)) [test;dit;dif] in
+        List.fold_left (fun acc a -> acc @ a) closuresList ifClosures
+      )
+    | Seq'(exprs) ->
+      (
+        let seqClosures = List.map (fun e -> (get_reads_closure e var_str closuresList curr_closure)) exprs in
+        List.fold_left (fun acc a -> acc @ a) closuresList seqClosures
+      )
+
+    | Set'(a,b) -> get_reads_closure b var_str closuresList curr_closure
+    | Def'(name,value) -> get_reads_closure value var_str closuresList curr_closure
+    | Or'(exprs) ->   let seqClosures = List.map (fun e -> (get_reads_closure e var_str closuresList curr_closure)) exprs in
+      List.fold_left (fun acc a -> acc @ a) closuresList seqClosures
+    | LambdaSimple'(arglist,body) ->
+      (
+        get_reads_closure body var_str closuresList [(LambdaSimple'(arglist,body))]
+      )
+    | LambdaOpt'(arglist,opt,body) ->
+      (
+        get_reads_closure body var_str closuresList [(LambdaOpt'(arglist,opt,body))]
+      )
+    | Applic'(proc,args) ->
+      (
+        let procClosure = get_reads_closure proc var_str closuresList curr_closure in
+        let seqClosures = List.map (fun e -> (get_reads_closure e var_str closuresList curr_closure)) args in
+        let seqClosures2 =  List.fold_left (fun acc a -> acc @ a) closuresList seqClosures in
+        procClosure @ seqClosures2
+      )
+    | ApplicTP'(proc,args) ->
+      (
+        let procClosure = get_reads_closure proc var_str closuresList curr_closure in
+        let seqClosures = List.map (fun e -> (get_reads_closure e var_str closuresList curr_closure)) args in
+        let seqClosures2 =  List.fold_left (fun acc a -> acc @ a) closuresList seqClosures in
+        procClosure @ seqClosures2
+      )
+
+
+    | _ -> raise X_syntax_error;;
+
+
+  let rec get_writes_closure expr var_str closuresList curr_closure=
+    match expr with
+    | Const'(e) -> closuresList
+    | Var'(v) -> closuresList
+    | If'(test,dit,dif) ->
+      (
+        let ifClosures = List.map (fun e -> (get_writes_closure e var_str closuresList curr_closure)) [test;dit;dif] in
+        List.fold_left (fun acc a -> acc @ a) closuresList ifClosures
+      )
+    | Seq'(exprs) ->
+      (
+        let seqClosures = List.map (fun e -> (get_writes_closure e var_str closuresList curr_closure)) exprs in
+        List.fold_left (fun acc a -> acc @ a) closuresList seqClosures
+      )
+
+    | Set'(a,b) ->
+      (match a with
+       | VarFree(x) -> if x = var_str then closuresList @ curr_closure else closuresList
+       | VarParam(x,_) -> if x = var_str then closuresList @ curr_closure else closuresList
+       | VarBound(x,_,_) -> if x = var_str then closuresList @ curr_closure else closuresList)
+
+    | Def'(name,value) -> get_writes_closure value var_str closuresList curr_closure
+    | Or'(exprs) ->   let seqClosures = List.map (fun e -> (get_writes_closure e var_str closuresList curr_closure)) exprs in
+      List.fold_left (fun acc a -> acc @ a) closuresList seqClosures
+    | LambdaSimple'(arglist,body) ->
+      (
+        get_writes_closure body var_str closuresList [(LambdaSimple'(arglist,body))]
+      )
+    | LambdaOpt'(arglist,opt,body) ->
+      (
+        get_writes_closure body var_str closuresList [(LambdaOpt'(arglist,opt,body))]
+      )
+    | Applic'(proc,args) ->
+      (
+        let procClosure = get_writes_closure proc var_str closuresList curr_closure in
+        let seqClosures = List.map (fun e -> (get_writes_closure e var_str closuresList curr_closure)) args in
+        let seqClosures2 =  List.fold_left (fun acc a -> acc @ a) closuresList seqClosures in
+        procClosure @ seqClosures2
+      )
+    | ApplicTP'(proc,args) ->
+      (
+        let procClosure = get_writes_closure proc var_str closuresList curr_closure in
+        let seqClosures = List.map (fun e -> (get_writes_closure e var_str closuresList curr_closure)) args in
+        let seqClosures2 =  List.fold_left (fun acc a -> acc @ a) closuresList seqClosures in
+        procClosure @ seqClosures2
+      )
+
+
+    | _ -> raise X_syntax_error;;
+
+
+  let rec get_read_writes_closure expr var_str readClosuresList writeClosuresList curr_closure=
+    match expr with
+    | Const'(e) -> readClosuresList,writeClosuresList
+    | Var'(v) ->
+      (match v with
+       | VarFree(x) -> if x = var_str then readClosuresList @ curr_closure,writeClosuresList else readClosuresList,writeClosuresList
+       | VarParam(x,_) -> if x = var_str then readClosuresList @ curr_closure,writeClosuresList else readClosuresList,writeClosuresList
+       | VarBound(x,_,_) -> if x = var_str then readClosuresList @ curr_closure,writeClosuresList else readClosuresList,writeClosuresList)
+    | If'(test,dit,dif) ->
+      (
+        let ifClosures = List.map (fun e -> (get_read_writes_closure e var_str readClosuresList writeClosuresList curr_closure)) [test;dit;dif] in
+        let a = List.fold_left (fun acc a -> acc @ a) readClosuresList (List.map (fun x -> fst x) ifClosures)  in
+        let b = List.fold_left (fun acc b -> acc @ b) writeClosuresList (List.map (fun x -> snd x) ifClosures) in
+        a,b
+      )
+    | Seq'(exprs) ->
+      (
+        let seqClosures = List.map (fun e -> (get_read_writes_closure e var_str readClosuresList writeClosuresList curr_closure)) exprs in
+        let a = List.fold_left (fun acc a -> acc @ a) readClosuresList (List.map (fun x -> fst x) seqClosures)  in
+        let b = List.fold_left (fun acc b -> acc @ b) writeClosuresList (List.map (fun x -> snd x) seqClosures) in
+        a,b
+      )
+
+    | Set'(a,b) ->
+      ( let x =
+          (match a with
+           | VarFree(x) -> if x = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList
+           | VarParam(x,_) -> if x = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList
+           | VarBound(x,_,_) -> if x = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList) in
+        let y = get_read_writes_closure b var_str readClosuresList writeClosuresList curr_closure in
+        (fst x @ fst y),(snd x @ snd y)
+      )
+
+    | Def'(name,value) ->
+      ( let x =
+          (match name with
+           | VarFree(v) -> if v = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList
+           | VarParam(v,_) -> if v = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList
+           | VarBound(v,_,_) -> if v = var_str then readClosuresList,writeClosuresList @ curr_closure else readClosuresList,writeClosuresList) in
+        let y = get_read_writes_closure value var_str readClosuresList writeClosuresList curr_closure in
+        (fst x @ fst y),(snd x @ snd y)
+      )
+    | Or'(exprs) ->
+      (
+        let orClosures = List.map (fun e -> (get_read_writes_closure e var_str readClosuresList writeClosuresList curr_closure)) exprs in
+        let a = List.fold_left (fun acc a -> acc @ a) readClosuresList (List.map (fun x -> fst x) orClosures)  in
+        let b = List.fold_left (fun acc b -> acc @ b) writeClosuresList (List.map (fun x -> snd x) orClosures) in
+        a,b
+      )
+
+    | LambdaSimple'(arglist,body) ->
+      (
+        get_read_writes_closure body var_str readClosuresList writeClosuresList [(LambdaSimple'(arglist,body))]
+      )
+    | LambdaOpt'(arglist,opt,body) ->
+      (
+        get_read_writes_closure body var_str readClosuresList writeClosuresList [(LambdaOpt'(arglist,opt,body))]
+      )
+    | Applic'(proc,args) ->
+      (
+        let procClosure = get_read_writes_closure proc var_str readClosuresList writeClosuresList curr_closure in
+        let argsClosures = List.map (fun e -> (get_read_writes_closure e var_str readClosuresList writeClosuresList curr_closure)) args in
+        let a = List.fold_left (fun acc a -> acc @ a) readClosuresList (List.map (fun x -> fst x) argsClosures)  in
+        let b = List.fold_left (fun acc b -> acc @ b) writeClosuresList (List.map (fun x -> snd x) argsClosures) in
+        (fst procClosure @ a),(snd procClosure @ b)
+      )
+    | ApplicTP'(proc,args) ->
+      (
+        let procClosure = get_read_writes_closure proc var_str readClosuresList writeClosuresList curr_closure in
+        let argsClosures = List.map (fun e -> (get_read_writes_closure e var_str readClosuresList writeClosuresList curr_closure)) args in
+        let a = List.fold_left (fun acc a -> acc @ a) readClosuresList (List.map (fun x -> fst x) argsClosures)  in
+        let b = List.fold_left (fun acc b -> acc @ b) writeClosuresList (List.map (fun x -> snd x) argsClosures) in
+        (fst procClosure @ a),(snd procClosure @ b)
+      )
+
+
+    | _ -> raise X_syntax_error;;
+
+  let rec get_var_lst exp var_name =
+    match exp with
+    | Const'(e) -> []
+    | Var'(name) -> (match name with
+        | VarFree(v) -> if v = var_name then [VarFree(v)] else []
+        | VarParam(v,major) -> if v = var_name then [VarParam(v,major)] else []
+        | VarBound(v,major,minor) -> if v = var_name then [VarBound(v,major,minor)] else [])
+
+
+    | If'(test,dit,dif) ->
+      (
+        let vars = List.map (fun e -> (get_var_lst e var_name)) [test;dit;dif] in
+        List.fold_left (fun acc a -> acc @ a) [] vars
+      )
+    | Seq'(exprs) | Or'(exprs) ->
+      (
+        let vars = List.map (fun e -> (get_var_lst e var_name)) exprs in
+        List.fold_left (fun acc a -> acc @ a) [] vars
+      )
+
+    | Set'(name,value) |  Def'(name,value)->
+      (let x =
+         (match name with
+          | VarFree(v) -> if v = var_name then [VarFree(v)] else []
+          | VarParam(v,major) -> if v = var_name then [VarParam(v,major)] else []
+          | VarBound(v,major,minor) -> if v = var_name then [VarBound(v,major,minor)] else []) in
+       let y = get_var_lst value var_name in
+       x @ y
+      )
+
+    | LambdaSimple'(arglist, body)  ->
+      (
+        get_var_lst body var_name
+      )
+    | LambdaOpt'(arglist,opt,body)  ->
+      (
+        get_var_lst body var_name
+      )
+    | Applic'(proc,args) | ApplicTP'(proc,args) ->
+      (
+        let procvars = get_var_lst proc var_name  in
+        let vars = List.map (fun e -> (get_var_lst e var_name)) args in
+        let vars2 =  List.fold_left (fun acc a -> acc @ a) [] vars in
+        procvars @ vars2
+      )
+    | _ -> raise X_syntax_error;;
+
+  let rec get_seq_list exp var_name seq_lst curr_item_in_seq =
+    match exp with
+    | Const'(e) -> []
+    | Var'(name) -> (match name with
+        | VarFree(v) -> if v = var_name then seq_lst @ curr_item_in_seq else seq_lst
+        | VarParam(v,major) -> if v = var_name then seq_lst @ curr_item_in_seq else seq_lst
+        | VarBound(v,major,minor) -> if v = var_name then seq_lst @ curr_item_in_seq else seq_lst)
+
+    | If'(test,dit,dif) ->
+      (
+        let seqs = List.map (fun e -> (get_seq_list e var_name seq_lst curr_item_in_seq)) [test;dit;dif] in
+        List.fold_left (fun acc a -> acc @ a) [] seqs
+      )
+    | Seq'(exprs)->
+      (
+        let seqs = List.map (fun e -> (get_seq_list e var_name seq_lst [e])) exprs in
+        [Seq'(List.fold_left (fun acc a -> acc @ a) [] seqs)]
+      )
+    | Or'(exprs) ->
+      (
+        let seqs = List.map (fun e -> (get_seq_list e var_name seq_lst curr_item_in_seq)) exprs in
+        List.fold_left (fun acc a -> acc @ a) [] seqs
+      )
+    | Set'(name,value) |  Def'(name,value)->
+      (let x =
+         (match name with
+          | VarFree(v) -> if v = var_name then curr_item_in_seq else []
+          | VarParam(v,major) -> if v = var_name then curr_item_in_seq else []
+          | VarBound(v,major,minor) -> if v = var_name then curr_item_in_seq else []) in
+       let y = get_seq_list value var_name seq_lst curr_item_in_seq in
+       x @ y
+      )
+
+    | LambdaSimple'(arglist, body)  ->
+      (
+        get_seq_list body var_name seq_lst curr_item_in_seq
+      )
+    | LambdaOpt'(arglist,opt,body)  ->
+      (
+        get_seq_list body var_name seq_lst curr_item_in_seq
+      )
+    | Applic'(proc,args) | ApplicTP'(proc,args) ->
+      (
+        let procseqs = get_seq_list proc var_name seq_lst curr_item_in_seq  in
+        let seqs = List.map (fun e -> (get_seq_list e var_name seq_lst curr_item_in_seq)) args in
+        let seqs2 =  List.fold_left (fun acc a -> acc @ a) [] seqs in
+        procseqs @ seqs2
+      )
+    | _ -> raise X_syntax_error;;
+
+
+  let should_box expr name =
+    let isExistBound0 v = List.exists (fun x-> match x with | VarBound(_,0,_) -> true | _ -> false) v in
+    let isExistBound0Plus v = List.exists (fun x-> match x with | VarBound(_,major,_) -> major > 0 | _ -> false) v in
+    let isExistParam v = List.exists (fun x -> match x with VarParam(_,_)-> true |_-> false) v in
+    let rec checkVarFromEnvsHelper r w =
+      (if not (r == w) then
+         (
+           let v1 = get_var_lst r name in
+           let v2 = get_var_lst w name in
+           if v1 = [] || v2 = [] then false
+           else (
+             if isExistBound0(v1) && isExistBound0(v2) then true
+             else if isExistParam(v1) && isExistBound0Plus(v2) then true
+             else if isExistBound0Plus(v1) && isExistParam(v2) then true
+             else false
+           )
+         )
+       else false)
+    in
+
+    let rec isNotSameRibs readlst writelst name =
+      (match readlst,writelst with
+       | [],_ -> false
+       | _,[] -> false
+       | r::rs,w::ws ->
+         let car =
+           (
+             if (checkVarFromEnvsHelper r w) = true then true else isNotSameRibs (r::rs) ws name
+           ) in
+         if car = true then true else isNotSameRibs rs (w::ws) name) in
+
+    let readlst,writelst = get_read_writes_closure expr name [] [] [] in
+    if (isNotSameRibs readlst writelst name) = false then false
+    else(
+      let seq_lst = get_seq_list expr name [] [] in
+      let rec  criteria1 = function
+        | [] -> false
+        | e::es ->
+          (match e with
+           | Set'(var,_) ->
+             (match var with
+              | VarFree(v) -> if v = name then not ((List.fold_left (fun acc e_es -> acc @ (get_reads_closure e_es name [] [])) es []) = []) else false
+              | VarParam(v,major) -> if v = name then not ((List.fold_left (fun acc e_es -> acc @ (get_reads_closure e_es name [] [])) es []) = []) else false
+              | VarBound(v,major,minor) -> if v = name then not ((List.fold_left (fun acc e_es -> acc @ (get_reads_closure e_es name [] [])) es []) = []) else false)
+           | _ -> criteria1 es
+          ) in
+      let rec  criteria2 = function
+        | [] -> false
+        | e::es ->
+          (match e with
+           | Var'(var) ->
+             (match var with
+              | VarFree(v) -> if v = name then not ((List.fold_left (fun acc e_es -> acc @ (get_writes_closure e_es name [] [])) es []) = []) else false
+              | VarParam(v,major) -> if v = name then not((List.fold_left (fun acc e_es -> acc @ (get_writes_closure e_es name [] [])) es []) = []) else false
+              | VarBound(v,major,minor) -> if v = name then not((List.fold_left (fun acc e_es -> acc @ (get_writes_closure e_es name [] [])) es []) = []) else false)
+
+
+           | _ -> criteria2 es
+          ) in
+      let rec extra_res = function
+        | [] -> true
+        | Seq'(seq_body)::es -> not ((criteria1 seq_body) || (criteria2 seq_body)) && (extra_res es)
+        | _ -> true
+
+      in
+      extra_res seq_lst
+    )
+
+
+  let rec flatten_expr'_seq'_body = function
+    | (Seq'(e)::es) -> e @ (flatten_expr'_seq'_body es)
+    | (e::es) -> e :: (flatten_expr'_seq'_body es)
+    | [] -> [];;
+
+  let rec body_to_expr body =
+    if (List.length body) > 1 then Seq'(flatten_expr'_seq'_body body)
+    else if (List.length body) = 1 then (List.hd body)
+    else raise X_syntax_error;;
+
+
+  let rec make_box expr box_vars =
+    match expr with
+    | Const'(e) -> Const'(e)
+    | Var'(v) ->
+      (match v with
+       | VarFree(x) -> Var'(v)
+       | VarParam(x,minor) -> if List.mem x box_vars then BoxGet'(VarParam(x,minor)) else expr
+       | VarBound(x,minor,major) -> if List.mem x box_vars then BoxGet'(VarBound(x,minor,major)) else expr)
+
+    | If'(test,dit,dif) -> If'(make_box test box_vars,make_box dit box_vars, make_box dif box_vars)
+    | Seq'(exprs) -> Seq'(List.map (fun e -> make_box e box_vars) exprs )
+    | Set'(name,value) ->
+      (match name with
+       | VarFree(x) -> Set'(name,make_box value box_vars)
+       | VarParam(x,minor) -> if List.mem x box_vars then BoxSet'(VarParam(x,minor), make_box value box_vars) else Set'(name,make_box value box_vars)
+       | VarBound(x,minor,major) -> if List.mem x box_vars then BoxSet'(VarBound(x,minor,major), make_box value box_vars) else Set'(name,make_box value box_vars))
+
+    | Def'(name,value) -> Def'(name, make_box value box_vars)
+    | Or'(exprs) ->   Or'(List.map (fun e -> make_box e box_vars) exprs )
+
+    | LambdaSimple'(arglist,body) ->
+      (
+        let box_vars_new = List.filter (fun v-> should_box (LambdaSimple'(arglist,body)) v) arglist in
+        let box_signatures = List.map (fun v-> Set'(VarParam(v, find v arglist), Box'(VarParam(v,find v arglist)))) box_vars_new in
+
+        let box_vars2 =
+          (List.fold_left
+             (fun acc b ->
+                (
+                  if (List.mem b arglist) && (List.mem b box_vars) && (not (List.mem b box_vars_new)) then acc
+                  else acc @ [b]
+                )
+             )
+             []
+             box_vars) in
+
+        let body_box = body_to_expr (box_signatures @ [make_box body (box_vars2 @ box_vars_new)]) in
+        LambdaSimple'(arglist, body_box)
+      )
+
+    | LambdaOpt'(arglist,opt,body) ->
+      (
+        let box_vars_new = List.filter (fun v-> should_box (LambdaOpt'(arglist,opt,body)) v) (arglist@[opt]) in
+        let box_signatures = List.map (fun v-> Set'(VarParam(v, find v (arglist @ [opt])), Box'(VarParam(v,find v (arglist @ [opt])))))  box_vars_new in
+
+        let box_vars2 =
+          (List.fold_left
+             (fun acc b ->
+                (
+                  if (List.mem b (arglist @ [opt])) && (List.mem b box_vars) && (not (List.mem b box_vars_new)) then acc
+                  else acc @ [b]
+                )
+             )
+             []
+             box_vars) in
+
+        let body_box = body_to_expr (box_signatures @ [make_box body (box_vars2 @ box_vars_new)])  in
+        LambdaOpt'(arglist, opt, body_box)
+      )
+
+    | Applic'(proc,args) ->
+      ( let new_args = List.map (fun arg -> make_box arg box_vars) args in
+        let new_proc = make_box proc box_vars in
+        Applic'(new_proc, new_args)
+      )
+
+    | ApplicTP'(proc,args) ->
+      ( let new_args = List.map (fun arg -> make_box arg box_vars) args in
+        let new_proc = make_box proc box_vars in
+        ApplicTP'(new_proc, new_args)
+      )
+
+
+    | _ -> raise X_syntax_error;;
+
+  let annotate_lexical_addresses e = annotate_lexical_expr e [];;
+
+  let annotate_tail_calls e = annotate_tail e false;;
+  (*raise X_not_yet_implemented;;*)
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+  let box_set e = make_box e [];;
+  (* raise X_not_yet_implemented;; *)
 
-let box_set e = raise X_not_yet_implemented;;
+  let run_semantics expr =
+    box_set
+      (annotate_tail_calls
+         (annotate_lexical_addresses expr));;
 
-let run_semantics expr =
-  box_set
-    (annotate_tail_calls
-       (annotate_lexical_addresses expr));;
-  
 end;; (* struct Semantics *)
 
 
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..f65f335 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -22,26 +22,26 @@ let rec expr_eq e1 e2 =
   | Const(Sexpr s1), Const(Sexpr s2) -> sexpr_eq s1 s2
   | Var(v1), Var(v2) -> String.equal v1 v2
   | If(t1, th1, el1), If(t2, th2, el2) -> (expr_eq t1 t2) &&
-                                            (expr_eq th1 th2) &&
-                                              (expr_eq el1 el2)
+                                          (expr_eq th1 th2) &&
+                                          (expr_eq el1 el2)
   | (Seq(l1), Seq(l2)
     | Or(l1), Or(l2)) -> List.for_all2 expr_eq l1 l2
   | (Set(var1, val1), Set(var2, val2)
     | Def(var1, val1), Def(var2, val2)) -> (expr_eq var1 var2) &&
-                                             (expr_eq val1 val2)
+                                           (expr_eq val1 val2)
   | LambdaSimple(vars1, body1), LambdaSimple(vars2, body2) ->
-     (List.for_all2 String.equal vars1 vars2) &&
-       (expr_eq body1 body2)
+    (List.for_all2 String.equal vars1 vars2) &&
+    (expr_eq body1 body2)
   | LambdaOpt(vars1, var1, body1), LambdaOpt(vars2, var2, body2) ->
-     (String.equal var1 var2) &&
-       (List.for_all2 String.equal vars1 vars2) &&
-         (expr_eq body1 body2)
+    (String.equal var1 var2) &&
+    (List.for_all2 String.equal vars1 vars2) &&
+    (expr_eq body1 body2)
   | Applic(e1, args1), Applic(e2, args2) ->
-     (expr_eq e1 e2) &&
-       (List.for_all2 expr_eq args1 args2)
+    (expr_eq e1 e2) &&
+    (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
-                       
+
+
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -50,16 +50,329 @@ end;; (* signature TAG_PARSER *)
 
 module Tag_Parser : TAG_PARSER = struct
 
-let reserved_word_list =
-  ["and"; "begin"; "cond"; "define"; "else";
-   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
-   "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
-   "unquote-splicing"];;  
+  let reserved_word_list =
+    ["and"; "begin"; "cond"; "define"; "else";
+     "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+     "quasiquote"; "quote"; "set!"; "unquote";
+     "unquote-splicing"];;
 
-(* work on the tag parser starts here *)
+  (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+  let list_string_to_string l =
+    List.fold_left (fun acc x -> acc ^ x) "" l;;
 
-  
-end;; (* struct Tag_Parser *)
+  let rec dup_exist = function
+    | [] -> false
+    | hd::tl -> List.exists ((=) hd) tl || dup_exist tl;;
+
+  let assert_list_unique lst = match (dup_exist lst) with
+    | false -> lst
+    | true -> raise X_syntax_error;;
+
+  let rec improper_list_to_ocaml_list = function
+    | Pair(a,b) -> a::(improper_list_to_ocaml_list b)
+    | s -> [s];;
+
+
+  let rec proper_list_to_ocaml_list = function
+    | Pair(a,b) -> a::(proper_list_to_ocaml_list b)
+    | Nil -> []
+    | _ -> raise X_no_match;;
+
+  let rec is_proper_lst = function
+    | Pair(a,b) -> is_proper_lst b
+    | Nil -> true
+    | _ -> false;;
+
+  let rec is_improper_lst = function
+    | Pair(a,b) -> is_improper_lst b
+    | Nil -> false
+    | _ -> true;;
+
+  let is_nil  = function
+    | Nil -> true
+    | _ -> false
+  let is_let_exp = function
+    | Pair(Symbol("let"), args_and_vals) -> true
+    | _-> false ;;
+
+  let rec scheme_list_to_ocaml_list scheme_lst=
+    if is_proper_lst scheme_lst then proper_list_to_ocaml_list scheme_lst
+    else  improper_list_to_ocaml_list scheme_lst;;
+
+  let improper_arglist_to_lambdaOpt arglist final_body=
+    let f = (function | Symbol(e) -> e | _ -> raise X_no_match) in
+    let lst = List.map f (improper_list_to_ocaml_list arglist) in
+    let lst = assert_list_unique lst in
+    let lst_last = List.hd (List.rev lst) in
+    let lst_without_last = List.rev (List.tl (List.rev lst)) in
+    LambdaOpt (lst_without_last, lst_last, final_body);;
+
+  let rec flatten_scheme_expr_list = function
+    | (Seq(e)::es) -> e @ (flatten_scheme_expr_list es)
+    | (e::es) -> e :: (flatten_scheme_expr_list es)
+    | [] -> [];;
+
+  let rec body_to_expr body =
+    if (List.length body) > 1 then Seq(flatten_scheme_expr_list body)
+    else if (List.length body) = 1 then (List.hd body)
+    else raise X_syntax_error;;
+
+  let wrap_with_quote sexpr = Pair(Symbol "quote",Pair(sexpr,Nil))
+  let wrap_with_qq sexpr = Pair(Symbol "quasiquote",Pair(sexpr,Nil))
+
+
+  let rec zip lst1 lst2 =
+    match lst1,lst2 with
+    | [], [] -> []
+    | h1::t1, h2::t2 -> (h1, h2)::(zip t1 t2)
+    | _, _ -> raise X_syntax_error
+  ;;
+
+  let lst_last lst = List.hd (List.rev lst) ;;
+  let lst_without_last lst= List.rev (List.tl (List.rev lst));;
+
+  let rec tag_parse = function
+    | Bool(x) -> Const(Sexpr(Bool(x)))
+    | Char(x) -> Const(Sexpr(Char(x)))
+    | Number(x) -> Const(Sexpr(Number(x)))
+    | String(x) -> Const(Sexpr(String(x)))
+    | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) ->
+      If(tag_parse test, tag_parse dit, tag_parse dif)
+    | Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) ->
+      If(tag_parse test, tag_parse dit, Const(Void))
+
+    | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+    | Symbol(x) ->
+      if List.exists (fun y-> x == y) reserved_word_list then raise X_no_match
+      else Var(x)
+
+    (*variadic*)
+    (* ToDo: check that string list is actual a set (unique params) *)
+    (* ToDo: check if Pair(body,Nil) is the only case*)
+
+    | Pair(Symbol("lambda"), Pair(arglist,body)) ->
+      (match arglist with
+       | Nil -> LambdaSimple([],(body_to_expr (List.map tag_parse (scheme_list_to_ocaml_list body))))
+       | Pair(_,_) ->
+         if is_proper_lst arglist then
+           LambdaSimple(
+             (assert_list_unique (List.map (function | Symbol(e) -> e | _ -> raise X_no_match) (proper_list_to_ocaml_list arglist))),
+             (body_to_expr (List.map tag_parse (scheme_list_to_ocaml_list body)))
+           )
+         else (improper_arglist_to_lambdaOpt arglist
+                 (body_to_expr (List.map tag_parse (scheme_list_to_ocaml_list body))))
+       | Symbol(s) -> LambdaOpt([],s,(body_to_expr (List.map tag_parse (scheme_list_to_ocaml_list body))))
+       | _ -> raise X_no_match)
+
+    (* Or *)
+    |  Pair(Symbol ("or"), args) ->
+      Or(List.map tag_parse (scheme_list_to_ocaml_list args))
+
+
+    (* Define *)
+    | Pair(Symbol ("define"), Pair(Symbol(x), Pair(value,Nil))) ->
+      Def(tag_parse (Symbol(x)),tag_parse value)
+
+
+    (* set! *)
+    | Pair(Symbol ("set!"), Pair(Symbol(x), Pair(value,Nil))) ->
+      Set(tag_parse (Symbol(x)),tag_parse value)
+
+    (* begin *)
+    | Pair(Symbol ("begin"), Nil) ->
+      Const(Void)
+
+    | Pair(Symbol ("begin"), Pair(x, Nil)) ->
+      tag_parse x
+
+
+    | Pair(Symbol ("begin"),Pair(a,b)) ->
+      Seq(flatten_scheme_expr_list (List.map tag_parse (scheme_list_to_ocaml_list (Pair(a,b)))))
+
+    (*QQ*)
+    | Pair(Symbol ("quasiquote"), Pair(sexpr,Nil)) -> (macro_QQ sexpr)
+
+    (* and *)
+    | Pair(Symbol ("and"), sexpr) -> (macro_and sexpr)
+
+    (* define mit *)
+    | Pair(Symbol "define",Pair(var_and_arglist,Pair(sexprs,Nil))) ->
+      (match var_and_arglist with
+       | Pair(var, arglist) -> tag_parse (Pair(Symbol "define",Pair(var,Pair(Pair(Symbol("lambda"), Pair(arglist,Pair(sexprs,Nil))),Nil))))
+       | _ -> raise X_syntax_error)
+
+    | Pair(Symbol "let", Pair(args, body))-> macro_let args body
+
+    | Pair (Symbol("let*"), Pair(args, body)) -> macro_let_star args body
+
+    | Pair (Symbol("letrec"), Pair(args, body)) -> macro_letrec args body
+
+    | Pair (Symbol("cond"),ribs) -> macro_cond ribs
 
+    | Pair(Symbol "pset!", sexpr) -> macro_pset sexpr
+
+    (* Aplic *)
+    | Pair(proc, args) ->
+      Applic(tag_parse proc,List.map tag_parse (scheme_list_to_ocaml_list args))
+
+    | _ -> raise X_syntax_error
+
+  and macro_cond ribs =
+
+
+    let rec parse_cond ribs_2 =
+      match ribs with
+      | Nil -> Const(Void)
+
+
+      | Pair(Pair(a_sexp,Pair(Symbol("=>"),Pair(b_sexp,Nil))),Nil) ->
+        let lambdaSimple_if = LambdaSimple (["value"; "f"],If (Var "value", Applic (Applic (Var "f", []), [Var "value"]),Const Void)) in
+        Applic(lambdaSimple_if,[tag_parse a_sexp]@ [LambdaSimple([],tag_parse b_sexp)]  @[])
+
+      | Pair(Pair(a_sexp,Pair(Symbol("=>"),Pair(b_sexp,Nil))), rest_ribs) ->
+        let lambdaSimple_if = LambdaSimple (["value"; "f"; "rest"],If (Var "value", Applic (Applic (Var "f", []), [Var "value"]),Applic (Var "rest", []))) in
+        Applic(lambdaSimple_if,[tag_parse a_sexp]@ [LambdaSimple([],tag_parse b_sexp)]  @[LambdaSimple([],macro_cond rest_ribs)])
+
+      | Pair(Pair(Symbol("else"),rib),_) -> body_to_expr( List.map tag_parse (scheme_list_to_ocaml_list rib))
+      | Pair(Pair(test,dit),dif) -> If(tag_parse test ,body_to_expr( List.map tag_parse (scheme_list_to_ocaml_list dit)), macro_cond dif)
+      | _-> raise X_syntax_error in
+
+    parse_cond ribs
+
+
+  and macro_let args body =
+
+    let rec make_lambda_vars args_2 =
+      match args_2 with
+      | Nil -> Nil
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil) -> Pair(Symbol(first_var), Nil)
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) -> Pair(Symbol(first_var),make_lambda_vars rest)
+      | _-> raise X_syntax_error in
+
+    let rec make_lambda_vals args_3 =
+      match args_3 with
+      | Nil -> Nil
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil) -> Pair(first_val, Nil)
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) -> Pair(first_val,make_lambda_vals rest)
+      | _-> raise X_syntax_error in
+
+    let lambda_vars = make_lambda_vars args in
+    let lambda_vals = make_lambda_vals args in
+    let applic_vals = List.map tag_parse (scheme_list_to_ocaml_list lambda_vals) in
+
+    let lambda = tag_parse (Pair(Symbol("lambda"),Pair(lambda_vars, body))) in
+    Applic(lambda, applic_vals)
+
+  and macro_let_star args body =
+
+    let rec let_star_tag_parse =
+      match args with
+      | Nil -> macro_let args body
+      | Pair(Pair(Symbol(fisrt_var), Pair(sexp,Nil)), Nil)->  macro_let args body
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) ->
+        Applic(LambdaSimple([first_var],(tag_parse(Pair(Symbol("let*"),Pair(rest, body))))), [tag_parse first_val])
+      | _-> raise X_syntax_error in
+    let_star_tag_parse
+
+
+  and macro_letrec args body =
+
+    let rec make_lambda_vars args_1 =
+      match args_1 with
+      | Nil -> Nil
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil) -> Pair(Symbol(first_var), Nil)
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) -> Pair(Symbol(first_var),make_lambda_vars rest)
+      | _-> raise X_syntax_error in
+
+    let rec make_lambda_vals args_3 =
+      match args_3 with
+      | Nil -> Nil
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil) -> Pair(first_val, Nil)
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) -> Pair(first_val,make_lambda_vals rest)
+      | _-> raise X_syntax_error in
+
+    let rec make_sets_as_exp_list args_4 =
+      match args_4 with
+      | Nil-> []
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil)-> [Set(Var(first_var),tag_parse first_val)]
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) -> [Set(Var(first_var),tag_parse first_val)]@(make_sets_as_exp_list rest)
+      | _ -> raise X_syntax_error in
+
+    let rec make_whatever args_4 =
+      match args_4 with
+      | Nil-> Nil
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), Nil) -> Pair(Pair(Symbol(first_var), Pair(Symbol("whatever"),Nil)), Nil)
+      | Pair(Pair(Symbol(first_var), Pair(first_val,Nil)), rest) ->Pair(Pair(Symbol(first_var), Pair(Symbol("whatever"),Nil)),make_whatever rest)
+      | _ -> raise X_syntax_error in
+
+    let letrec_vars = make_lambda_vars args in
+    let letrec_vars_as_exp_list  = List.map (function | Symbol(x) -> x | _-> raise X_syntax_error) (scheme_list_to_ocaml_list letrec_vars) in
+    (*let letrec_vals = make_lambda_vals args in*)
+    let whatever_list =scheme_list_to_ocaml_list( make_lambda_vals(make_whatever args)) in
+    let whatever_list_as_exp = List.map (function | Symbol(x) -> Const (Sexpr (Symbol x)) | _-> raise X_syntax_error) whatever_list in
+    let applic_no_vars_body_ = (body_to_expr (List.map tag_parse (scheme_list_to_ocaml_list body))) in
+    let applic_no_vars = Applic(LambdaSimple([], applic_no_vars_body_),[]) in
+    let sets_list = make_sets_as_exp_list args in
+    Applic(LambdaSimple(letrec_vars_as_exp_list, (body_to_expr(sets_list @ [applic_no_vars]))),whatever_list_as_exp)
+
+
+  and macro_QQ = function
+    | Pair(Symbol "unquote",Pair(a,Nil)) -> (tag_parse a)
+    | Pair(Symbol "unquote-splicing", Pair(a,Nil)) -> (tag_parse a)
+    | Pair(Pair (Symbol "unquote-splicing",Pair(sexpr,Nil)),b) ->
+      Applic(Var "append",([tag_parse sexpr;(macro_QQ b)]))
+    | Pair(Pair (Symbol "unquote", Pair (a, Nil)),b) ->
+      Applic(Var "cons",([tag_parse a;(macro_QQ b)]))
+    | Pair(Pair(a,b),c) ->
+      Applic(Var "cons",([(macro_QQ (Pair(a,b)));(macro_QQ c)]))
+    | Pair(a,b) ->
+      Applic(Var "cons",([tag_parse (wrap_with_quote a);(macro_QQ b)]))
+    | s -> tag_parse (wrap_with_quote s)
+
+
+  and macro_and  = function
+    | Nil -> tag_parse (Bool true)
+    | Pair(a,Nil) -> tag_parse a
+    | Pair(a,b) -> If(tag_parse a,macro_and b,tag_parse (Bool false))
+    | _ -> raise X_syntax_error
+
+  and macro_pset sexpr =
+    let rec make_vars_scheme_list = function
+      | Pair(Pair(Symbol(v),_),rest) ->  (tag_parse (Symbol(v))) :: (make_vars_scheme_list rest)
+      | Nil -> [Const(Void)]
+      | _ -> raise X_syntax_error in
+    let rec make_sexprs_scheme_list = function
+      | Pair(Pair(Symbol(v),Pair(sexpr,Nil)),rest) ->  (tag_parse sexpr) :: (make_sexprs_scheme_list rest)
+      | Nil -> [Const(Void)]
+      | _ -> raise X_syntax_error in
+    (* ToDo: check if need to remove last item  *)
+    let vars_scheme_list = lst_without_last (make_vars_scheme_list sexpr) in
+    let sexprs_scheme_list = lst_without_last (make_sexprs_scheme_list sexpr) in
+    let combineAllVarsNames = list_string_to_string (List.map (function | Var(x) -> x | _ -> raise X_syntax_error) vars_scheme_list) in
+    let lambda_arglist = List.map (function | Var(x) -> Var(x ^ (String.make 1 '_')^combineAllVarsNames) | _ -> raise X_syntax_error) vars_scheme_list  in
+    let lambda_inner_body =
+      List.map (function (a,b) -> Set(a,b)) (zip vars_scheme_list lambda_arglist) in
+
+    (* let lambda_inner_body = lambda_inner_body @ [(Const(Sexpr(Bool false)))] in *)
+    (* create the expr: (not send it to tag_parse recursively)*)
+    (*reanme expr_i to expr_i_i *)
+    let lambda_arglist_str = List.map (function | Var(x) -> (x ^ (String.make 1 '_')^combineAllVarsNames) | _ -> raise X_syntax_error) vars_scheme_list in
+    let l2 = LambdaSimple(lambda_arglist_str,(body_to_expr lambda_inner_body)) in
+    let l1 = LambdaSimple([],Applic(l2,sexprs_scheme_list)) in
+    let app_pset = Applic(l1,[]) in
+    app_pset;;
+  (* let if_expr = If(app_pset,Const(Sexpr(Bool false)),Const(Void)) in *)
+  (* if_expr *)
+
+  let tag_parse_expression sexpr =
+    tag_parse sexpr;;
+
+  (* raise X_not_yet_implemented;; *)
+
+  let tag_parse_expressions sexpr =
+    List.map tag_parse_expression sexpr;;
+  (* raise X_not_yet_implemented;; *)
+
+
+end;; (* struct Tag_Parser *)
