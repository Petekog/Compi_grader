diff --git a/reader.ml b/reader.ml
index 32445c2..2d27c69 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,6 @@
 
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -40,7 +41,391 @@ let normalize_scheme_symbol str =
 	s) then str
   else Printf.sprintf "|%s|" str;;
 
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+let rec star nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (star nt s) in
+      (e :: es, s)
+  with X_no_match -> ([], s);;
 
-let read_sexprs string = raise X_not_yet_implemented;;
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+(* Parser for line comments *)
+let make_spaced nt = make_paired (star nt_whitespace) (star nt_whitespace) nt;;
+let nt_semicolon = const (fun ch -> ch == ';');;
+let newLine = char_of_int 10;;
+let endOfFile = char_of_int 4;;
+let not_endOfComment = const (fun ch -> ch != newLine && ch != endOfFile);;
+let do_nothing () = ()
+let nt_line_comments =
+  let nt = caten (nt_semicolon) (star not_endOfComment) in
+  let nt = pack (nt) (function (e1,e2) ->  do_nothing) in
+  make_spaced nt;;
+
+let nt_without_comments nt = make_paired (star nt_line_comments) (star nt_line_comments) nt;;
+let nt_without_spaces_and_comments nt = nt_without_comments (make_spaced nt);;
+
+(* Parser for Sexpr comments *)
+
+(* This section represnting parse for: ⟨Boolean⟩ ::= #f | #t *)
+let nt_ladder = const (fun ch -> ch == '#');;
+(* The parser below should parse ('t' or 'T' as 't') + ('f' or 'F' as 'f') *)
+let nt_boolsign = const (fun ch ->  (lowercase_ascii ch) == 't' || (lowercase_ascii ch) == 'f');;
+
+(* Pre-condition -> 't' or 'f' as an argument *)
+let char_to_bool c = if c == 't' then true else false;;
+
+let nt_bool =
+  let nt = caten (nt_ladder) (nt_boolsign) in
+  let nt = pack nt (function (e,t) -> Bool(char_to_bool (lowercase_ascii t))) in
+  nt_without_spaces_and_comments nt;;
+
+(* This section represnting parse for :
+  ⟨Char⟩ ::= ⟨CharPrefix⟩ ( ⟨VisibleSimpleChar⟩ | ⟨NamedChar⟩) *)
+let nt_slash = const (fun ch -> ch == '\\');;
+let char_prefix = caten (nt_ladder) (nt_slash);;
+let nt_visibleSimpleChar = const (fun ch -> ch >= ' ');;
+let nt_namedChar_nul = word_ci "nul";;
+let nt_namedChar_newline = word_ci "newline";;
+let nt_namedChar_return = word_ci "return";;
+let nt_namedChar_tab = word_ci "tab";;
+let nt_namedChar_page = word_ci "page";;
+let nt_namedChar_space = word_ci "space";;
+let nt_namedChar = disj_list [nt_namedChar_nul; nt_namedChar_newline; nt_namedChar_return; nt_namedChar_tab; nt_namedChar_page; nt_namedChar_space];;
+
+(* Pre-condition -> This function get string as an argument *)
+let convert_namedChar_to_asci st = 
+  match (String.lowercase_ascii st) with
+  | "nul" -> (char_of_int 0)
+  | "newline" -> (char_of_int 10)
+  | "return" -> (char_of_int 13)
+  | "tab" -> (char_of_int 9)
+  | "page" -> (char_of_int 12)
+  | "space" -> (char_of_int 32)
+  | _ -> raise X_not_yet_implemented;; 
+
+  let nt_char_visibleSimpleChar =
+    (* let nt = caten nt_visibleSimpleChar (nt_whitespace) in *)
+    let nt = caten (char_prefix) nt_visibleSimpleChar in
+    let nt = pack (nt)
+              (function ((c1,c2),c3) -> c3) in
+    nt;;
+    
+  let nt_char_namedChar =
+    (* let nt = caten nt_namedChar (nt_whitespace) in *)
+    let nt = caten (char_prefix) nt_namedChar in
+    let nt = pack (nt)
+              (function ((c1,c2),lst) -> convert_namedChar_to_asci((list_to_string)lst)) in
+    nt;;
+    
+  let nt_char =
+    let nt = disj nt_char_namedChar nt_char_visibleSimpleChar in
+    let nt = pack (nt) (function (finalretchar) -> Char(finalretchar)) in
+    nt_without_spaces_and_comments nt;;
+
+  let nt_not_symbol_letter = plus (range_ci 'A' 'Z');;
+  let nt_not_symbol_nonCapitalLetters = plus (range_ci 'a' 'z');;
+  let nt_not_dollarSign = word_ci "$";;
+  let nt_not_exclamationMark = word_ci "!";;
+  let nt_not_power = word_ci "^";;
+  let nt_not_symbolAsterik = word_ci "*";;
+  let nt_not_symbolDash = word_ci "-";;
+  let nt_not_bottomMark = word_ci "_";;
+  let nt_not_equal = word_ci "=";;
+  let nt_not_plus = word_ci "+";; 
+  let nt_not_greaterThan = word_ci "<";;
+  let nt_not_lowerThan = word_ci ">";;
+  let nt_not_questionMark = word_ci "?";;
+  let nt_not_symbolSlash = word_ci "/";;
+  let nt_not_doublePoint = word_ci "::";; 
+  let nt_not_followed_by_symbol_sign = disj_list [nt_not_symbol_letter; nt_not_symbol_nonCapitalLetters;
+                                                  nt_not_dollarSign; nt_not_exclamationMark; nt_not_power; nt_not_symbolAsterik; nt_not_symbolDash;
+                                                  nt_not_bottomMark; nt_not_equal; nt_not_plus; nt_not_greaterThan; nt_not_lowerThan; nt_not_questionMark;
+                                                  nt_not_symbolSlash; nt_not_doublePoint]
+
+  let make_nt_digit ch_from ch_to displacement =
+    let nt = const (fun ch -> ch_from <= ch && ch <= ch_to) in
+    let nt = pack nt (let delta = (Char.code ch_from) - displacement in
+          fun ch -> (Char.code ch) - delta) in
+    nt;;
+  
+  let nt_digit = make_nt_digit '0' '9' 0;;
+  let nt_natural =
+    let nt = plus nt_digit in
+    let nt = pack nt (fun digits -> List.fold_left (fun a b -> 10 * a + b) 0 digits) in
+    nt;;
+
+  let nt_natural_after_point =
+    let nt = plus nt_digit in
+    let nt = pack nt (fun digits -> List.fold_right (fun a b -> ((float_of_int a) +. b) /. 10.0) digits 0.0) in
+    nt;; 
   
+  let nt_plus = const (fun ch -> ch == '+');;
+  let nt_minus = const (fun ch -> ch == '-');;
+  let nt_number_sign = disj nt_plus nt_minus;;
+  let convert_num_with_sign sign naturalNum =
+    if sign == '+' then naturalNum
+    else (naturalNum * (-1));;
+  
+  let nt_integer_with_sign =
+    let nt = caten nt_number_sign nt_natural in
+    let nt = pack nt (function (sign,naturalNum) -> (convert_num_with_sign sign naturalNum)) in
+    nt;;
+  
+  let nt_integer =
+    let nt = disj nt_integer_with_sign nt_natural in
+    let nt = pack (nt) (function (finalretInteger) -> (finalretInteger,1)) in
+    make_spaced nt;;
+
+  let nt_integer_exclusive =
+    let nt = disj nt_integer_with_sign nt_natural in
+    let nt = pack (nt) (function (finalretInteger) -> Number(Fraction(finalretInteger,1))) in
+    make_spaced nt;;
+
+  let rec gcd a b =
+      if a = b then a
+      else if a > b then gcd (a - b) b
+      else gcd a (b - a);;
+
+  let nt_right_slash = const (fun ch -> ch == '/');;
+  let nt_fraction = 
+    let nt = caten nt_right_slash nt_natural in
+    let nt = caten nt_integer nt in 
+    let nt = pack nt (function ((counter,_),(slash,denominator)) ->
+      let gcd = gcd (abs denominator) (abs counter) in
+      Number (Fraction(counter / gcd, denominator / gcd))) in
+      make_spaced nt;;
+
+  let nt_dot = const (fun ch -> ch == '.');;
+  let nt_float = 
+    let nt = caten nt_dot nt_natural_after_point in
+    let nt = caten nt_integer nt in 
+    let nt = pack nt (function ((counter,_),(dot,mantista)) ->
+      if counter < 0 then Number (Float ((float_of_int)counter +. (mantista *. (-1.0)))) else
+      Number (Float((float_of_int)counter +. mantista))) in
+      make_spaced nt;;
+
+  let nt_helper_convert_to_float num = match num with
+  | Number(Float(num)) -> num
+  | Number(Fraction(counter,denominator)) -> float_of_int(counter)
+  | _ -> raise X_no_match;;
+
+  let nt_scientific_sign = const (fun ch -> ch == 'e' || ch == 'E');;
+  let nt_scientific_notation = 
+    let nt = disj (nt_float) (nt_integer_exclusive) in
+    let nt = caten (nt) (nt_scientific_sign) in
+    let nt = caten (nt) (nt_integer_exclusive) in
+    let nt = pack (nt) (function ((num,e),power) -> Number(Float((nt_helper_convert_to_float(num)) *. (10.0 ** (nt_helper_convert_to_float power))))) in
+    nt;;
+
+  let nt_number =
+    let nt = disj_list [nt_scientific_notation; nt_fraction; nt_float] in
+    let nt = disj nt nt_integer_exclusive in
+    let nt = pack (nt) (function (finalnum) -> finalnum) in
+    nt_without_spaces_and_comments (not_followed_by (nt) (nt_not_followed_by_symbol_sign));;
+
+  (* This section represnting parse for :
+  ⟨String⟩ ::= " ⟨StringChar⟩∗ "gsi
+  ⟨StringChar⟩ ::= ⟨StringLiteralChar⟩ | ⟨StringMetaChar⟩ *)
+
+  let nt_apostrophe = const (fun ch -> ch == '\"');;
+  let nt_stringMetaChar_t = char_ci 't';;
+  let nt_stringMetaChar_n = char_ci 'n';;
+  let nt_stringMetaChar_f = char_ci 'f';;
+  let nt_stringMetaChar_r = char_ci 'r';;
+  let nt_stringMetaChar_apostrophe = char_ci '"';;
+  let nt_stringMetaChar_backslash = char_ci '\\';;
+  let nt_stringMetaChar = disj_list [nt_stringMetaChar_t; nt_stringMetaChar_n; nt_stringMetaChar_f; nt_stringMetaChar_r; nt_stringMetaChar_apostrophe; nt_stringMetaChar_backslash];;
+
+let convert_stringMetaChar_to_asci ch = 
+  match ch with
+  | 'r' | 'R' -> (char_of_int 13)
+  | 'n' | 'N' -> (char_of_int 10)
+  | 't' | 'T' -> (char_of_int 9)
+  | 'f' | 'F' -> (char_of_int 12)
+  | '\\' -> (char_of_int 92)
+  | '"' -> (char_of_int 34)
+  | _ -> raise X_not_yet_implemented;;
+
+  let nt_string_metaChar =
+    (* let nt = caten (nt_stringMetaChar) (nt_whitespace) in *)
+    let nt = caten (nt_stringMetaChar_backslash) (nt_stringMetaChar) in
+    let nt = pack (nt)
+              (function (c1,metaChar) -> convert_stringMetaChar_to_asci(metaChar)) in
+    nt;;
+
+  let nt_stringLiteralChar = const (fun ch -> (ch != '\"') && (ch != '\\'));;
+  let nt_stringChar = disj (nt_stringLiteralChar) (nt_string_metaChar) ;;
+
+  let make_paired nt_left nt_right nt =
+    let nt = caten nt_left nt in
+    let nt = pack nt (function (_, e) -> e) in
+    let nt = caten nt nt_right in
+    let nt = pack nt (function (e, _) -> e) in
+    nt;;  
+
+  let nt_string_star = star nt_stringChar 
+  let nt_string =
+    let nt = pack (make_paired (nt_apostrophe) (nt_apostrophe) nt_string_star) (fun st -> String(list_to_string st)) in
+    nt_without_spaces_and_comments nt;;
+
+  (* This section represnting parse for :
+  ⟨Symbol⟩ ::= ⟨SymbolCharNoDot⟩ | ⟨SymbolChar⟩
+  ⟨SymbolChar⟩
+  +
+  ⟨SymbolChar⟩ ::= ⟨SymbolCharNoDot⟩ | ⟨Dot⟩
+  ⟨SymbolCharNoDot⟩ ::= (0 | · · · | 9) | (a | · · · | z) | (A | · · · | Z) | ! | $
+  | ^ | * | - | _ | = | + | < | > | ? | / | :
+  ⟨Dot⟩ ::= .                              *)
+  
+  let nt_dot = const (fun ch -> ch == '.');;
+  let nt_symbol_number = range_ci '0' '9';;
+  let nt_symbol_capitlLetters = range_ci 'A' 'Z';;
+  let nt_symbol_nonCapitalLetters = range_ci 'a' 'z';;
+  let nt_dollarSign = const (fun ch -> ch == '$');;
+  let nt_exclamationMark = const (fun ch -> ch == '!');;
+  let nt_power = const (fun ch -> ch == '^');;
+  let nt_symbolAsterik = const (fun ch -> ch == '*');;
+  let nt_symbolDash = const (fun ch -> ch == '-');;
+  let nt_bottomMark = const (fun ch -> ch == '_');;
+  let nt_equal = const (fun ch -> ch == '=');;
+  let nt_plus = const (fun ch -> ch == '+');;
+  let nt_greaterThan = const (fun ch -> ch == '<');;
+  let nt_lowerThan = const (fun ch -> ch == '>');;
+  let nt_questionMark = const (fun ch -> ch == '?');;
+  let nt_symbolSlash = const (fun ch -> ch == '/');;
+  let nt_doublePoint = const (fun ch -> ch == ':');;
+  let nt_SymbolCharNoDot = disj_list [nt_symbol_number; nt_symbol_capitlLetters; nt_symbol_nonCapitalLetters; nt_dollarSign; nt_exclamationMark; nt_power;
+                                      nt_symbolAsterik; nt_symbolDash; nt_bottomMark; nt_equal; nt_plus; nt_greaterThan; nt_lowerThan; nt_questionMark;
+                                      nt_symbolSlash; nt_doublePoint];;
+  let nt_symbolChar = disj (nt_SymbolCharNoDot) (nt_dot);;
+
+  let nt_symbol_plus =
+    let nt = plus nt_symbolChar in
+    let nt = caten nt_symbolChar nt in
+    let nt = pack (nt) (function (e1,e2) -> (list_to_string (e1::e2))) in
+    nt;;
+
+  let char_to_string ch = list_to_string[ch];;
+  
+  let nt_symbol =
+    let nt = pack (nt_SymbolCharNoDot) (function (ch) -> (char_to_string(ch))) in
+    let nt = disj (nt_symbol_plus) nt in
+    let nt = pack (nt) (function (sym) -> (Symbol(String.lowercase_ascii sym))) in
+    nt_without_spaces_and_comments nt;;
+  
+  (* This section represnting parse for Nil *)
+  let nt_sexpr_comments_sign = word "#;";;
+  let nt_lparen = const (fun ch -> ch == '(');;
+  let nt_rparen = const (fun ch -> ch == ')');;
+  let nt_nil =
+    let nt_lparen_exp = nt_without_spaces_and_comments nt_lparen in
+    let nt_rparen_exp = nt_without_spaces_and_comments nt_rparen in
+    let nt = caten (nt_lparen_exp) (nt_rparen_exp) in
+    let nt = pack (nt) (function (e1,e2) -> Nil) in
+    nt;;
+
+  (* This section represnting parse for sexp *)
+  let nt_paranthesized nt =
+    make_paired (make_spaced (nt_lparen)) (make_spaced (nt_rparen)) nt;;
+  
+  let nt_quote_mark = const (fun ch -> ch == (char_of_int 39));;
+  let nt_quasi_quoted_mark = const (fun ch -> ch == (char_of_int 96));;
+  let nt_comma = const (fun ch -> ch == (char_of_int 44));;
+  let nt_strudel = const (fun ch -> ch == (char_of_int 64));;
+  let nt_dot_without_spaces = (make_spaced nt_dot);;
+
+  let rec nt_list_as_pairs = fun sexpsLst -> match sexpsLst with
+  | h :: t when (List.length sexpsLst) > 1 -> Pair(h, (nt_list_as_pairs t))
+  | h :: [] when (List.length sexpsLst) = 1 -> Pair(h,Nil)
+  | _ -> raise X_no_match;;
+   
+  let final_exp =
+    let rec nt_sexp exp = disj_list [nt_bool; nt_nil; nt_number; nt_char; nt_string; nt_symbol; nt_quote_like_forms;
+                          nt_dotted_list; nt_list; nt_line_comments_internal; nt_sexp_comments; nt_all_exp_with_sexpr_comments] exp;
+
+    and nt_sexp_eval exp =
+      let sexp_without_parens = pack (star nt_sexp) (fun exp -> exp) in
+      (* List.fold_right (fun sexp acc -> 
+      match sexps with
+      | head::[] -> sexp
+      | head  -> Pair(sexp, acc)) (sexps) Nil) in *)
+      let sexp_with_parens = (nt_paranthesized sexp_without_parens) in
+      let nt = (disj sexp_without_parens sexp_with_parens) in
+      (nt_without_spaces_and_comments nt) exp;
+      
+    and nt_all_exp_with_sexpr_comments exp =
+      let nt = (pack (plus (caten (nt_sexpr_comments_sign) nt_sexp))) (fun (expsLst) -> Nil) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_sexp_comments exp =
+      let nt = (caten nt_sexpr_comments_sign nt_sexp) in
+      let nt = pack (nt) (fun (commentSign, e) -> e) in
+      let nt = pack (caten nt nt_sexp) (fun (e1, e2) -> e2) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_line_comments_internal exp =
+      let nt = (pack (plus nt_line_comments) (fun exp -> Nil)) in
+      (nt_without_spaces_and_comments nt) exp;  
+
+    (* This section represnting parse for Quote-like forms:
+      ⟨List⟩ ::= ( ⟨Sexpr⟩∗ )
+      ⟨DottedList⟩ ::= ( ⟨Sexpr⟩+ . ⟨Sexpr⟩ ) *)
+
+    and nt_list exp =
+      let nt = star (make_spaced nt_sexp) in
+      let nt = make_paired (nt_lparen) (nt_rparen) nt in
+      let nt = pack (nt) (fun sexps -> (nt_list_as_pairs sexps)) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_dotted_list exp =
+      let nt = caten (nt_dot_without_spaces) (nt_sexp) in
+      let nt = caten (plus nt_sexp) nt in 
+      let nt = make_paired (nt_lparen) (nt_rparen) nt in
+      let nt = pack (nt) (fun (sexp1,(dot,sexp2)) ->
+      List.fold_right (fun sexp acc -> Pair(sexp, acc)) sexp1 sexp2) in
+      (* let nt = pack (nt) (fun (sexp1,(dot,sexp2)) -> match sexp2 with
+      | Nil -> List.fold_right (fun sexp acc -> Pair(sexp, acc)) sexp1 Nil
+      | sexp2 -> List.fold_right (fun sexp acc -> Pair(sexp, acc)) (List.append sexp1 [sexp2]) Nil) in *)
+      (nt_without_spaces_and_comments nt) exp;
+
+    (* This section represnting parse for Quote-like forms:
+    ⟨Quoted⟩ ::= ' ⟨Sexpr⟩
+    ⟨QQuoted⟩ ::= ` ⟨Sexpr⟩
+    ⟨Unquoted⟩ ::= , ⟨Sexpr⟩
+    ⟨UnquotedSpliced⟩ ::= ,@ ⟨Sexpr⟩ *)
+
+    and nt_quoted exp =  
+      let nt = caten (nt_quote_mark) nt_sexp in
+      let nt = pack (nt) (function (e1,e2) -> Pair(Symbol("quote"),Pair(e2,Nil))) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_quasi_quoted exp = 
+      let nt = caten (nt_quasi_quoted_mark) nt_sexp in
+      let nt = pack (nt) (function (e1,e2) -> Pair(Symbol("quasiquote"),Pair(e2,Nil))) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_unquoted exp = 
+      let nt = caten (nt_comma) nt_sexp in
+      let nt = pack (nt) (function (e1,e2) -> Pair(Symbol("unquote"),Pair(e2,Nil))) in
+      (nt_without_spaces_and_comments nt) exp;
+
+    and nt_unquoteAndSpliced exp = 
+      let nt = caten (nt_comma) (nt_strudel) in
+      let nt = caten nt nt_sexp in
+      let nt = pack (nt) (function ((e1,e2),e3) -> Pair(Symbol("unquote-splicing"),Pair(e3,Nil))) in
+      (nt_without_spaces_and_comments nt) exp;
+    
+    and nt_quote_like_forms exp = disj_list[nt_quoted; nt_quasi_quoted; nt_unquoted; nt_unquoteAndSpliced] exp in
+    nt_sexp_eval;;
+
+  let read_sexprs string =
+    let (e1,e2) = final_exp (string_to_list string) in
+    e1;;
+
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..9cd0e71 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,4 @@
+Nir Rashti - 313266348
+Eden Salansky - 315357806
+
+We assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the Internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction.
\ No newline at end of file
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..ecde411 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -69,17 +69,165 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let rec find_index_in_params_lst exp params_list = match params_list with
+  | [] -> -1
+  | h :: t -> if exp = h then 0 else 1 + (find_index_in_params_lst exp t);;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+let rec find_indexes_in_lex_env exp env_lst lex_env_number = match env_lst with
+  | [] -> (-1, -1)
+  | h :: t -> (if (List.mem exp h) then (lex_env_number, (find_index_in_params_lst exp h))
+               else (find_indexes_in_lex_env exp t (lex_env_number + 1)));;
 
-let box_set e = raise X_not_yet_implemented;;
+let rec get_tuple_of_last_exp_with_rest_lst exps =
+  let list_reverse = (List.rev exps) in  
+  ((List.hd list_reverse), (List.rev (List.tl list_reverse)));;
+
+
+let rec create_annotate_lexical_addresses env_lst params_lst expr = match expr with
+  | Const(exp) -> Const'(exp)
+  | Var(exp) -> (if(List.mem exp params_lst) then
+                  Var'(VarParam(exp, (find_index_in_params_lst exp params_lst)))
+                  else match (find_indexes_in_lex_env exp env_lst 0) with
+                  | (-1,-1) -> Var'(VarFree(exp))
+                  | (major, minor) -> Var'(VarBound(exp, major, minor)))
+  | If(test, dit, dif) -> If'((create_annotate_lexical_addresses env_lst params_lst test), (create_annotate_lexical_addresses env_lst params_lst dit), (create_annotate_lexical_addresses env_lst params_lst dif)) 
+  | Seq(exp_lst) -> Seq'(List.map (create_annotate_lexical_addresses env_lst params_lst) exp_lst)
+  | Set(var,exp) -> (match (create_annotate_lexical_addresses env_lst params_lst var) with
+                    | Var'(variable) -> Set'(variable, (create_annotate_lexical_addresses env_lst params_lst exp))
+                    | _  -> raise X_this_should_not_happen)
+  | Def(var,exp) -> (match (create_annotate_lexical_addresses env_lst params_lst var) with
+                    | Var'(variable) -> Def'(variable, (create_annotate_lexical_addresses env_lst params_lst exp))
+                    | _  -> raise X_this_should_not_happen)
+  | Or(exp_lst) -> Or'(List.map (create_annotate_lexical_addresses env_lst params_lst) exp_lst)
+  | LambdaSimple(str_lst,exp) -> (match params_lst with
+                                  | [] -> LambdaSimple'(str_lst, (create_annotate_lexical_addresses (List.append [params_lst] env_lst) str_lst exp))
+                                  | _ -> LambdaSimple'(str_lst, (create_annotate_lexical_addresses (List.append [params_lst] env_lst) str_lst exp)))
+  | LambdaOpt(str_lst,st,exp) -> (match params_lst with
+                                  | [] -> LambdaOpt'(str_lst, st, (create_annotate_lexical_addresses (List.append [params_lst] env_lst) (List.append str_lst [st]) exp))
+                                  | _ -> LambdaOpt'(str_lst, st, (create_annotate_lexical_addresses (List.append [params_lst] env_lst) (List.append str_lst [st]) exp)))
+  |  Applic(operator,rands) -> Applic'((create_annotate_lexical_addresses env_lst params_lst operator), (List.map(create_annotate_lexical_addresses env_lst params_lst) rands))
+  
+let rec create_tail_calls tp expr = match expr with
+  | Const'(exp) -> Const'(exp)
+  | Var'(exp) -> Var'(exp)
+  | If'(test, dit, dif) -> If' ((create_tail_calls false test), (create_tail_calls tp dit), (create_tail_calls tp dif))
+  | Seq'(exp_lst) -> let (last_element , exps_without_last_element) = (get_tuple_of_last_exp_with_rest_lst exp_lst) in
+                      Seq'((List.append (List.map (create_tail_calls false) exps_without_last_element) [(create_tail_calls true last_element)]))
+  | Set'(variable,exp) -> Set'(variable,(create_tail_calls false exp))
+  | Def'(var,exp) -> Def'(var,(create_tail_calls false exp))
+  | Or'(exps) -> let (last_element , exps_without_last_element) = (get_tuple_of_last_exp_with_rest_lst exps) in
+                  Or'((List.append (List.map (create_tail_calls false) exps_without_last_element) [(create_tail_calls true last_element)]))
+  | LambdaSimple'(params, body) -> LambdaSimple'(params, (create_tail_calls true body))
+  | LambdaOpt'(params, st, body) -> LambdaOpt'(params,st,(create_tail_calls true body))
+  | Applic'(operator,rands) -> (if tp then ApplicTP'((create_tail_calls false operator), (List.map (create_tail_calls false) rands))
+                                else Applic'((create_tail_calls false operator), (List.map (create_tail_calls false) rands)))
+  | ApplicTP'(operator,rands) -> ApplicTP'((create_tail_calls false operator), (List.map (create_tail_calls false) rands))
+  | _ -> raise X_this_should_not_happen
+
+let is_boxing_should_happen read_array write_array =
+  let first read_num = (List.filter (fun write_num -> write_num != read_num) write_array) in
+  let second = (List.map (fun read_num -> (List.length (first read_num)) > 0) read_array) in
+  (List.fold_right (fun acc value -> (acc || value)) second false);;
+
+let add_first_box_exp body param minor= (match body with
+  | Seq'(Set'(VarParam(param_un_known, minor_un_known), Box'(VarParam(param_un_known_2,minor_un_known_2))) :: rest_exps) when (param_un_known = param_un_known_2) && (minor_un_known = minor_un_known_2) ->
+    Seq'(List.append [Set'(VarParam(param, minor), Box'(VarParam(param,minor))); Set'(VarParam(param_un_known, minor_un_known), Box'(VarParam(param_un_known_2,minor_un_known_2)))] rest_exps) 
+  | Seq'(exps) -> Seq'([Set'(VarParam(param, minor), Box'(VarParam(param,minor))); body])
+  | _ -> Seq'(List.append [Set'(VarParam(param, minor), Box'(VarParam(param,minor)))] [body]));;
+
+let rec create_box_exp expr = match expr with
+  | Const'(exp) -> Const'(exp)
+  | Var'(exp) -> Var'(exp)
+  | If'(test, dit, dif) -> If' ((create_box_exp test), (create_box_exp dit), (create_box_exp dif))
+  | Seq'(exp_lst) -> Seq'(List.map create_box_exp exp_lst)
+  | Set'(variable,exp) -> Set'(variable,(create_box_exp exp))
+  | Def'(var,exp) -> Def'(var,(create_box_exp exp))
+  | Or'(exps) -> Or'(List.map create_box_exp exps)
+  | LambdaSimple'(params, body) -> LambdaSimple'(params, (create_box_exp (lookup_for_boxing (List.rev params) body (List.length params-1))))
+  | LambdaOpt'(params, st, body) -> LambdaOpt'(params,st,(create_box_exp (lookup_for_boxing (List.rev params) body (List.length params-1))))
+  | Applic'(operator,rands) -> Applic' ((create_box_exp operator), (List.map create_box_exp rands))
+  | ApplicTP'(operator,rands) -> ApplicTP' ((create_box_exp operator), (List.map create_box_exp rands))
+  | Box'(var) -> Box'(var) 
+  | BoxGet'(var) -> BoxGet'(var)
+  | BoxSet'(var, exp) -> BoxSet'(var, (create_box_exp exp))
+
+and param_read_write_occurences param clousre_index read_array write_array body = match body with
+  | Const'(exp) -> Const'(exp)
+  | Var'(variable) -> (match variable with
+                      | VarParam(var_name, index_of_param) when var_name = param -> read_array:= (List.append !read_array [clousre_index]); Var'(variable)
+                      | VarBound(var_name, major, minor) when var_name = param -> read_array:= (List.append !read_array [clousre_index]); Var'(variable)
+                      | _ -> Var'(variable))
+  | If'(test, dit, dif) -> If' ((param_read_write_occurences param clousre_index read_array write_array test), (param_read_write_occurences param clousre_index read_array write_array dit),
+                                (param_read_write_occurences param clousre_index read_array write_array dif))
+  | Seq'(exp_lst) -> Seq'(List.map (param_read_write_occurences param clousre_index read_array write_array) exp_lst)
+  | Def'(var,exp) -> Def'(var,(param_read_write_occurences param clousre_index read_array write_array exp))
+  | Or'(exps) -> Or'(List.map (param_read_write_occurences param clousre_index read_array write_array) exps)
+  | Set'(variable,exp) -> (match variable with
+                          | VarBound(var_name, major, minor) when var_name = param -> write_array:= (List.append !write_array [clousre_index]);
+                                                                                      Set'(variable,(param_read_write_occurences param clousre_index read_array write_array exp))
+                          | VarParam(var_name, index) when var_name = param -> write_array:= (List.append !write_array [clousre_index]);
+                                                      Set'(variable,(param_read_write_occurences param clousre_index read_array write_array exp))
+                          | _ -> Set'(variable, (param_read_write_occurences param clousre_index read_array write_array exp))) 
+  | LambdaSimple'(params, body) -> (if (List.mem param params) then LambdaSimple'(params, body)
+                                    else LambdaSimple'(params, (param_read_write_occurences param (clousre_index + 1) read_array write_array body))) 
+  | LambdaOpt'(params, st, body) -> (if (List.mem param (List.append params [st])) then LambdaOpt'(params, st, body)
+                                     else LambdaOpt'(params, st, (param_read_write_occurences param (clousre_index + 1) read_array write_array body))) 
+  | Applic'(operator,rands) -> Applic' ((param_read_write_occurences param clousre_index read_array write_array operator),
+                                        (List.map (param_read_write_occurences param clousre_index read_array write_array) rands))
+  | ApplicTP'(operator,rands) -> ApplicTP'((param_read_write_occurences param clousre_index read_array write_array operator),
+                                           (List.map (param_read_write_occurences param clousre_index read_array write_array) rands))
+  | Box'(var) -> Box'(var) 
+  | BoxGet'(var) -> BoxGet'(var)
+  | BoxSet'(var, exp) -> BoxSet'(var, (param_read_write_occurences  param clousre_index read_array write_array exp));
+
+and actual_boxing param body = match body with
+  | Const'(exp) -> Const'(exp)
+  | Var'(variable) -> (match variable with
+                      | VarParam(var_name, index_of_param) when var_name = param -> BoxGet'(variable)
+                      | VarBound(var_name, major, minor) when var_name = param -> BoxGet'(variable) 
+                      | _ -> Var'(variable))
+  | If'(test, dit, dif) -> If' ((actual_boxing param test), (actual_boxing param dit), (actual_boxing param dif))
+  | Seq'(exp_lst) -> Seq'(List.map (actual_boxing param) exp_lst)
+  | Def'(var,exp) -> Def'(var,(actual_boxing param exp))
+  | Or'(exps) -> Or'(List.map (actual_boxing param) exps)
+  | Set'(variable,exp) -> (match variable with
+                          | VarBound(var_name, major, minor) when var_name = param -> BoxSet'(VarBound(var_name, major, minor), (actual_boxing param exp))
+                          | VarParam(var_name, index) when var_name = param -> BoxSet'(VarParam(var_name, index), (actual_boxing param exp))
+                          | _ -> Set'(variable, (actual_boxing param exp)))
+  | LambdaSimple'(params, body) -> (if (List.mem param params) then LambdaSimple'(params, body)
+                                    else LambdaSimple'(params, (actual_boxing param body))) 
+  | LambdaOpt'(params, st, body) -> (if (List.mem param (List.append params [st])) then LambdaOpt'(params, st, body)
+                                    else LambdaOpt'(params, st, (actual_boxing param body))) 
+  | Applic'(operator,rands) -> Applic' ((actual_boxing param operator), (List.map (actual_boxing param) rands))
+  | ApplicTP'(operator,rands) -> ApplicTP'((actual_boxing param operator), (List.map (actual_boxing param) rands))
+  | Box'(var) -> Box'(var) 
+  | BoxGet'(var) -> BoxGet'(var)
+  | BoxSet'(var, exp) -> BoxSet'(var, (actual_boxing param exp));
+
+and lookup_for_boxing paramas body index = match paramas with
+  | h :: t -> (lookup_for_boxing t (param_boxing body h index) (index - 1))
+  | [] -> body;
+  
+and param_boxing body param minor =
+  let read_array = ref [] in
+  let write_array = ref [] in
+  let un_used = (param_read_write_occurences param 0 read_array write_array body) in
+  let boxing_boolean = (is_boxing_should_happen !read_array !write_array) in
+  (if boxing_boolean then (add_first_box_exp (actual_boxing param body) param minor)
+                     else un_used);;
+
+let annotate_lexical_addresses e = create_annotate_lexical_addresses [] [] e;;
+
+let annotate_tail_calls e = create_tail_calls false e;;
+ 
+let box_set e = create_box_exp e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
-end;; (* struct Semantics *)
+         
+end;;
+ (* struct Semantics *)
 
 
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..2c000a6 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -58,8 +58,184 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+(* let tag_parse_expressions sexpr = raise X_not_yet_implemented;; *)
 
+let not_reserved_word st = not (List.mem st reserved_word_list);;
+
+let rec pair_to_list pairs = match pairs with
+| Pair(Symbol(x),Nil) -> x :: []
+| Pair(Symbol(x),y) -> x :: (pair_to_list y)
+| _ -> raise X_this_should_not_happen;;
+
+let rec tag_parser_improper_args arguments = match arguments with
+| Pair(Symbol(x), Pair(y, w)) -> x :: (tag_parser_improper_args (Pair(y, w)))
+| Pair(Symbol(x), Symbol(w)) -> x :: []
+| _ -> raise X_this_should_not_happen;;
+
+let rec tag_parser_get_arg arguments = match arguments with
+| Pair(Symbol(x), Pair(y, w)) -> (tag_parser_get_arg (Pair(y, w)))
+| Pair(Symbol(x), Symbol(y)) -> y
+| _ -> raise X_this_should_not_happen;;
+
+let rec check_whether_is_not_proper_list lst = match lst with
+| Nil -> false
+| Pair(x,y) -> (check_whether_is_not_proper_list y)
+| _ -> true;;
+
+
+let rec validArguments lst = match lst with
+| [] -> true
+| head :: [] -> true
+| head :: tail when (List.mem head tail) -> false
+| head :: tail -> (validArguments tail);;
+
+let makeSeq lst = match lst with
+| head :: [] -> head
+| _ -> Seq(lst);;
+
+(* TODO: Make sure if we should support on quasiquote expansion vector*)
+(* TODO: Bugfix (The input: "3 eden") raise incorrect output (Not succeeding to parse Number), so we should remove make_spaced from nt_xxxxx (which relative to nt_number) *)
   
-end;; (* struct Tag_Parser *)
+let rec tag_parse_exp = function
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | String(x) -> Const(Sexpr(String(x)))
+  | Symbol(st) when (not_reserved_word st) -> Var(st) 
+  | Pair(Symbol("begin"), Nil) -> Const(Void)
+  | Pair(Symbol("begin"), Pair(y,Nil)) -> (tag_parse_exp y)
+  | Pair(Symbol("begin"), y) -> makeSeq((build_seq y))    
+  | Pair(Symbol("set!"), Pair(y,Pair(exp,Nil))) -> Set((tag_parse_exp y),(tag_parse_exp exp))
+  | Pair(Symbol("pset!"), psetExp) -> (tag_parse_pset psetExp)   
+  | Pair(Symbol("define"), Pair(Symbol(y),Pair(exp,Nil))) when (not_reserved_word y) -> Def(Var(y),(tag_parse_exp exp))
+  | Pair(Symbol("define"), Pair(Pair(Symbol(variable), argslist),body)) -> (tag_parse_exp (tag_parse_define_mit_exp variable argslist body))
+  | Pair(Symbol("or"),Nil) -> Const(Sexpr(Bool(false)))
+  | Pair(Symbol("or"),Pair(y,Nil)) -> (tag_parse_exp y)
+  | Pair(Symbol("or"), sexpsPairs) -> Or((pair_to_list_exp sexpsPairs))
+  | Pair(Symbol "lambda", Pair(Symbol(x), body)) -> LambdaOpt([], x, makeSeq(pair_to_list_exp_without_begin body))
+  | Pair(Symbol "lambda", Pair(args, body)) when ((check_whether_is_not_proper_list args) && (validArguments (tag_parser_improper_args args)))->
+      LambdaOpt((tag_parser_improper_args args), (tag_parser_get_arg args), makeSeq(pair_to_list_exp_without_begin body))
+  | Pair(Symbol "lambda", Pair(Nil, body)) -> LambdaSimple([],makeSeq(pair_to_list_exp_without_begin body))
+  | Pair(Symbol "lambda", Pair(args, body)) when (validArguments (pair_to_list args))-> LambdaSimple((pair_to_list args),makeSeq(pair_to_list_exp_without_begin body))
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) -> If(tag_parse_exp test, (tag_parse_exp dit), (tag_parse_exp dif))
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) ->  If(tag_parse_exp test, (tag_parse_exp dit), Const(Void))
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("unquote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("quasiquote"), Pair(exp,Nil)) -> (tag_parse_exp (tag_quasiquote exp))
+  | Pair(Symbol("let"),letExp) -> (tag_parse_let letExp)
+  | Pair(Symbol("let*"),letStarExp) -> tag_parse_exp (tag_parse_let_star letStarExp)
+  | Pair(Symbol("letrec"), letRecExp) -> tag_parse_exp (tag_parse_let_rec letRecExp)
+  | Pair(Symbol("and"), Nil) -> Const(Sexpr(Bool(true)))
+  | Pair(Symbol("and"), Pair(exp,Nil)) -> (tag_parse_exp exp)
+  | Pair(Symbol("and"), exps) -> (tag_parse_exp (tag_parse_and_exp exps))
+  | Pair (Symbol("cond"), condExp) -> (tag_parse_exp (tag_parse_cond_exp condExp))
+  | Pair(operator, Nil)  -> Applic((tag_parse_exp operator),[])
+  | Pair(operator, operands) -> Applic((tag_parse_exp operator),(pair_to_list_exp operands))
+  | _ -> raise X_no_match
+
+  and pair_to_list_exp_without_begin pairs = match pairs with
+    | Pair(Pair(Symbol("begin"),exp),Nil) -> (pair_to_list_exp_without_begin exp)
+    | Pair(Pair(Symbol("begin"),exp),rest) -> (pair_to_list_exp_without_begin exp)@(pair_to_list_exp_without_begin rest)
+    | Pair(Symbol("begin"),exp) -> (pair_to_list_exp_without_begin exp)
+    | Pair(x,Nil) -> tag_parse_exp(x) :: []
+    | Pair(x,y) -> tag_parse_exp(x) :: (pair_to_list_exp_without_begin y)
+    | _ -> raise X_this_should_not_happen
+
+  and pair_to_list_exp pairs = match pairs with
+  | Pair(Symbol("begin"),exp) -> (pair_to_list_exp exp)
+  | Pair(x,Nil) -> tag_parse_exp(x) :: []
+  | Pair(x,y) -> tag_parse_exp(x) :: (pair_to_list_exp y)
+  | _ -> raise X_this_should_not_happen
+
+  and build_seq pairs = match pairs with
+  | Pair(Pair (Symbol("begin"), Nil),Nil) -> []
+  | Pair(Pair (Symbol("begin"), y),Nil) -> (build_seq y)
+  | Pair(x,Nil) -> tag_parse_exp(x) :: []
+  | Pair(x,y) -> tag_parse_exp(x) :: (build_seq y)
+  | _ -> raise X_this_should_not_happen
+
+  and tag_quasiquote exp = match exp with
+  | Pair(Symbol("unquote"), Pair(sexp,Nil)) -> sexp
+  | Pair(Symbol("unquote-splicing"), Pair(sexp,Nil)) -> raise X_this_should_not_happen
+  | Nil -> Pair(Symbol("quote"),Pair(Nil,Nil))
+  | Symbol(x) -> Pair(Symbol("quote"),Pair(Symbol(x),Nil))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(sexp,Nil)), cdr) -> Pair(Symbol("append"),Pair(sexp,Pair((tag_quasiquote cdr),Nil)))
+  | Pair(car,Pair(Symbol("unquote-splicing"),Pair(sexp,Nil))) -> Pair(Symbol("cons"),Pair((tag_quasiquote car), Pair(sexp,Nil)))
+  | Pair(car,cdr) -> Pair(Symbol("cons"), Pair((tag_quasiquote car), Pair((tag_quasiquote cdr), Nil)))
+  | _ -> exp
+
+  and tag_parse_let letExp = match letExp with
+  | Pair(bindings,body) -> Applic(LambdaSimple((tag_parse_vars_binding bindings), makeSeq((pair_to_list_exp_without_begin body))), (tag_parse_vals_binding bindings))
+  | _ -> raise X_this_should_not_happen
+
+  and tag_parse_vars_binding bindings = match bindings with
+  | Pair(Pair(Symbol(var),valPair),y) -> var :: (tag_parse_vars_binding y)
+  | _ -> []
+
+  and tag_parse_vals_binding bindings = match bindings with
+  | Pair(Pair(var, Pair(value,Nil)), y)-> (tag_parse_exp value) :: (tag_parse_vals_binding y)
+  | _ -> []
+
+  and tag_parse_let_star letStarExp = match letStarExp with
+  | Pair(Nil,body) -> Pair(Symbol ("let"), Pair(Nil, body))
+  | Pair(Pair(Pair(Symbol(variable), Pair(value,Nil)), Nil), body) -> Pair(Symbol ("let"), Pair(Pair(Pair(Symbol(variable), Pair(value,Nil)),Nil), body))
+  | Pair(Pair(Pair(Symbol(variable),Pair(value,Nil)), rest_of_pairs), body) -> Pair(Symbol("let"),Pair(Pair(Pair(Symbol(variable),Pair(value,Nil)), Nil), Pair(Pair(Symbol("let*"), Pair(rest_of_pairs,body)), Nil)))
+  | _ -> raise X_this_should_not_happen
+
+  and tag_parse_let_rec letRecExp = match letRecExp with
+  | Pair(Nil,body) -> Pair(Symbol("let"),Pair(Nil,body))
+  | Pair(bindings,body) -> Pair(Symbol("let"), Pair((tag_parse_letrec_bindings bindings), (tag_parse_letrec_body bindings body)))
+  | _ -> raise X_this_should_not_happen
+
+  and tag_parse_letrec_bindings bindings = match bindings with
+  | Pair(Pair(Symbol(var),valPair),Nil) -> Pair(Pair(Symbol(var), Pair(Pair(Symbol("quote"),Pair(Symbol("whatever"), Nil)), Nil)),Nil)
+  | Pair(Pair(Symbol(var),valPair),y) -> Pair(Pair(Symbol(var), Pair(Pair(Symbol("quote"),Pair(Symbol("whatever"), Nil)), Nil)),(tag_parse_letrec_bindings y))
+  | _ -> raise X_this_should_not_happen
+
+  and tag_parse_letrec_body bindings body = match bindings with 
+  | Pair(Pair(Symbol(var),valPair),y) -> Pair(Pair(Symbol("set!"), Pair(Symbol(var), valPair)),(tag_parse_letrec_body y body))
+  | _ -> Pair(Pair(Symbol("let"),Pair(Nil,body)),Nil)
+
+  and tag_parse_and_exp exps = match exps with
+  | Pair(firstexp, otherexps) -> Pair(Symbol("if"),Pair(firstexp, Pair(Pair(Symbol("and"), otherexps), Pair(Bool(false), Nil))))
+  | _ -> raise X_this_should_not_happen
+
+  and tag_parse_define_mit_exp variable argslist body = match body with
+  | Nil -> raise X_syntax_error
+  | _ -> Pair(Symbol "define", Pair(Symbol(variable), Pair(Pair(Symbol("lambda"), Pair(argslist,body)), Nil)))
+
+  and tag_parse_vars_binding_with_addition bindings = match bindings with
+  | Pair(Pair(Symbol(var),valPair),y) -> (var ^ "_1") :: (tag_parse_vars_binding_with_addition y)
+  | _ -> []
+
+  and tag_parse_pset psetExp = 
+    let list_of_exps = (tag_parse_vals_binding psetExp) in
+    let variable_names_as_list = (tag_parse_vars_binding psetExp) in
+    let variable_names_as_list_with_additions = (tag_parse_vars_binding_with_addition psetExp) in
+    let acc = ref [] in 
+    for i=0 to ((List.length list_of_exps)-1) do
+       acc := [Set(Var(List.nth variable_names_as_list_with_additions i),(List.nth list_of_exps i))]
+    done;
+    let acc2 = ref [] in
+    for i=0 to ((List.length list_of_exps)-1) do
+       acc2 := [Set(Var(List.nth variable_names_as_list i),Var(List.nth variable_names_as_list_with_additions i))]
+    done; 
+    Const(Void)
+
+  and tag_parse_cond_exp condExp = match condExp with
+  | Pair(Pair (Symbol "else", exp),rest) ->  Pair (Symbol("begin"), exp)
+  | Pair(Pair(test, Pair(Symbol("=>"), body)), Nil) ->  Pair (Symbol("let"),Pair(Pair(Pair(Symbol("value"),Pair(test,Nil)),Pair(Pair(Symbol("f"),Pair(Pair(Symbol("lambda"),
+                                                        Pair(Nil,body)),Nil)),Nil)),Pair(Pair(Symbol("if"),Pair(Symbol("value"),Pair(Pair(Pair(Symbol("f"), Nil), Pair(Symbol("value"), Nil)),
+                                                        Nil))),Nil))) 
+  | Pair(Pair(test, Pair(Symbol("=>"), body)), restconds) -> Pair(Symbol("let"), Pair(Pair(Pair(Symbol("value"),Pair(test,Nil)),Pair(Pair(Symbol("f"),Pair(Pair(Symbol("lambda"),Pair(Nil,
+                                                              body)),Nil)),Pair(Pair(Symbol("rest"),Pair(Pair(Symbol("lambda"),Pair(Nil,Pair((tag_parse_cond_exp restconds),Nil))),Nil)),Nil))),
+                                                              Pair(Pair(Symbol("if"), Pair (Symbol("value"),Pair(Pair(Pair (Symbol("f"), Nil), Pair(Symbol("value"), Nil)), Pair (Pair
+                                                              (Symbol("rest"), Nil), Nil)))),Nil)))
+  | Pair(Pair(test,exp),Nil) -> Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), exp), Nil)))
+  | Pair(Pair(test,exp),restcond) -> Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), exp), Pair((tag_parse_cond_exp restcond), Nil))))
+  | _ -> raise X_no_match;;
+
+  let tag_parse_expressions sexpr = (List.map tag_parse_exp sexpr);;
 
+end;;
+(* struct Tag_Parser *)
\ No newline at end of file
