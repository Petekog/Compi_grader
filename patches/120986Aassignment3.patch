diff --git a/reader.ml b/reader.ml
index 32445c2..e7d1db5 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,6 +1,6 @@
 
 #use "pc.ml";;
-
+open PC;;
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
   
@@ -40,7 +40,223 @@ let normalize_scheme_symbol str =
 	s) then str
   else Printf.sprintf "|%s|" str;;
 
+  let make_paired nt_left nt_right nt =
+    let nt = caten nt_left nt in
+    let nt = pack nt (function (_ , e)-> e) in
+    let nt = caten nt nt_right in
+    let nt = pack nt (function (e,_) ->e) in
+    nt;;
+
+  let word_ci_to_char wc n = pack (word_ci wc) (fun _-> char_of_int n) ;;
+  let nt_whitespaces = star(nt_whitespace);;
+  let make_spaced nt = make_paired nt_whitespaces nt_whitespaces nt;;
+  let dot_nt = char '.';;
+  let lparen_nt = make_spaced(char '(');;
+  let rparen_nt = make_spaced(char ')');;
+  let psic_nt = char ',';;
+  let divide_nt = char '/';;
+  let plus_nt = char '+';;
+  let minus_nt = char '-' ;;
+  let dig = range '0' '9' ;;
+  let digits = plus dig;;
+  let first = (function (e,_)->e);;
+  let second = (function (_,e)->e);;
+  let list_to_int lst = int_of_string (list_to_string lst);;
+  let char_of_float ch = float_of_int (Char.code ch - Char.code '0');;
+  let list_to_float lst = float_of_int(list_to_int lst);;
+  let sexp_star nt = star nt;;
+
+  let rec nt_line_comments s =
+    let nt_end_line = pack (caten (char '\n') nt_epsilon) (fun (e,s) -> e::s)  in
+    let nt_end = disj nt_end_of_input nt_end_line in
+    let nt_comment = caten (char ';') (star (diff nt_any nt_end)) in 
+    let nt = pack nt_comment (fun _ -> ()) in
+    nt s
+
+  and nt_sexpr_comments s = 
+    let nt_last = pack (caten (word_ci "#;") nt_sexp) (fun _ -> ()) in
+    let nt_previous = pack (caten (caten (word "#;") nt_sexpr_comments) nt_sexp) (fun _ -> ()) in
+    let nt = disj nt_last nt_previous in
+    nt s
+    
+  and nt_comments s = (disj nt_sexpr_comments nt_line_comments) s
+
+  and clear nt s =
+  let nt = pack nt_whitespace (fun _ -> ()) in
+  let nt = disj nt nt_comments in
+  nt s
+
+  and clear_for_nil s =
+  let nt = pack nt_whitespace (fun _ -> ()) in
+  let nt = disj nt nt_comments in
+  nt s
+
+  and nt_bool s = 
+    let nt_true = pack (word_ci "#t") (fun p -> Bool(true)) in
+    let nt_false = pack (word_ci "#f") (fun p-> Bool(false)) in 
+    let nt = disj nt_true nt_false in
+    nt s
+
+  and nt_char s = 
+    let nt_nul = word_ci_to_char "nul" 0 in
+    let nt_nl = word_ci_to_char "newline" 10  in
+    let nt_return = word_ci_to_char "return" 13 in
+    let nt_tab = word_ci_to_char "tab" 9  in
+    let nt_page  = word_ci_to_char "page" 12 in
+    let nt_bs = word_ci_to_char "space" 32 in
+    let nt_named_char = disj_list[nt_nul; nt_nl; nt_return; nt_tab; nt_page; nt_bs] in
+    let nt_visible_simple_char = range (char_of_int 32) (char_of_int 127) in (* have an ASCII value is larger than 32*)
+    let nt_chars = disj nt_named_char nt_visible_simple_char in
+    let nt_char_prefix = caten (word_ci "#\\") nt_chars in
+    let nt = pack nt_char_prefix (fun (e,c) -> Char(c)) in (*we are expexted to get [#\,c] and we want to construct Char(c)*)
+    nt s
+    
+  and nt_string s = 
+    let nt_return = word_ci_to_char "\\r" 13 in 
+    let nt_nl = word_ci_to_char "\\n" 10 in 
+    let nt_tab = word_ci_to_char "\\t" 9  in 
+    let nt_page = word_ci_to_char "\\f" 12 in 
+    let nt_bs = word_ci_to_char "\\\\" 92  in
+    let nt_dq = word_ci_to_char "\\\"" 34  in 
+    let nt_string_meta_char = disj_list [nt_dq; nt_nl; nt_tab; nt_page; nt_return; nt_bs ] in
+    let nt_chars = const (fun c -> c >= char_of_int 32) in 
+    let nt_strins_literal_char = diff (diff nt_chars (char '\\')) (char '\"') in
+    let nt_string_char = disj nt_strins_literal_char nt_string_meta_char in
+    let nt_content = star nt_string_char in 
+    let nt = make_paired (char '\"') (char '\"') nt_content in
+    let nt_make_string = pack nt (fun l -> String(list_to_string l)) in
+    nt_make_string s
+    
+  and nt_num s =
+    let pos_neg_nt s =
+      let pos_neg = maybe (disj plus_nt minus_nt) in
+      let pos_neg = pack pos_neg (function
+      | Some('+')-> 1
+      | Some('-')-> -1 
+      | None -> 1 
+      | _-> raise X_no_match) in
+      pos_neg s in
+    let nt_number_sign s =
+      let nt_number s =
+        let tok_int s = 
+          let prsr = pack digits (fun (e)-> Number(Fraction ((list_to_int e), 1))) in
+          prsr s in
+        let tok_float s = 
+          let right_side_float lst = 
+            let lst = List.map char_of_float lst in
+            List.fold_right (fun acc e -> ((acc +.e)/.10.0)) lst 0.0 in
+          let float_prsr = caten (caten digits dot_nt) digits in
+          let float_prsr = pack float_prsr (function (l,r)-> (list_to_float (first l)) +.(right_side_float r)) in
+          let float_prsr = pack float_prsr (function(e)-> Number(Float(e))) in
+          float_prsr s in
+        let tok_frac s = 
+          let char_list_to_frac lst =
+            let rec gcd a b = 
+              if b = 0 then a else gcd b (a mod b) in
+              let n1 = list_to_int (first (first lst)) in
+              let n2 = list_to_int (second lst) in
+              let dvsr = gcd n1 n2 in
+              Number(Fraction ((n1/dvsr),(n2/dvsr))) in
+          let nt = caten (caten digits divide_nt) digits in
+          let nt = pack nt (function (e)-> char_list_to_frac e)
+          in nt s in
+        let tok_num = disj_list [tok_frac;tok_float; tok_int] in
+        tok_num s in
+      let num_with_sign = caten pos_neg_nt nt_number in
+      let num_with_sign = pack num_with_sign (fun (n1,n2)-> match n2 with
+      | Number(Fraction(left,right)) -> Number(Fraction(left * n1,right))
+      | Number(Float(n2)) -> Number(Float(float n1 *. n2))
+      | _-> raise X_no_match) in
+      num_with_sign s in
+    let scientific_nt s =
+      let tok_int_scntf s= 
+        let prsr = pack digits (fun (e)-> (float_of_int(list_to_int e))) in
+        prsr s in
+      let tok_float_scntf s = 
+        let right_side_float lst = 
+          let lst = List.map char_of_float lst in
+          List.fold_right (fun acc e -> ((acc +.e)/.10.0)) lst 0.0 in
+        let float_prsr = caten (caten digits dot_nt) digits in
+        let float_prsr = pack float_prsr (function (l,r)-> (list_to_float (first l)) +.(right_side_float r)) in
+        float_prsr s in
+      let num_tok s= 
+        let num_with_sign = disj tok_float_scntf tok_int_scntf in
+        let num_with_sign = caten pos_neg_nt num_with_sign in
+        let num_with_sign = pack num_with_sign (function (l,r)-> float l *. r) in
+        num_with_sign s in 
+      let e_tok = pack (char_ci 'E') (fun (e)-> Char e) in
+      let sntfk_tok = caten num_tok e_tok in
+      let exponent_tok = caten sntfk_tok num_tok in
+      let exponent_tok = pack exponent_tok (function (l,r)-> (first l) *. (10. ** r)) in
+      let exponent_tok = pack exponent_tok (function (e)-> Number(Float(e))) in
+      exponent_tok s in
+    let nt = disj scientific_nt nt_number_sign in
+    let nt = not_followed_by nt nt_symbol in
+    nt s
+    
+  and nt_symbol s =
+    let special_symb = one_of "!$^*-_=+<>/?:" in
+    let symb = disj_list [special_symb; dig; range_ci 'A' 'Z';] in
+    let symb_plus = plus symb in
+    let with_dot = disj (plus dot_nt) symb_plus in 
+    let two_dot = pack (caten dot_nt with_dot) (fun (e, es) -> (e :: es)) in
+    let symb_plus = disj two_dot symb_plus in
+    let symb_plus = plus symb_plus in 
+    let symb_plus = pack symb_plus (fun (e)-> Symbol(String.lowercase_ascii (list_to_string (List.flatten (e))))) in
+    symb_plus s
+
+  and nt_nil s =
+    let left_p = char '(' in
+    let right_p = char ')' in
+    let nil = caten left_p (star clear_for_nil) in
+    let nil = caten nil right_p in
+    let nil = pack nil (fun _ -> Nil) in
+    nil s
+
+  and nt_qoutes s = 
+    let quote_str = "'" in
+    let nt_quote = word quote_str in
+    let nt_qquote = word "`" in
+    let nt_unquote = word "," in
+    let nt_unquotedSpliced = word ",@" in
+    let quotes = disj_list [nt_quote; nt_qquote;nt_unquotedSpliced; nt_unquote] in 
+    let res = caten quotes nt_sexp in
+    let quotes_pairing qt_str rest_exp = 
+      match qt_str with
+      | "'" -> Pair(Symbol("quote"),Pair(rest_exp,Nil))
+      | "`" -> Pair(Symbol("quasiquote"),Pair(rest_exp,Nil))
+      | ",@" -> Pair(Symbol("unquote-splicing"),Pair(rest_exp,Nil))
+      | "," -> Pair(Symbol("unquote"),Pair(rest_exp,Nil))
+      | _-> raise X_no_match
+      in
+    let res = pack res (fun (qt,rst)-> quotes_pairing (list_to_string(qt)) rst) in
+    res s
+      
+  and nt_imp_list s = 
+    let nt = caten (caten lparen_nt (star nt_sexp)) rparen_nt in
+    let nt = pack nt (fun ((lpar,sexps),rpar) -> List.fold_right (fun sexp aggr -> Pair(sexp,aggr)) sexps Nil) in
+    nt s
+
+  and nt_proper_list s = 
+    let sexp_plus = plus nt_sexp in
+    let nt = caten lparen_nt sexp_plus in
+    let nt = caten (caten nt dot_nt) nt_sexp in
+    let nt = caten nt rparen_nt in
+    let nt = pack nt (fun (((((lpar,plus),dot),star),rpar)) -> List.fold_right (fun sexp aggr -> Pair(sexp,aggr)) plus star ) in
+    nt s
+
+  and nt_pair s = ( disj nt_imp_list nt_proper_list ) s
+  
+  and make_clear nt s = ( make_paired (star (clear nt) ) (star (clear nt)) nt) s
+
+  and nt_sexp s= 
+    let nt = disj_list [nt_bool; nt_char; nt_num;nt_qoutes; nt_string; nt_symbol;nt_nil; nt_pair] in
+    (make_clear nt) s
 
-let read_sexprs string = raise X_not_yet_implemented;;
+  and nt_sexp_star s = 
+    let star_sexp = star nt_sexp in
+    let star_sexp = star_sexp (string_to_list s) in
+    first star_sexp
   
-end;; (* struct Reader *)
+  and read_sexprs string = nt_sexp_star string
+end;; (* struct Reader *) 
diff --git a/readme.txt b/readme.txt
index e69de29..a986e4b 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,9 @@
+Shvat Messica 208986752
+
+I (We) assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
\ No newline at end of file
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..b651248 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -69,17 +69,400 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
-
-let annotate_tail_calls e = raise X_not_yet_implemented;;
-
-let box_set e = raise X_not_yet_implemented;;
-
-let run_semantics expr =
-  box_set
-    (annotate_tail_calls
-       (annotate_lexical_addresses expr));;
+  let rec lexical_adress_analysis expr lambdas_args_list params =
+    (*this function searches for the first list (lambda params) that var is in. 
+      if it finds it returns the major index, if fails return -1. 
+      assumes that the list of params is from the newest (0) to the oldest.*)
+    let rec find_first_in_lists lists i lists_size = 
+      if(lists_size = i || (List.length lists) = 0)then (-1,-1)
+      else(
+        let minor = List.hd lists in
+        if minor > -1 then (i,minor) else find_first_in_lists (List.tl lists) (i+1) lists_size
+      ) in
+    
+    let find_var_in_list e params = 
+      let rec var_in_list_help e params i = 
+        if (String.equal e (List.hd params)) then i else var_in_list_help e (List.tl params) (i+1) in
+      if (List.mem e params) = true then (var_in_list_help e params 0) else -1 in
   
-end;; (* struct Semantics *)
-
-
+    let find_in_lists e lists = 
+      List.map (fun l -> find_var_in_list e l) lists in
+  
+    match expr with
+    | Const(exp) -> Const'(exp)
+    | Var(var) -> ( 
+      let minor =  find_var_in_list var params in
+      if minor != -1 then Var'(VarParam(var,minor))
+      else 
+      let lists_find_result = find_in_lists var lambdas_args_list  in
+      let res = find_first_in_lists lists_find_result 0 (List.length lambdas_args_list) in
+      match res with
+      | (-1,-1) -> Var'(VarFree(var))
+      | (major,minor) -> Var'(VarBound(var,major,minor)))
+    | LambdaSimple(args, body)-> LambdaSimple'(args,(lexical_adress_analysis body ([params] @ lambdas_args_list) args))
+    | LambdaOpt(args, opt, body) -> LambdaOpt'(args, opt,(lexical_adress_analysis body ([params] @ lambdas_args_list) (args@[opt])))
+    | Applic(operator, operands) -> Applic'((lexical_adress_analysis operator lambdas_args_list params) ,List.map (fun e-> (lexical_adress_analysis e lambdas_args_list params)) operands)
+    | If(test, dit, dif) -> If'((lexical_adress_analysis test lambdas_args_list params), (lexical_adress_analysis dit lambdas_args_list params), (lexical_adress_analysis dif lambdas_args_list params))
+    | Seq(expr_list) -> Seq'(List.map (fun e-> (lexical_adress_analysis e lambdas_args_list params)) expr_list)
+    | Set(var,value)-> (
+      let ret_var = (lexical_adress_analysis var lambdas_args_list params) in
+      match ret_var with
+      | Var'(var) -> Set'(var,(lexical_adress_analysis value lambdas_args_list params))
+      | _ -> raise X_no_match
+    )
+    | Def(var, value) -> (
+      let ret_var = (lexical_adress_analysis var lambdas_args_list params) in
+      match ret_var with
+      | Var'(var) -> Def'(var, (lexical_adress_analysis value lambdas_args_list params))
+      | _ -> raise X_no_match
+    )
+    | Or(bool_list)-> Or'(List.map (fun e-> (lexical_adress_analysis e lambdas_args_list params)) bool_list);;
+   
+  let rec tail_pos_annotation expr in_tp = 
+    let annotate_implicit_seq expr_list in_tp =
+    let list_reversed = List.rev expr_list in
+    let list_without_last = List.tl list_reversed in
+    let last_expr' = List.hd list_reversed in
+    let last_expr' = (tail_pos_annotation last_expr' in_tp) in
+    let list_without_last = List.rev list_without_last in
+    let list_without_last = List.map (fun e->tail_pos_annotation e false) list_without_last in
+    list_without_last @ [last_expr'] in
+  
+    match expr with
+    | Or'(bool_list)-> Or'(annotate_implicit_seq bool_list in_tp)
+    | If'(test, dit, dif) -> If'(tail_pos_annotation test false, tail_pos_annotation dit in_tp, tail_pos_annotation dif in_tp)
+    | Def'(var,value)-> Def'(var, tail_pos_annotation value in_tp)
+    | Set'(var,value)-> Set'(var,tail_pos_annotation value false )
+    | LambdaSimple'(args, body) -> LambdaSimple'(args, tail_pos_annotation body true)
+    | LambdaOpt'(args, opt, body) -> LambdaOpt'(args, opt ,tail_pos_annotation body true)
+    | Applic'(operator,operands) -> 
+      ( match in_tp with 
+      | true -> ApplicTP'(tail_pos_annotation operator false, List.map (fun e-> tail_pos_annotation e false) operands)
+      | false -> Applic'(tail_pos_annotation operator false, List.map (fun e -> tail_pos_annotation e false) operands)
+      )
+    | Seq'(expr_list) -> Seq'(annotate_implicit_seq expr_list in_tp)
+    | _ -> expr
+  
+  (*Boxing*)
+  let update_list rw_list var_name read_bool lexical_env= 
+    (*toadd = isreadvar/iswritevar = true than we want to add to lambdas list*)
+    let add_to_lambdas toadd list_lambda_env lambda_env = 
+      if toadd then lambda_env::list_lambda_env else [lambda_env] in
+  
+    List.map (fun elem -> 
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = elem in
+    if (String.equal name_of_var var_name) then (if(read_bool) then (to_box,main_lambda,curr_lambda,name_of_var,(true,(add_to_lambdas isreadvar lambda_env_list1 (curr_lambda,lexical_env))),(iswritevar,lambda_env_list2))
+    else (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(true,(add_to_lambdas iswritevar lambda_env_list2 (curr_lambda,lexical_env))))) else elem) !rw_list ;;
+  
+  let update_element_box elem  =
+    let rec find_shared_rib lex_env1 lex_env2 =
+      if ((List.length lex_env1) = 0 || (List.length lex_env2) = 0) then false else (if ((List.mem (List.hd lex_env1) lex_env2) = true && (List.length !(List.hd lex_env1) != 0)) then true else find_shared_rib (List.tl lex_env1) (lex_env2)) in
+    
+    let special_cond lex_env1 lex_env2 =
+      if (((List.length lex_env1) = 2) && ((List.length lex_env2) = 2) && ( ((List.hd lex_env1) == (List.hd lex_env2)) = false) &&  ( (List.hd(List.tl lex_env1)) == (List.hd (List.tl lex_env2)))) then true else false in
+  
+    let rec box_cond lambda_env_list1 lambda_env_list2 =
+      let rec pair_compare lambda_env_pair1 lambda_env_pair2 =
+        match lambda_env_pair1,lambda_env_pair2 with
+        |(l1,env1),(l2,env2) -> if((l1 != l2) && ((special_cond !env1 !env2)|| ((List.length !env1) = 0 || (List.length !env2) = 0)|| (find_shared_rib (List.tl !env1) (List.tl !env2)) = false)) then true else false in
+             
+      let rec box_cond_help lambda_env_pair lambda_env_list2 =
+        if (List.length lambda_env_list2) = 0 then false else (if (pair_compare lambda_env_pair (List.hd lambda_env_list2)) then true else box_cond_help lambda_env_pair (List.tl lambda_env_list2)) in
+      
+      if ((List.length lambda_env_list1) = 0 || (List.length lambda_env_list2 ) = 0) then false else (if (box_cond_help (List.hd lambda_env_list1) lambda_env_list2) then true else box_cond (List.tl lambda_env_list1) lambda_env_list2) in
+  
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = elem in
+    if (isreadvar = true && iswritevar = true && box_cond lambda_env_list1 lambda_env_list2) then
+    (true,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) else elem;;
+  
+  let get_var_name var_exp =
+    match var_exp with
+    | VarParam (var,_) -> var
+    | VarBound (var,_,_) -> var
+    | _ -> "" ;;
+  
+  (* get var, return its lexcial adress, returns its lexical address*)
+  let update_var expr rw_list read_bool lexical_env =
+    match expr with
+    | VarParam (v1,mn1) ->  List.map (update_element_box ) (update_list rw_list v1 read_bool lexical_env) 
+    | VarBound (v1,mj1,mn1) -> List.map (update_element_box) (update_list rw_list v1 read_bool lexical_env)
+    | _ -> !rw_list;;
+  
+  let update_mutual_vars box_list vars_mutual lambda_id lexical_env = 
+    List.map (fun elem -> 
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = elem in
+    if (List.mem name_of_var vars_mutual) then (false,lambda_id,lambda_id,name_of_var,(false,[]),(false,[])) else (to_box,main_lambda,lambda_id,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2))) !box_list ;;
+  
+  let box_var_name e = 
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+    name_of_var;;
+  
+  let create_elem vars lambda_id lex_env =
+    let elements = List.map (fun e -> (false,lambda_id,lambda_id,e,(false,[]),(false,[]))) vars in
+    elements ;;
+  
+  let rec apply_boxing vars_to_box expr =
+    let apply_box = apply_boxing vars_to_box in
+    
+    let lambda_box_handle args body = 
+      let filtered_vars = ref (List.filter (fun e -> ((List.mem (box_var_name e) args) = false)) !vars_to_box) in
+      apply_boxing filtered_vars body in
+    
+    let var_to_box_names = List.map box_var_name !vars_to_box in
+  
+    match expr with
+    | Var'(v_exp) -> let var_name = get_var_name v_exp in
+                     if(List.mem var_name var_to_box_names) then BoxGet'(v_exp) else expr
+    | If'(t1, th1, el1)-> If'(apply_box t1,apply_box th1, apply_box el1)
+    | Seq'(l1) -> Seq'(List.map (fun e-> (apply_box e)) l1)
+    | Or'(l1) -> Or'(List.map (fun e-> (apply_box e)) l1)
+    | Set'(var1, val1) -> let var_name = (get_var_name var1) in
+                          if(List.mem var_name var_to_box_names) then BoxSet'(var1, apply_box val1) 
+                          else Set'(var1, apply_box val1) 
+    | Def'(var1, val1) -> Def'(var1,apply_box val1)
+    | LambdaSimple'(vars1, body1) ->  LambdaSimple'(vars1, lambda_box_handle vars1 body1)
+    | LambdaOpt'(vars1, var1, body1) ->  LambdaOpt'(vars1, var1, (lambda_box_handle (vars1@[var1]) body1))
+    | Applic'(e1, args1) ->  Applic'(apply_box e1, List.map apply_box args1)
+    | ApplicTP'(e1, args1) -> ApplicTP'(apply_box e1, List.map apply_box args1)
+    | _ -> expr
+  
+  and needBoxing e = 
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+    if (to_box) then true else false 
+  
+  and lambda_boxing args body box_list counter lexical_env = 
+    let box_names = List.map box_var_name !box_list in
+    
+    (*gets a list of refs of ribs (List.tl !lexical_env) and returns a list of refs of ribs without params in it*)
+    let rec lexical_env_without_mutual_params lexical_env args new_list =
+      if (List.length lexical_env) != 0 then
+      (
+        let rib_hd = (List.hd lexical_env) in
+        ignore (rib_hd := List.filter (fun e-> (List.mem e args)=false) !rib_hd);
+        ignore(new_list := !new_list@[rib_hd]);
+        lexical_env_without_mutual_params (List.tl lexical_env) args new_list
+      )
+      else () in
+    
+    let mutual_params_remover_wrapper args lexical_env new_list =
+      match args with
+      |[]-> lexical_env
+      |_-> ignore (lexical_env_without_mutual_params lexical_env args new_list); !new_list
+      in
+    
+    let mutual_elem list_of_args e = 
+      let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+      if (List.mem name_of_var list_of_args) then true else false in
+  
+    let unmutual_elem list_of_args e = 
+      let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+      if (List.mem name_of_var list_of_args) then false else true in
+    
+    let update_curr_lambda e  = 
+      let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+      if (main_lambda != curr_lambda) then (to_box,main_lambda,curr_lambda-1,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) else (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) in
+    
+    let update_list_curr_lambda list_elem = 
+      List.map update_curr_lambda list_elem in
+  
+    let var_of_lambda lambda_id e = 
+      let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+      if (main_lambda = lambda_id) then true else false in
+    
+    let rec get_index var var_list i =
+      if List.hd var_list = var then i else  get_index var (List.tl var_list) (i+1) in
+    
+    (*update box list*)
+    let lambda_id = counter() in
+    let vars_unmutual_of_args = List.filter (fun e -> (List.mem e box_names) = false) args in
+    let vars_mutual = List.filter (fun e -> List.mem e box_names) args in
+    (*filtering lexical env from any mutual arguments*)
+    ignore (if(List.length !lexical_env > 0 ) then (
+    let new_rib = (List.hd !lexical_env) in
+    let new_lexcial_env = ref[] in
+    ignore (lexical_env := [new_rib]@(mutual_params_remover_wrapper args (List.tl (!lexical_env)) new_lexcial_env));
+    ));
+    let vars_unmutual_of_args = create_elem vars_unmutual_of_args lambda_id lexical_env in
+    let list_backup_mutual = List.filter (fun e -> mutual_elem args e) !box_list in
+    (*replace lambdas boxing arguments*)
+    ignore (box_list := ((update_mutual_vars box_list vars_mutual lambda_id lexical_env)@vars_unmutual_of_args));
+    let new_body = check_for_box counter lexical_env box_list body in
+    ignore (box_list := update_list_curr_lambda !box_list);
+    let list_new_unmutual = List.filter (fun e -> unmutual_elem args e) !box_list in
+    let needbox_list =ref (List.filter(fun e -> needBoxing e) !box_list) in
+    let new_body = (apply_boxing needbox_list new_body) in
+    let vars_of_this_lambda = List.filter (fun e -> var_of_lambda lambda_id e) !needbox_list in
+    let vars_of_lambda_names = List.map box_var_name vars_of_this_lambda in
+    let new_args = List.map (fun var_name -> (
+      let minor = get_index var_name args 0 in 
+      Set'((VarParam(var_name, minor)), Box'(VarParam(var_name, minor))))) (vars_of_lambda_names) in
+    let new_body_with_box = (match new_args,new_body with
+      |[],_ -> new_body
+      | _,Seq'(l) ->Seq'(new_args@l) 
+      |_,_ ->Seq'(new_args@[new_body])
+      )  in
+    ignore (box_list := list_new_unmutual @ list_backup_mutual);
+    new_body_with_box  
+  
+  and cut_list l b e i = 
+    if((List.length l) = 0 || i = (e+1)) then [] else (if(i >= b && i<=e) then [(List.hd l)]@(cut_list (List.tl l) b e (i+1)) else (cut_list (List.tl l) b e (i+1)))
+  
+  and check_for_true_boxes box_lst =
+    let filter_box = List.filter needBoxing !box_lst in
+    List.map box_var_name filter_box 
+  
+  (*given a read_index, a clean original box_list and exp_list, this function runs from read occ to 0 the check for box
+  and returns the to_box = true that exists on this list.*)  
+  and list_till_read read_index exp_list box_list lexical_env lambda_id_generator =
+    let till_read_oc_list = (cut_list exp_list 0 read_index 0) in
+    ignore(List.map (check_for_box lambda_id_generator lexical_env box_list) till_read_oc_list);
+    let true_boxes = check_for_true_boxes box_list in
+    true_boxes
+    
+  and list_till_write write_index exp_list box_list lexical_env lambda_id_generator =
+    let till_write_oc_list = cut_list exp_list 0 write_index 0 in
+    ignore(List.map (check_for_box lambda_id_generator lexical_env box_list) till_write_oc_list);
+    let true_boxes = check_for_true_boxes box_list in
+    true_boxes
+  
+  and update_lists_by_rw lexical_env i len exp_list box_list to_box_ref lambda_id_generator =
+    if((List.length exp_list) = 0 || i = len) then () else(
+      let exp = (List.hd exp_list) in 
+      match exp with
+      | Var'(v_exp)-> to_box_ref := !to_box_ref @ (list_till_read i exp_list (ref (!box_list)) lexical_env lambda_id_generator)
+      | Set'(var1, val1) -> to_box_ref := !to_box_ref @ (list_till_write i exp_list (ref (!box_list)) lexical_env lambda_id_generator)
+      | Def'(var1, val1) -> to_box_ref := !to_box_ref @ (list_till_write i exp_list (ref (!box_list)) lexical_env lambda_id_generator)
+      | _ -> ())
+  
+  (*we update new_box_Ref with all the read/write in box_lists. we adding variables that need boxings in those lists to the to_box_list immdediatly.*)     
+  and handle_seq lambda_id_generator lexical_env box_list exp_list =
+    let check = check_for_box lambda_id_generator lexical_env box_list in
+    
+    let is_RW_occ exp =
+      match exp with
+      | Var'(v_exp)-> true
+      | Set'(var1, val1) -> true
+      | Def'(var1, val1) -> true
+      | _ -> false in
+  
+    let is_R_occ exp =
+      match exp with
+      | Set'(var1, val1) -> true
+      | Def'(var1, val1) -> true
+      | _ -> false in
+  
+    let update_rw_var box_list lexical_env exp =
+      match exp with
+      | Var'(v_exp)->  box_list := (update_var v_exp box_list true lexical_env)
+      | Set'(var1, val1) -> box_list := (update_var var1 box_list false lexical_env)
+      | Def'(var1, val1) -> box_list := (update_var var1 box_list false lexical_env)
+      | _ -> () in
+  
+    let update_box_elemnt need_box_vars e =
+      let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+      if(List.mem name_of_var need_box_vars) then (true,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) else e in
+  
+    let update_boxes_list box_list need_box_vars =
+      box_list := List.map (update_box_elemnt need_box_vars) !box_list in
+    
+    let return_write_val exp =
+      match exp with
+      | Set'(var1, val1) -> val1
+      | Def'(var1, val1) -> val1
+      | _ -> raise X_no_match in
+  
+    let rw_vals exp_list =
+      let exps_rw = List.filter (is_R_occ) exp_list in
+      List.map (return_write_val) exps_rw in
+    
+    let update_with_rw exp_list box_list lexical_env =
+      let rw_list = List.filter is_RW_occ exp_list in
+      List.map (update_rw_var box_list lexical_env) rw_list in
+    
+    let clean_box_list = ref (!box_list) in
+    let clean_box_list1 = ref (!box_list) in
+    let exps_without_rw = List.filter (fun e-> if(is_RW_occ e) = true then false else true) exp_list in
+    let exps_without_rw = exps_without_rw @ (rw_vals exp_list) in
+    (*updating the normal exps in seq first with box_list*)
+    ignore (List.map (check) exps_without_rw);
+    (*checking with clean_box_list the read/write with proper exps -> getting to_box list*)
+    let need_box_list = ref [] in
+    ignore (update_lists_by_rw lexical_env 0 (List.length exp_list) exp_list clean_box_list need_box_list lambda_id_generator);
+    ignore (update_boxes_list box_list !need_box_list);
+    let needbox_list =ref (List.filter(fun e -> needBoxing e) !box_list) in
+    let new_l = List.map (apply_boxing needbox_list) exp_list in
+    ignore (update_boxes_list clean_box_list1 (List.map box_var_name !needbox_list));
+    ignore (update_with_rw exp_list clean_box_list1 lexical_env);
+    ignore(box_list := !clean_box_list1);
+    Seq'(new_l)
+  
+  and update_box_elem need_box_vars e =
+    let (to_box,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) = e in
+    if(List.mem name_of_var need_box_vars) then (true,main_lambda,curr_lambda,name_of_var,(isreadvar,lambda_env_list1),(iswritevar,lambda_env_list2)) else e 
+  
+  and update_box_list box_list need_box_vars =
+    box_list := List.map (update_box_elem need_box_vars) !box_list 
+  
+  and check_for_true_box box_lst =
+    let filter_box = List.filter needBoxing !box_lst in
+    List.map box_var_name filter_box 
+  
+  and check_for_box lambda_id_generator lexical_env box_list expr =
+    let check = check_for_box lambda_id_generator lexical_env box_list in
+    let check2 = check_for_box lambda_id_generator lexical_env  in
+    match expr with
+    | Var'(v_exp) -> ( box_list := (update_var v_exp box_list true lexical_env ) ; expr)
+    | If'(t1, th1, el1)-> (
+      let t1_new = check t1 in
+      let th1_list = ref (!box_list) in
+      let el1_list = ref (!box_list) in
+      let body_th1 = check2 th1_list th1 in
+      let body_el1 = check2 el1_list el1 in
+      let update = (check_for_true_box th1_list) @ (check_for_true_box el1_list) in
+      ignore (update_box_list th1_list update);
+      ignore (update_box_list el1_list update);
+      ignore (update_box_list box_list update);
+      If' (check t1_new,check2 th1_list body_th1, check2 el1_list body_el1))
+    | Seq'(l1) -> handle_seq lambda_id_generator lexical_env box_list l1
+    | Or'(l1) -> Or'(List.map (fun e-> check e) l1)
+    | Set'(var1, val1) ->(
+       (box_list := update_var var1 box_list false lexical_env ) ;
+      let new_val = check val1  in Set'(var1,new_val)) 
+    | Def'(var1, val1) -> (
+      (box_list := update_var var1 box_list false lexical_env ) ;
+      let new_val = check val1 in Def'(var1,new_val))
+    | LambdaSimple'(vars1, body1) ->(
+      if(List.length vars1 != 0) then LambdaSimple'(vars1, (lambda_boxing vars1 body1 box_list lambda_id_generator (ref ([(ref vars1)]@ (!lexical_env))))) else LambdaSimple'(vars1, (lambda_boxing vars1 body1 box_list lambda_id_generator lexical_env))) 
+    | LambdaOpt'(vars1, var1, body1) -> ( 
+      if(List.length (vars1@[var1]) != 0) then LambdaOpt'(vars1, var1, (lambda_boxing (vars1@[var1]) body1 box_list lambda_id_generator (ref ([(ref (vars1@[var1]))]@(!lexical_env))))) else  LambdaOpt'(vars1, var1, (lambda_boxing (vars1@[var1]) body1 box_list lambda_id_generator lexical_env)))
+    | Applic'(e1, args1) -> 
+     let new_op = check e1 in
+      let new_rands = List.map (fun e-> check e) args1 in
+      Applic'(new_op, new_rands)
+    | ApplicTP'(e1, args1) -> 
+      let new_op = check e1 in
+      let new_rands = List.map (fun e-> check e) args1 in
+      ApplicTP'(new_op, new_rands)
+    | _ -> expr
+  
+  and counter_factory() = 
+      let num = ref 0 in
+      let cf() = (num :=(!num+1);!num) in cf
+  
+  and annotate_lexical_addresses e = 
+    lexical_adress_analysis e [] []
+  
+  and annotate_tail_calls e = tail_pos_annotation e false
+  
+  and box_set e =
+    let counter = counter_factory() in
+    check_for_box counter (ref []) (ref []) e
+  
+  and run_semantics expr = 
+    (box_set
+      (annotate_tail_calls
+         (annotate_lexical_addresses expr)));;
+    
+  end;; (* struct Semantics *) 
+  
+  
\ No newline at end of file
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..7d089c7 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -58,8 +58,301 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let rec tag_parse s =
+  match s with 
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | String(x) -> Const(Sexpr(String(x)))
+  | Symbol(x) -> variable_parser x
+  | Pair (Symbol ("unquote") , Pair (x, Nil)) -> Const(Sexpr(x)) 
+  | Pair (Symbol ("quote") , Pair (x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("or"), x) ->  disj_parser x
+  | Pair(Symbol("set!"), Pair(Symbol(var), Pair(value, Nil))) -> set_parser var value
+  | Pair(Symbol("lambda"), Pair(Nil, body)) -> make_simple_lambda [] body 
+  | Pair(Symbol("lambda"), Pair(args,body)) -> lambda_parser args body 
+  | Pair(Symbol("and"), x) -> (tag_parse (and_macro x))
+  | Pair(Symbol("if"), Pair(test, Pair(dit, dif_op))) -> if_parser test dit dif_op 
+  | Pair(Symbol("define"), Pair(Pair(name, args), expr)) -> (tag_parse (define_macro name args expr))
+  | Pair(Symbol("define"),Pair(Symbol(name),Pair(expr,Nil))) -> define_parser name expr
+  | Pair(Symbol("letrec"), Pair(Nil, body)) -> (tag_parse (make_simple_lambda_for_let_macros body))
+  | Pair(Symbol("letrec"), Pair(ribs, body)) -> (tag_parse (letrec_macro ribs body))
+  | Pair(Symbol("let"), Pair(Nil, body)) -> (tag_parse (make_simple_lambda_for_let_macros body))
+  | Pair(Symbol("let"), Pair(args, body)) -> (tag_parse (let_macro (get_args_var args) body (get_args_val args)))
+  | Pair(Symbol("let*"), Pair(Nil, body)) -> (tag_parse (make_simple_lambda_for_let_macros body))
+  | Pair(Symbol("let*"), Pair(args, body)) -> (tag_parse (let_star_macro args body))
+  | Pair(Symbol("pset!"), sets) -> tag_parse (pset_parser sets)
+  | Pair(Symbol("begin"), seq) -> seq_explicit_parser seq
+  | Pair (Symbol("quasiquote"), Pair(symb,Nil)) -> tag_parse(quasi_qoute_parser symb)
+  | Pair(Symbol "cond",ribs) -> tag_parse (cond_macro_parser ribs)
+  | Pair(operator, operands) -> application_parser operator operands  
+  | _ -> raise X_no_match
 
+and make_simple_lambda_for_let_macros body = 
+  Pair(Pair(Symbol("lambda"), Pair(Nil, body)),Nil)
+
+and cond_macro_parser sexp =
+  match sexp with
+    | Pair(Pair(test, Pair (Symbol "=>",exprf)),Nil) -> 
+      Pair (Symbol "let",Pair(Pair (Pair (Symbol "value", Pair (test, Nil)),
+      Pair(Pair (Symbol "f", Pair(Pair (Symbol "lambda",Pair (Nil,exprf)),Nil)),Nil)),Pair(Pair (Symbol "if",Pair (Symbol "value",Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),Nil))),Nil)))
+      
+    | Pair (Pair (test, Pair (Symbol "=>",exprf)),ribs) ->
+      Pair (Symbol "let",Pair(Pair (Pair (Symbol "value", Pair (test, Nil)),
+      Pair(Pair (Symbol "f",Pair (Pair (Symbol "lambda", Pair (Nil, exprf)),Nil)),
+      Pair(Pair (Symbol "rest",Pair (Pair (Symbol "lambda", Pair (Nil, Pair (cond_macro_parser ribs, Nil))),Nil)),Nil))),
+      Pair(Pair (Symbol "if",Pair (Symbol "value",Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
+      Pair (Pair (Symbol "rest", Nil), Nil)))),Nil)))
+    
+    | Pair(Pair(Symbol "else", exprs),_)-> Pair (Symbol "begin", exprs)
+  
+    | Pair(Pair (test, exp_list), Nil)-> Pair(Symbol "if",Pair(test,Pair (Pair (Symbol "begin",exp_list), Nil)))
+    
+    | Pair(Pair(test ,exp_list),ribs) ->
+      Pair(Symbol "if",Pair (test, Pair (Pair (Symbol "begin",exp_list), Pair((cond_macro_parser ribs), Nil))))
   
-end;; (* struct Tag_Parser *)
+    |_->raise X_no_match
+
+and quasi_qoute_parser sexp =
+  match sexp with
+  | Nil -> Pair(Symbol("quote"),Pair(Nil,Nil))
+  | Pair(Symbol("unquote"), Pair(sexpr,Nil)) -> sexpr
+  | Pair(Symbol("unquote-splicing"), Pair(sexpr,Nil)) -> raise X_syntax_error
+  | Symbol(x)-> Pair(Symbol("quote"),Pair(Symbol(x),Nil))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(sexpr,Nil)),b) -> Pair(Symbol("append"),Pair(sexpr, Pair((quasi_qoute_parser b), Nil)))
+  | Pair(a,Pair(Symbol("unquote-splicing"),Pair(sexpr,Nil))) -> Pair(Symbol("cons"),Pair(quasi_qoute_parser a, Pair(sexpr,Nil)))
+  | Pair(car,cdr)-> Pair(Symbol("cons"),Pair((quasi_qoute_parser car),Pair((quasi_qoute_parser cdr),Nil)))
+  |_-> raise(X_no_match)
+
+and get_args_var sexp =
+  match sexp with
+  | Nil -> Nil
+  | Pair(Symbol(var),Pair(value,Nil)) -> Symbol(var)
+  | Pair(Pair(Symbol(var),value),Nil) -> Pair(Symbol(var),Nil)
+  | Pair(var1,rest) -> Pair(get_args_var var1 ,get_args_var rest)
+  |_-> raise(X_no_match)
+
+and get_args_val sexp =
+  match sexp with
+  | Nil -> Nil
+  | Pair(Symbol(var),Pair(value,Nil)) -> value
+  | Pair(Pair(Symbol(var),value),Nil) -> value
+  | Pair(var1,rest) -> Pair(get_args_val var1 ,get_args_val rest)
+  |_-> raise(X_no_match) 
+
+and let_macro vars body vals =
+Pair(Pair(Symbol "lambda",Pair(vars,body)),vals)
+
+and let_star_macro arg_list body =
+  match arg_list with
+  | Nil -> Pair(Symbol "let",Pair(Nil,Pair (body, Nil)))
+  | Pair(arg,Nil) -> Pair(Symbol "let",Pair (Pair (arg,Nil),body)) 
+  | Pair (arg1,rst) -> Pair (Symbol "let", Pair (Pair (arg1,Nil),Pair ((let_star_macro rst body),Nil)))
+  | _-> raise X_no_match
+
+and seq_explicit_parser seq =
+  match seq with
+  | Nil -> Const(Void)
+  | Pair(sexpr, Nil) -> tag_parse sexpr 
+  | sexp_list -> Seq(make_exp_list sexp_list) 
+
+and seq_implicit_parser seq = 
+  match seq with
+  | Nil -> raise X_not_yet_implemented
+  | Pair(e,Nil) -> tag_parse e
+  | Pair(e1,e2) -> Seq(make_exp_list seq)
+  | _ -> tag_parse seq 
+
+and if_parser test dit dif_op = 
+  match dif_op with
+  | Pair(dif, Nil) -> If((tag_parse test), (tag_parse dit), (tag_parse dif)) 
+  | Nil -> If((tag_parse test), (tag_parse dit), Const(Void))
+  | _ -> raise X_syntax_error
+
+and define_parser name expr = 
+  Def( (variable_parser name), (tag_parse expr) )
+
+and variable_parser s = 
+  if(not (List.mem s reserved_word_list)) then (Var(s))
+  else   (raise X_syntax_error) 
+     
+and application_parser operator operands = 
+  Applic((tag_parse operator) , (make_exp_list operands))
+
+and make_exp_list s = 
+  match s with
+  | Nil -> []
+  | Pair(first, Nil) -> [tag_parse first]
+  | Pair(first,rest) -> [tag_parse first] @ (make_exp_list rest)
+  | x -> [tag_parse x]
+        
+
+and disj_parser s =
+ match s with 
+ | Nil -> Const(Sexpr(Bool(false)))
+ | Pair(first,Nil) -> tag_parse first
+ | Pair(first,second) -> Or(make_exp_list s)
+ | _ -> raise X_syntax_error
+
+and set_parser var value =
+ Set( (variable_parser var), (tag_parse value) )
+ 
+
+ and args_to_list args =
+  match args with
+  | Nil -> []
+  | Pair(Symbol(first), rest) -> [first] @ (args_to_list rest)
+  | Symbol(first) -> [first]
+  | _ -> raise X_not_yet_implemented
+
+and is_proper_list arg_list = 
+  match arg_list with
+  | Pair(Symbol(first),rest) -> check_simple_lambda rest
+  | Nil -> true
+  | _ -> false
+
+and check_simple_lambda arg_list = 
+  is_proper_list arg_list
+
+and check_opt_lambda arg_list = 
+  (List.length arg_list) > 1
+ 
+and check_lambda_type args arg_list = 
+  if(check_simple_lambda args) then ("simple")
+  else(
+    if(check_opt_lambda arg_list) then ("opt")
+    else("variadic"))
+
+and make_simple_lambda arg_list body = 
+ LambdaSimple(arg_list, (seq_implicit_parser body))
+
+and make_opt_lambda arg_list body = 
+  let mand = (List.rev (List.tl (List.rev arg_list))) in
+  let opt = (List.hd (List.rev arg_list)) in 
+  LambdaOpt(mand, opt, (seq_implicit_parser body))
+
+and make_variadic_lambda arg_list body = 
+  let opt = (List.hd (List.rev arg_list)) in
+  LambdaOpt([], opt, (seq_implicit_parser body))
+
+and validiate_args_list arg_list = 
+  match arg_list with
+  | [] -> true
+  | _ ->
+    (let hd = (List.hd arg_list) in
+    let tl = (List.tl arg_list) in 
+    let len = (List.length arg_list) in
+    if(len <= 1) then (true)
+    else(
+      if(List.mem hd tl) then (false)
+      else (validiate_args_list tl)
+    ))
+
+and lambda_parser args body =
+  let arg_list = args_to_list args in
+  if((validiate_args_list arg_list)) then
+    (let lambda_type = check_lambda_type args arg_list in 
+    match lambda_type with
+    | "simple" -> make_simple_lambda arg_list body
+    | "opt" -> make_opt_lambda arg_list body
+    | "variadic" -> make_variadic_lambda arg_list body
+    | _ -> raise X_syntax_error)
+  else(raise X_syntax_error)  
+
+and and_macro sexpr = 
+  match sexpr with
+  | Nil -> Bool(true)
+  | Pair(x,Nil) -> x
+  | Pair(x , rest ) -> Pair(
+                        Symbol("if"), 
+                         Pair(x, 
+                          Pair(Pair(Symbol("and"), 
+                                    rest), 
+                                Pair(Bool(false),
+                                  Nil))))
+  | _ -> raise X_syntax_error
+
+and define_macro name args_list expr =
+  Pair(Symbol("define"), 
+       Pair (name, 
+            Pair (Pair( Symbol ("lambda"),
+                              Pair (args_list,expr))
+                 ,Nil)))
+
+and letrec_macro_ribs ribs = 
+match ribs with
+| Nil -> Nil
+| Pair(Pair(f, Pair(expr, Nil)), rest) -> Pair(Pair(f, Pair(Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)), Nil)), (letrec_macro_ribs rest))
+| _ -> raise X_syntax_error
+
+and letrec_macro_body ribs body = 
+  match ribs with
+  | Nil -> Pair(Pair(Symbol("let"), Pair(Nil, body)),Nil)
+  | Pair(Pair(f, Pair(expr, Nil)), rest) -> Pair(Pair(Symbol("set!"), Pair(f, Pair(expr, Nil))), (letrec_macro_body rest body))
+  | _ -> raise X_syntax_error
+
+and letrec_macro ribs body = 
+  Pair(Symbol("let"), Pair((letrec_macro_ribs ribs),(letrec_macro_body ribs body)))
+
+and pset_parser sets =
+  let rec get_vars sets =
+    match sets with
+    | Pair(Pair(Symbol(x),y),rest) -> x:: (get_vars rest)
+    | Nil -> []
+    | _ -> raise X_syntax_error in
+  
+  let rec find_unique_name var var_list =
+    let add_unique_sign e = (list_to_string ('~':: string_to_list e)) in
+    let var_name = add_unique_sign var in
+    if (List.mem var_name var_list) = false then var_name else find_unique_name var_name var_list in
+    
+  let rec make_unique_vars vars =
+    let setify l =
+      List.fold_left (fun a x -> a@[(find_unique_name x a)]) [] l in
+    setify vars in
+    (*List.map find_unique_name var_list in*)
+
+  (*let rec make_unique_vars vars =
+    let add_unique_sign e = (list_to_string ('$':: string_to_list e)) in
+    List.map add_unique_sign vars in*)
+  
+  let rec make_args arg_list = 
+    match arg_list with
+    | (e :: rest) -> Pair(Symbol e,make_args rest)
+    | [] -> Nil in
+  
+  let rec make_body old_vars new_vars =
+    match old_vars with
+    | (e :: rest) -> Pair(Pair(Symbol "set!", Pair(Symbol e, Pair(Symbol(List.hd new_vars),Nil))), make_body rest (List.tl new_vars))
+    | [] -> Nil in
+  
+  let rec get_bindings sets = 
+    match sets with
+    | Pair(Pair(Symbol x,Pair(y,Nil)),rest) -> Pair(y,get_bindings rest)
+    | Nil -> Nil
+    | _ -> raise X_syntax_error in
+
+  let vars_list = get_vars sets in
+  let unique_var_list = make_unique_vars vars_list in
+  let arg_list = make_args unique_var_list in
+  let body = make_body vars_list unique_var_list in
+  let vals = get_bindings sets in
+  Pair(Pair(Symbol "lambda", Pair(arg_list, body)),vals)
+  
+and tag_parse_expressions sexpr = List.map tag_parse sexpr;;
+
+end;;(* struct Tag_Parser *)
+
+
+
+
+
+
+
+  
+
+
+
+
+
 
